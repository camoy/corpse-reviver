@inproceedings{takikawa2016,
 author = {Takikawa, Asumu and Feltey, Daniel and Greenman, Ben and New, Max S. and Vitek, Jan and Felleisen, Matthias},
 title = {Is Sound Gradual Typing Dead?},
 booktitle = {Proceedings of the 43rd Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages},
 series = {POPL '16},
 year = {2016},
 isbn = {978-1-4503-3549-2},
 location = {St. Petersburg, FL, USA},
 pages = {456--468},
 numpages = {13},
 url = {http://doi.acm.org/10.1145/2837614.2837630},
 doi = {10.1145/2837614.2837630},
 acmid = {2837630},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {Gradual typing, performance evaluation},
}

@inproceedings{greenman2019,
 author = {Greenman, Ben and Takikawa, Asumu and New, Max S. and Feltey, Daniel and Findler, Robert Bruce and Vitek, Jan and Felleisen, Matthias},
 title = {How to Evaluate the Performance of Gradual Typing Systems},
 journal = {Journal of Functional Programming},
 volume = {29},
 number = {e4},
 year = {2019},
 doi = {https://doi.org/10.1017/S0956796818000217}
}

@inproceedings{greenman2017,
 author = {Greenman, Ben and Migeed, Zeina},
 title = {On the Cost of Type-tag Soundness},
 booktitle = {Proceedings of the ACM SIGPLAN Workshop on Partial Evaluation and Program Manipulation},
 series = {PEPM '18},
 year = {2018},
 isbn = {978-1-4503-5587-2},
 location = {Los Angeles, CA, USA},
 pages = {30--39},
 numpages = {10},
 url = {http://doi.acm.org/10.1145/3162066},
 doi = {10.1145/3162066},
 acmid = {3162066},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {D-deliverable, Migratory typing, Performance evaluation, Tag soundness, Type granularity},
}

@article{feltey2018,
 author = {Feltey, Daniel and Greenman, Ben and Scholliers, Christophe and Findler, Robert Bruce and St-Amour, Vincent},
 title = {Collapsible Contracts: Fixing a Pathology of Gradual Typing},
 journal = {Proc. ACM Program. Lang.},
 issue_date = {November 2018},
 volume = {2},
 number = {OOPSLA},
 month = oct,
 year = {2018},
 issn = {2475-1421},
 pages = {133:1--133:27},
 articleno = {133},
 numpages = {27},
 url = {http://doi.acm.org/10.1145/3276503},
 doi = {10.1145/3276503},
 acmid = {3276503},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {contracts, gradual typing, migratory typing, runtime support},
}

@article{andersen2018,
 author = {Andersen, Leif and St-Amour, Vincent and Vitek, Jan and Felleisen, Matthias},
 title = {Feature-Specific Profiling},
 journal = {ACM Trans. Program. Lang. Syst.},
 issue_date = {March 2019},
 volume = {41},
 number = {1},
 month = dec,
 year = {2018},
 issn = {0164-0925},
 pages = {4:1--4:34},
 articleno = {4},
 numpages = {34},
 url = {http://doi.acm.org/10.1145/3275519},
 doi = {10.1145/3275519},
 acmid = {3275519},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {Profiling, performance monitoring},
}

@InProceedings{Nguyen2018Soft,
    title={Soft contract verification for higher-order stateful programs},
    author={Nguyễn, Ph{\'u}c C. and Gilray, Thomas and Tobin-Hochstadt, Sam and Van Horn, David},
    journal={Proceedings of the ACM Symposium on Principles of Programming Languages (POPL)},
    volume={2},
    number={POPL},
    pages={51},
    year={2018},
    publisher={ACM}
}

@article{darais2017adi,
 author = {Darais, David and Labich, Nicholas and Nguyễn, Ph\'{u}c C. and Van Horn, David},
 title = {Abstracting Definitional Interpreters (Functional Pearl)},
 journal = {Proc. ACM Program. Lang.},
 issue_date = {September 2017},
 volume = {1},
 number = {ICFP},
 month = aug,
 year = {2017},
 issn = {2475-1421},
 pages = {12:1--12:25},
 articleno = {12},
 numpages = {25},
 x-url = {http://doi.acm.org/10.1145/3110256},
 x-doi = {10.1145/3110256},
 acmid = {3110256},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {abstract interpreters, interpreters},
}

@inproceedings{siek2006gradual,
  title={Gradual typing for functional languages},
  author={Siek, Jeremy G. and Taha, Walid},
  booktitle={Scheme and Functional Programming Workshop},
  volume={6},
  pages={81--92},
  year={2006}
}

@inproceedings{kuhlenschmidt2019toward,
  title={Toward efficient gradual typing for structural types via coercions},
  author={Kuhlenschmidt, Andre and Almahallawi, Deyaaeldeen and Siek, Jeremy G},
  booktitle={Proceedings of the 40th ACM SIGPLAN Conference on Programming Language Design and Implementation},
  pages={517--532},
  year={2019},
  organization={ACM}
}

@article{greenman2018spectrum,
author = {Greenman, Ben and Felleisen, Matthias},
title = {A Spectrum of Type Soundness and Performance},
year = {2018},
issue_date = {September 2018},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {2},
number = {ICFP},
url = {https://doi.org/10.1145/3236766},
doi = {10.1145/3236766},
journal = {Proc. ACM Program. Lang.},
month = jul,
articleno = {71},
numpages = {32},
keywords = {performance evaluation, D-deliverable, type soundness, migratory typing}
}

@inproceedings{vitousek2014design,
  title={Design and evaluation of gradual typing for Python},
  author={Vitousek, Michael M. and Kent, Andrew M. and Siek, Jeremy G. and Baker, Jim},
  booktitle={ACM SIGPLAN Notices},
  volume={50},
  number={2},
  pages={45--56},
  year={2014},
  organization={ACM}
}

@inproceedings{rastogi2015safe,
  title={Safe \& efficient gradual typing for TypeScript},
  author={Rastogi, Aseem and Swamy, Nikhil and Fournet, C{\'e}dric and Bierman, Gavin and Vekris, Panagiotis},
  booktitle={Proceedings of the 42nd Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages},
  volume={50},
  number={1},
  pages={167--180},
  year={2015},
  organization={ACM}
}

@InProceedings{siek2015monotonic,
author="Siek, Jeremy G.
and Vitousek, Michael M.
and Cimini, Matteo
and Tobin-Hochstadt, Sam
and Garcia, Ronald",
editor="Vitek, Jan",
title="Monotonic References for Efficient Gradual Typing",
booktitle="Programming Languages and Systems",
year="2015",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="432--456",
abstract="Gradual typing enables both static and dynamic typing in the same program and makes it convenient to migrate code regions between the two typing disciplines. One goal of gradual typing is to provide all the benefits of static typing, such as efficiency, in statically-typed regions. However, this goal is elusive: the standard approach to mutable references imposes run-time overhead in statically-typed regions and alternative approaches are too conservative, either statically or at run-time. In this paper we present a new semantics called monotonic references which imposes none of the run-time overhead of dynamic typing in statically typed regions. With this design, casting a reference may cause a heap cell to become more statically typed (but not less). Retaining type safety is challenging with strong updates to the heap. Nevertheless, we have a mechanized proof of type safety. Further, we present blame tracking for monotonic references and prove a blame theorem.",
isbn="978-3-662-46669-8"
}

@inproceedings{takikawa2015towards,
  title={Towards practical gradual typing},
  author={Takikawa, Asumu and Feltey, Daniel and Dean, Earl and Flatt, Matthew and Findler, Robert Bruce and Tobin-Hochstadt, Sam and Felleisen, Matthias},
  booktitle={29th European Conference on Object-Oriented Programming (ECOOP 2015)},
  year={2015},
  organization={Schloss Dagstuhl-Leibniz-Zentrum fuer Informatik}
}

@article{bauman2017mostly,
 author = {Bauman, Spenser and Bolz-Tereick, Carl Friedrich and Siek, Jeremy and Tobin-Hochstadt, Sam},
 title = {Sound Gradual Typing: Only Mostly Dead},
 journal = {Proc. ACM Program. Lang.},
 issue_date = {October 2017},
 volume = {1},
 number = {OOPSLA},
 month = oct,
 year = {2017},
 issn = {2475-1421},
 pages = {54:1--54:24},
 articleno = {54},
 numpages = {24},
 url = {http://doi.acm.org/10.1145/3133878},
 doi = {10.1145/3133878},
 acmid = {3133878},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {Gradual Typing, Just-in-Time compilation, Performance Evaluation},
}

@article{feltey2018collapsible,
  title={Collapsible contracts: fixing a pathology of gradual typing},
  author={Feltey, Daniel and Greenman, Ben and Scholliers, Christophe and Findler, Robert Bruce and St-Amour, Vincent},
  journal={Proceedings of the ACM on Programming Languages},
  volume={2},
  number={OOPSLA},
  pages={133},
  year={2018},
  publisher={ACM}
}

@inproceedings{vitousek2017big,
 author = {Vitousek, Michael M. and Swords, Cameron and Siek, Jeremy G.},
 title = {Big Types in Little Runtime: Open-world Soundness and Collaborative Blame for Gradual Type Systems},
 booktitle = {Proceedings of the 44th ACM SIGPLAN Symposium on Principles of Programming Languages},
 series = {POPL 2017},
 year = {2017},
 isbn = {978-1-4503-4660-3},
 location = {Paris, France},
 pages = {762--774},
 numpages = {13},
 url = {http://doi.acm.org/10.1145/3009837.3009849},
 doi = {10.1145/3009837.3009849},
 acmid = {3009849},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {gradual typing, interoperability, semantics, type systems},
}

@inproceedings{vitousek2019optimizing,
 author = {Vitousek, Michael M. and Siek, Jeremy G. and Chaudhuri, Avik},
 title = {Optimizing and Evaluating Transient Gradual Typing},
 booktitle = {Proceedings of the 15th ACM SIGPLAN International Symposium on Dynamic Languages},
 series = {DLS 2019},
 year = {2019},
 isbn = {978-1-4503-6996-1},
 location = {Athens, Greece},
 pages = {28--41},
 numpages = {14},
 url = {http://doi.acm.org/10.1145/3359619.3359742},
 doi = {10.1145/3359619.3359742},
 acmid = {3359742},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {Gradual typing, Python, transient, type checks},
}

@inproceedings{swamy2014gradual,
 author = {Swamy, Nikhil and Fournet, Cedric and Rastogi, Aseem and Bhargavan, Karthikeyan and Chen, Juan and Strub, Pierre-Yves and Bierman, Gavin},
 title = {Gradual Typing Embedded Securely in JavaScript},
 booktitle = {Proceedings of the 41st ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages},
 series = {POPL '14},
 year = {2014},
 isbn = {978-1-4503-2544-8},
 location = {San Diego, California, USA},
 pages = {425--437},
 numpages = {13},
 url = {http://doi.acm.org/10.1145/2535838.2535889},
 doi = {10.1145/2535838.2535889},
 acmid = {2535889},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {compilers, language-based security, type systems},
}

@article{muehlboeck2017sound,
 author = {Muehlboeck, Fabian and Tate, Ross},
 title = {Sound Gradual Typing is Nominally Alive and Well},
 journal = {Proc. ACM Program. Lang.},
 issue_date = {October 2017},
 volume = {1},
 number = {OOPSLA},
 month = oct,
 year = {2017},
 issn = {2475-1421},
 pages = {56:1--56:30},
 articleno = {56},
 numpages = {30},
 url = {http://doi.acm.org/10.1145/3133880},
 doi = {10.1145/3133880},
 acmid = {3133880},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {Gradual Typing, Immediate Accountability, Nominal, Transparency},
}

@InProceedings{bierman2010adding,
author="Bierman, Gavin
and Meijer, Erik
and Torgersen, Mads",
editor="D'Hondt, Theo",
title="Adding Dynamic Types to C\#",
booktitle="ECOOP 2010 -- Object-Oriented Programming",
year="2010",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="76--100",
abstract="Developers using statically typed languages such as C{\$}^{\backslash}sharp{\$}and Java are increasingly having to interoperate with APIs and object models defined in dynamic languages. This impedance mismatch results in code that is difficult to understand, awkward to analyze, and expensive to maintain. In this paper we describe new features in C{\$}^{\backslash}sharp{\$}4.0 that support the safe combination of dynamically and statically typed code by deferring type checking of program fragments with static type dynamic until runtime. When executed, these dynamic code fragments are type-checked and resolved using the same rules as statically typed code. We formalize these features in a core fragment of C{\$}^{\backslash}sharp{\$}and prove important safety properties. In particular, we show that subtyping remains transitive.",
isbn="978-3-642-14107-2"
}

@article{nguyen2017higher,
  author    = {Ph\'{u}c C. Nguyễn and
               Sam Tobin{-}Hochstadt and
               David Van Horn},
  title     = {Higher order symbolic execution for contract verification and refutation},
  journal   = {J. Funct. Program.},
  volume    = {27},
  pages     = {e3},
  year      = {2017},
  url       = {https://doi.org/10.1017/S0956796816000216},
  doi       = {10.1017/S0956796816000216},
  timestamp = {Sat, 27 May 2017 14:24:34 +0200},
  biburl    = {https://dblp.org/rec/bib/journals/jfp/NguyenTH17},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@inproceedings{Nguyen2015Relatively,
    author = {Nguyễn, Ph\'{u}c C. and Van Horn, David},
    booktitle = {Proceedings of the 36th ACM SIGPLAN Conference on Programming Language Design and Implementation},
    citeulike-article-id = {13671014},
    citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=2737971},
    citeulike-linkout-1 = {http://dx.doi.org/10.1145/2737924.2737971},
    date-added = {2015-07-13 22:33:58},
    location = {Portland, OR, USA},
    priority = {2},
    publisher = {ACM},
    title = {Relatively Complete Counterexamples for Higher-order Programs},
    x-abstract = {In this paper, we study the problem of generating inputs to a higher-order program causing it to error. We first approach the problem in the setting of {PCF}, a typed, core functional language and contribute the first relatively complete method for constructing counterexamples for {PCF} programs. The method is relatively complete with respect to a first-order solver over the base types of {PCF}. In practice, this means an {SMT} solver can be used for the effective, automated generation of higher-order counterexamples for a large class of programs. We achieve this result by employing a novel form of symbolic execution for higher-order programs. The remarkable aspect of this symbolic execution is that even though symbolic higher-order inputs and values are considered, the path condition remains a first-order formula. Our handling of symbolic function application enables the reconstruction of higher-order counterexamples from this first-order formula. After establishing our main theoretical results, we sketch how to apply the approach to untyped, higher-order, stateful languages with first-class contracts and show how counterexample generation can be used to detect contract violations in this setting. To validate our approach, we implement a tool generating counterexamples for erroneous modules written in Racket.},
    x-address = {New York, NY, USA},
    x-doi = {10.1145/2737924.2737971},
    x-isbn = {978-1-4503-3468-6},
    x-series = {PLDI 2015},
    x-url = {http://dx.doi.org/10.1145/2737924.2737971},
    xpages = {446--456},
    year = {2015}
}

@inproceedings{Nguyen2014Soft,
    author = {Nguyễn, Ph\'{u}c C. and Tobin-Hochstadt, Sam and Van{ }Horn, David},
    booktitle = {Proceedings of the 19th ACM SIGPLAN International Conference on Functional Programming},
    citeulike-article-id = {13403599},
    citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=2628156},
    citeulike-linkout-1 = {http://dx.doi.org/10.1145/2628136.2628156},
    date-added = {2014-10-22 00:16:50},
    location = {Gothenburg, Sweden},
    priority = {2},
    publisher = {ACM},
    title = {Soft Contract Verification},
    x-abstract = {Behavioral software contracts are a widely used mechanism for governing the flow of values between components. However, run-time monitoring and enforcement of contracts imposes significant overhead and delays discovery of faulty components to run-time. To overcome these issues, we present soft contract verification, which aims to statically prove either complete or partial contract correctness of components, written in an untyped, higher-order language with first-class contracts. Our approach uses higher-order symbolic execution, leveraging contracts as a source of symbolic values including unknown behavioral values, and employs an updatable heap of contract invariants to reason about flow-sensitive facts. We prove the symbolic execution soundly approximates the dynamic semantics and that verified programs can't be blamed. The approach is able to analyze first-class contracts, recursive data structures, unknown functions, and control-flow-sensitive refinements of values, which are all idiomatic in dynamic languages. It makes effective use of an off-the-shelf solver to decide problems without heavy encodings. The approach is competitive with a wide range of existing tools - including type systems, flow analyzers, and model checkers - on their own benchmarks.},
    x-address = {New York, NY, USA},
    x-doi = {10.1145/2628136.2628156},
    x-isbn = {978-1-4503-2873-9},
    x-series = {ICFP '14},
    x-url = {http://dx.doi.org/10.1145/2628136.2628156},
    xpages = {139--152},
    year = {2014}
}



@article{flow,
  author    = {Avik Chaudhuri and
               Panagiotis Vekris and
               Sam Goldman and
               Marshall Roch and
               Gabriel Levi},
  title     = {Fast and precise type checking for JavaScript},
  journal   = {{PACMPL}},
  volume    = {1},
  number    = {{OOPSLA}},
  pages     = {48:1--48:30},
  year      = {2017},
  url       = {https://doi.org/10.1145/3133872},
  doi       = {10.1145/3133872},
  timestamp = {Tue, 06 Nov 2018 12:51:05 +0100},
  biburl    = {https://dblp.org/rec/bib/journals/pacmpl/ChaudhuriVGRL17},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}


@misc{mypy,
    title = {MyPy: Optional Static Typing for Python},
    url = {http://mypy-lang.org/},
    author = {Lehtosalo, Jukka},
    year = {2017}
}




@misc{sorbet,
    title = {Sorbet},
    author = {{Stripe Inc.}},
    url = {https://sorbet.org/},
    year = {2019},
}


@misc{ts,
  title={TypeScript {L}anguage {S}pecification},
  author={{Microsoft Corp.}},
  howpublished = {http://www.typescriptlang.org},
  year={2014},
 }


@misc{hack,
  title={Hack},
  author={{Facebook Inc.}},
  howpublished = {http://hacklang.org},
  year={2014},
}

@misc{dart,
    title = {Dart},
    author = {{Google Inc.}},
    url = {https://dart.dev/},
    year = {2018}
}



@article{DBLP:journals/pacmpl/RichardsAT17,
  author    = {Gregor Richards and
               Ellen Arteca and
               Alexi Turcotte},
  title     = {The {VM} already knew that: leveraging compile-time knowledge to optimize
               gradual typing},
  journal   = {{PACMPL}},
  volume    = {1},
  number    = {{OOPSLA}},
  pages     = {55:1--55:27},
  year      = {2017},
  url       = {https://doi.org/10.1145/3133879},
  doi       = {10.1145/3133879},
  timestamp = {Tue, 06 Nov 2018 12:51:05 +0100},
  biburl    = {https://dblp.org/rec/bib/journals/pacmpl/RichardsAT17},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@inproceedings{wrigstad2017integrating,
 author = {Wrigstad, Tobias and Nardelli, Francesco Zappa and Lebresne, Sylvain and \"{O}stlund, Johan and Vitek, Jan},
 title = {Integrating Typed and Untyped Code in a Scripting Language},
 booktitle = {Proceedings of the 37th Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages},
 series = {POPL '10},
 year = {2010},
 isbn = {978-1-60558-479-9},
 location = {Madrid, Spain},
 pages = {377--388},
 numpages = {12},
 url = {http://doi.acm.org/10.1145/1706299.1706343},
 doi = {10.1145/1706299.1706343},
 acmid = {1706343},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {compilers, object-orientation, semantics, types},
}


@inproceedings{DBLP:conf/ecoop/RichardsNV15,
  author    = {Gregor Richards and
               Francesco Zappa Nardelli and
               Jan Vitek},
  title     = {Concrete Types for TypeScript},
  booktitle = {29th European Conference on Object-Oriented Programming, {ECOOP} 2015,
               July 5-10, 2015, Prague, Czech Republic},
  pages     = {76--100},
  year      = {2015},
  url       = {https://doi.org/10.4230/LIPIcs.ECOOP.2015.76},
  doi       = {10.4230/LIPIcs.ECOOP.2015.76},
  timestamp = {Thu, 02 May 2019 17:40:11 +0200},
  biburl    = {https://dblp.org/rec/bib/conf/ecoop/RichardsNV15},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}


@inproceedings{grace,
  author    = {Andrew P. Black and
               Kim B. Bruce and
               Michael Homer and
               James Noble},
  title     = {Grace: the absence of (inessential) difficulty},
  booktitle = {{ACM} Symposium on New Ideas in Programming and Reflections on Software,
               Onward! 2012, part of {SPLASH} '12, Tucson, AZ, USA, October 21-26,
               2012},
  pages     = {85--98},
  year      = {2012},
  url       = {https://doi.org/10.1145/2384592.2384601},
  doi       = {10.1145/2384592.2384601},
  timestamp = {Tue, 06 Nov 2018 16:57:15 +0100},
  biburl    = {https://dblp.org/rec/bib/conf/oopsla/BlackBHN12},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}
