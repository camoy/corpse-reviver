@InProceedings{thiemann-symexp,
  author =       "Peter Thiemann",
  booktitle =    "Proceedings of the ACM SIGPLAN Workshop on Partial
                 Evaluation and Semantics-Based Program Manipulation",
  citeulike-article-id = "10561131",
  citeulike-linkout-0 = "http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.99.8734",
  date-added =   "2012-04-13 04:24:04",
  priority =     "2",
  title =        "{Higher-Order} Redundancy Elimination",
  x-abstract =   "Functional programs often define functions by pattern
                 matching where patterns may inadvertedly overlap
                 through successive function calls. This leads to hidden
                 ine ciencies since the recursively called function
                 possibly repeats redundant tests while trying to match
                 the pattern. An analysis which is based on conservative
                 symbolic execution (similar to higher order constant
                 propagation) is proposed for a strict higher-order
                 language to drive an arity raiser which generates
                 specialized versions for functions with partially known
                 arguments. To ensure termination only the definitely
                 consumed part of the partially known arguments is
                 considered.",
  x-url =        "http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.99.8734",
  xpages =       "73--84",
  year =         "1994",
}

@InProceedings{Cadar2006EXE,
  author =       "Cristian Cadar and Vijay Ganesh and Peter M. Pawlowski
                 and David L. Dill and Dawson R. Engler",
  booktitle =    "Proceedings of the 13th ACM Conference on Computer and
                 Communications Security",
  citeulike-article-id = "1438741",
  citeulike-linkout-0 = "http://portal.acm.org/citation.cfm?id=1180445",
  citeulike-linkout-1 = "http://dx.doi.org/10.1145/1180405.1180445",
  date-added =   "2012-04-13 03:41:05",
  location =     "Alexandria, Virginia, USA",
  priority =     "2",
  publisher =    "ACM",
  title =        "{EXE}: Automatically Generating Inputs of Death",
  x-abstract =   "This paper presents {EXE}, an effective bug-finding
                 tool that automatically generates inputs that crash
                 real code. Instead of running code on manually or
                 randomly constructed input, {EXE} runs it on symbolic
                 input initially allowed to be {"}anything.{"} As
                 checked code runs, {EXE} tracks the constraints on each
                 symbolic (i.e., input-derived) memory location. If a
                 statement uses a symbolic value, {EXE} does not run it,
                 but instead adds it as an input-constraint; all other
                 statements run as usual. If code conditionally checks a
                 symbolic expression, {EXE} forks execution,
                 constraining the expression to be true on the true
                 branch and false on the other. Because {EXE} reasons
                 about all possible values on a path, it has much more
                 power than a traditional runtime tool: (1) it can force
                 execution down any feasible program path and (2) at
                 dangerous operations (e.g., a pointer dereference), it
                 detects if the current path constraints allow any value
                 that causes a {bug.When} a path terminates or hits a
                 bug, {EXE} automatically generates a test case by
                 solving the current path constraints to find concrete
                 values using its own co-designed constraint solver,
                 {STP}. Because {EXE}'s constraints have no
                 approximations, feeding this concrete input to an
                 uninstrumented version of the checked code will cause
                 it to follow the same path and hit the same bug
                 (assuming deterministic {code).EXE} works well on real
                 code, finding bugs along with inputs that trigger them
                 in: the {BSD} and Linux packet filter implementations,
                 the udhcpd {DHCP} server, the pcre regular expression
                 library, and three Linux file systems.",
  x-address =    "New York, NY, USA",
  x-doi =        "10.1145/1180405.1180445",
  x-isbn =       "1-59593-518-5",
  x-series =     "CCS '06",
  x-url =        "http://dx.doi.org/10.1145/1180405.1180445",
  xpages =       "322--335",
  year =         "2006",
}

@InProceedings{klee08,
  author =       "Cristian Cadar and Daniel Dunbar and Dawson Engler",
  booktitle =    "Proceedings of the 8th USENIX Conference on Operating
                 Systems Design and Implementation",
  citeulike-article-id = "9722007",
  citeulike-linkout-0 = "http://portal.acm.org/citation.cfm?id=1855756",
  date-added =   "2012-04-13 03:40:09",
  location =     "San Diego, California",
  priority =     "2",
  publisher =    "USENIX Association",
  title =        "{KLEE}: Unassisted and Automatic Generation of
                 High-coverage Tests for Complex Systems Programs",
  x-abstract =   "We present a new symbolic execution tool, {KLEE},
                 capable of automatically generating tests that achieve
                 high coverage on a diverse set of complex and
                 environmentally-intensive programs. We used {KLEE} to
                 thoroughly check all 89 stand-alone programs in the
                 {GNU} {COREUTILS} utility suite, which form the core
                 user-level environment installed on millions of Unix
                 systems, and arguably are the single most heavily
                 tested set of open-source programs in existence.
                 {KLEE}-generated tests achieve high line coverage -- on
                 average over 90\% per tool (median: over 94\%) -- and
                 significantly beat the coverage of the developers' own
                 hand-written test suite. When we did the same for 75
                 equivalent tools in the {BUSYBOX} embedded system
                 suite, results were even better, including 100\%
                 coverage on 31 of them. We also used {KLEE} as a bug
                 finding tool, applying it to 452 applications (over
                 {430K} total lines of code), where it found 56 serious
                 bugs, including three in {COREUTILS} that had been
                 missed for over 15 years. Finally, we used {KLEE} to
                 crosscheck purportedly identical {BUSYBOX} and
                 {COREUTILS} utilities, finding functional correctness
                 errors and a myriad of inconsistencies.",
  x-address =    "Berkeley, CA, USA",
  x-series =     "OSDI'08",
  x-url =        "http://portal.acm.org/citation.cfm?id=1855756",
  xpages =       "209--224",
  year =         "2008",
}

@InProceedings{Xu2012:Hybrid,
  author =       "Dana N. Xu",
  booktitle =    "Proceedings of the ACM SIGPLAN 2012 workshop on
                 Partial evaluation and program manipulation",
  citeulike-article-id = "10365708",
  citeulike-linkout-0 = "http://portal.acm.org/citation.cfm?id=2103767",
  citeulike-linkout-1 = "http://dx.doi.org/10.1145/2103746.2103767",
  date-added =   "2012-02-19 00:19:38",
  location =     "Philadelphia, Pennsylvania, USA",
  priority =     "2",
  publisher =    "ACM",
  title =        "Hybrid contract checking via symbolic simplification",
  x-abstract =   "Program errors are hard to detect or prove absent.
                 Allowing programmers to write formal and precise
                 specifications, especially in the form of contracts, is
                 a popular approach to program verification and error
                 discovery. We formalize and implement a hybrid (static
                 and dynamic) contract checker for a subset of {OCaml}.
                 The key technique is symbolic simplification, which
                 makes integrating static and dynamic contract checking
                 easy and effective. Our technique statically checks
                 contract satisfaction or blames the function violating
                 the contract. When a contract satisfaction is
                 undecidable, it leaves residual code for dynamic
                 contract checking.",
  x-address =    "New York, NY, USA",
  x-doi =        "10.1145/2103746.2103767",
  x-isbn =       "978-1-4503-1118-2",
  x-series =     "PEPM '12",
  x-url =        "http://dx.doi.org/10.1145/2103746.2103767",
  xpages =       "107--116",
  year =         "2012",
}

@InProceedings{slam-pldi01,
  author =       "Thomas Ball and Rupak Majumdar and Todd Millstein and
                 Sriram K. Rajamani",
  booktitle =    "Proceedings of the ACM SIGPLAN 2001 conference on
                 Programming language design and implementation",
  citeulike-article-id = "1376607",
  citeulike-linkout-0 = "http://portal.acm.org/citation.cfm?id=378795.378846",
  citeulike-linkout-1 = "http://dx.doi.org/10.1145/378795.378846",
  date-added =   "2012-02-18 23:54:11",
  location =     "Snowbird, Utah, USA",
  priority =     "2",
  publisher =    "ACM",
  title =        "Automatic predicate abstraction of {C} programs",
  x-abstract =   "Model checking has been widely successful in
                 validating and debugging designs in the hardware and
                 protocol domains. However, state-space explosion limits
                 the applicability of model checking tools, so model
                 checkers typically operate on abstractions of systems.
                 Recently, there has been significant interest in
                 applying model checking to software. For infinite-state
                 systems like software, abstraction is even more
                 critical. Techniques for abstracting software are a
                 prerequisite to making software model checking a
                 reality. We present the first algorithm to
                 automatically construct a predicate abstraction of
                 programs written in an industrial programming language
                 such as C, and its implementation in a tool — {C2BP}.
                 The {C2BP} tool is part of the {SLAM} toolkit, which
                 uses a combination of predicate abstraction, model
                 checking, symbolic reasoning, and iterative refinement
                 to statically check temporal safety properties of
                 programs. Predicate abstraction of software has many
                 applications, including detecting program errors,
                 synthesizing program invariants, and improving the
                 precision of program analyses through predicate
                 sensitivity. We discuss our experience applying the
                 {C2BP} predicate abstraction tool to a variety of
                 problems, ranging from checking that list-manipulating
                 code preserves heap invariants to finding errors in
                 Windows {NT} device drivers.",
  x-address =    "New York, NY, USA",
  x-doi =        "10.1145/378795.378846",
  x-isbn =       "1-58113-414-2",
  x-issn =       "0362-1340",
  x-series =     "PLDI '01",
  x-url =        "http://dx.doi.org/10.1145/378795.378846",
  xpages =       "203--213",
  year =         "2001",
}

@Article{slam-cacm,
  author =       "Thomas Ball and Vladimir Levin and Sriram K.
                 Rajamani",
  citeulike-article-id = "9782473",
  citeulike-linkout-0 = "http://portal.acm.org/citation.cfm?id=1965743",
  citeulike-linkout-1 = "http://dx.doi.org/10.1145/1965724.1965743",
  date-added =   "2012-02-18 23:52:12",
  journal =      "Commun. ACM",
  number =       "7",
  priority =     "2",
  publisher =    "ACM",
  title =        "A decade of software model checking with {SLAM}",
  volume =       "54",
  x-abstract =   "{SLAM} is a program-analysis engine used to check if
                 clients of an {API} follow the {API}'s stateful usage
                 rules.",
  x-address =    "New York, NY, USA",
  x-doi =        "10.1145/1965724.1965743",
  x-issn =       "0001-0782",
  x-month =      jul,
  x-url =        "http://dx.doi.org/10.1145/1965724.1965743",
  xpages =       "68--76",
  year =         "2011",
}

@InCollection{acl2s2011,
  author =       "Harsh Chamarthi and Peter Dillinger and Panagiotis
                 Manolios and Daron Vroon and Harsh R. Chamarthi and
                 Peter Dillinger and Panagiotis Manolios and Daron
                 Vroon",
  booktitle =    "Tools and Algorithms for the Construction and Analysis
                 of Systems",
  chapter =      "27",
  citeulike-article-id = "10141418",
  citeulike-linkout-0 = "http://dx.doi.org/10.1007/978-3-642-19835-9\_27",
  citeulike-linkout-1 = "http://www.springerlink.com/content/24t31667077j732v",
  date-added =   "2011-12-18 22:40:55",
  priority =     "2",
  publisher =    "Springer Berlin / Heidelberg",
  title =        "The {ACL2} Sedan Theorem Proving System",
  volume =       "6605",
  x-abstract =   "The {ACL2} Sedan theorem prover ({ACL2s}) is an
                 Eclipse plug-in that provides a modern integrated
                 development environment, supports several modes of
                 interaction, provides a powerful termination analysis
                 engine, and includes fully automatic bug-finding
                 methods based on a synergistic combination of theorem
                 proving and random testing. {ACL2s} is publicly
                 available and open source. It has also been used in
                 several sections of a required freshman course at
                 Northeastern University to teach over 200 undergraduate
                 students how to reason about programs.",
  x-address =    "Berlin, Heidelberg",
  x-doi =        "10.1007/978-3-642-19835-9\_27",
  x-editor =     "Abdulla, Parosh and Leino, K. and Abdulla, Parosh A.
                 and Leino",
  x-isbn =       "978-3-642-19834-2",
  x-series =     "Lecture Notes in Computer Science",
  x-url =        "http://dx.doi.org/10.1007/978-3-642-19835-9\_27",
  xpages =       "291--295",
  year =         "2011",
}

@Article{VanHorn2011JS:arxiv,
  archiveprefix = "arXiv",
  author =       "David Van Horn and Matthew Might",
  citeulike-article-id = "10141171",
  citeulike-linkout-0 = "http://arxiv.org/abs/1109.4467",
  citeulike-linkout-1 = "http://arxiv.org/pdf/1109.4467",
  date-added =   "2011-12-18 19:43:55",
  day =          "21",
  eprint =       "1109.4467",
  priority =     "2",
  title =        "An Analytic Framework for {JavaScript}",
  x-abstract =   "As the programming language of the web, {JavaScript}
                 deserves a principled yet robust framework for static
                 analysis. To achieve both aims simultaneously, we start
                 from an established reduction semantics for
                 {JavaScript} and systematically derive its intensional
                 abstract interpretation. Our first step is to transform
                 the semantics into an equivalent low-level abstract
                 machine: the {JavaScript} Abstract Machine ({JAM}). We
                 then derive the systematic abstraction of the entire
                 low-level machine. That process yields a finite- state,
                 machine-based abstract interpretation for {JavaScript}.
                 The calculation of this analysis is itself a milestone,
                 constituting the first {"}field validation{"} of the
                 theory behind systematically abstracting abstract
                 machines. This finite-state framework allows us to
                 import important techniques from the over 30 years of
                 work on higher-order program analysis. We can
                 instantiate the abstraction to obtain traditional
                 analyses, such as {k-CFA} and {CPA}, extended to
                 {JavaScript}. Not content with the precision of this
                 analysis over complex control effects, we extend our
                 systematic approach with a new mode: unbounded
                 abstraction of continuations. This new mode yields an
                 infinite-state yet decidable pushdown machine whose
                 stack precisely models the structure of the concrete
                 program stack. The precise model of stack structure in
                 turn confers precise control-flow analysis over control
                 effects, such as exceptions, finally blocks, and of
                 course, calls and returns. Both the finite-state and
                 pushdown frameworks for abstract interpretation are
                 sound and computable.",
  x-month =      sep,
  x-url =        "http://arxiv.org/abs/1109.4467",
  year =         "2011",
}

@Article{cute-concolic,
  author =       "Koushik Sen and Darko Marinov and Gul Agha",
  citeulike-article-id = "2140042",
  citeulike-linkout-0 = "http://portal.acm.org/citation.cfm?id=1095430.1081750",
  citeulike-linkout-1 = "http://dx.doi.org/10.1145/1095430.1081750",
  date-added =   "2011-12-07 23:58:06",
  journal =      "SIGSOFT Softw. Eng. Notes",
  number =       "5",
  priority =     "2",
  publisher =    "ACM",
  title =        "{CUTE}: a concolic unit testing engine for {C}",
  volume =       "30",
  x-abstract =   "In unit testing, a program is decomposed into units
                 which are collections of functions. A part of unit can
                 be tested by generating inputs for a single entry
                 function. The entry function may contain pointer
                 arguments, in which case the inputs to the unit are
                 memory graphs. The paper addresses the problem of
                 automating unit testing with memory graphs as inputs.
                 The approach used builds on previous work combining
                 symbolic and concrete execution, and more specifically,
                 using such a combination to generate test inputs to
                 explore all feasible execution paths. The current work
                 develops a method to represent and track constraints
                 that capture the behavior of a symbolic execution of a
                 unit with memory graphs as inputs. Moreover, an
                 efficient constraint solver is proposed to facilitate
                 incremental generation of such test inputs. Finally,
                 {CUTE}, a tool implementing the method is described
                 together with the results of applying {CUTE} to
                 real-world examples of C code.",
  x-address =    "New York, NY, USA",
  x-doi =        "10.1145/1095430.1081750",
  x-isbn =       "1595930140",
  x-issn =       "0163-5948",
  x-month =      sep,
  x-url =        "http://dx.doi.org/10.1145/1095430.1081750",
  xpages =       "263--272",
  year =         "2005",
}

@InProceedings{hybrid-concolic,
  author =       "R. Majumdar and K. Sen",
  booktitle =    "Software Engineering, 2007. ICSE 2007. 29th
                 International Conference on",
  citeulike-article-id = "3515084",
  citeulike-linkout-0 = "http://portal.acm.org/citation.cfm?id=1248874",
  citeulike-linkout-1 = "http://dx.doi.org/10.1109/icse.2007.41",
  citeulike-linkout-2 = "http://ieeexplore.ieee.org/xpls/abs\_all.jsp?arnumber=4222603",
  date-added =   "2011-12-07 23:57:52",
  institution =  "CS Dept., UC Los Angeles, Los Angeles, CA",
  journal =      "Software Engineering, 2007. ICSE 2007. 29th
                 International Conference on",
  location =     "Minneapolis, MN, USA",
  priority =     "2",
  publisher =    "IEEE",
  title =        "Hybrid Concolic Testing",
  x-abstract =   "We present hybrid concolic testing, an algorithm that
                 interleaves random testing with concolic execution to
                 obtain both a deep and a wide exploration of program
                 state space. Our algorithm generates test inputs
                 automatically by interleaving random testing until
                 saturation with bounded exhaustive symbolic exploration
                 of program points. It thus combines the ability of
                 random search to reach deep program states quickly
                 together with the ability of concolic testing to
                 explore states in a neighborhood exhaustively. We have
                 implemented our algorithm on top of {CUTE} and applied
                 it to obtain better branch coverage for an editor
                 implementation ({VIM} 5.7, 150 K lines of code) as well
                 as a data structure implementation in C. Our
                 experiments suggest that hybrid concolic testing can
                 handle large programs and provide, for the same testing
                 budget, almost 4times the branch coverage than random
                 testing and almost 2times that of concolic testing.",
  x-address =    "Washington, DC, USA",
  x-doi =        "10.1109/icse.2007.41",
  x-isbn =       "0-7695-2828-7",
  x-issn =       "0270-5257",
  x-month =      may,
  x-series =     "ICSE '07",
  x-url =        "http://dx.doi.org/10.1109/icse.2007.41",
  xpages =       "416--426",
  year =         "2007",
}

@InProceedings{dart-concolic,
  author =       "Patrice Godefroid and Nils Klarlund and Koushik Sen",
  booktitle =    "Proceedings of the 2005 ACM SIGPLAN conference on
                 Programming language design and implementation",
  citeulike-article-id = "320083",
  citeulike-linkout-0 = "http://portal.acm.org/citation.cfm?id=1065010.1065036",
  citeulike-linkout-1 = "http://dx.doi.org/10.1145/1065010.1065036",
  date-added =   "2011-12-07 23:57:34",
  location =     "Chicago, IL, USA",
  number =       "6",
  priority =     "2",
  publisher =    "ACM",
  title =        "{DART}: directed automated random testing",
  volume =       "40",
  x-abstract =   "We present a new tool, named {DART}, for automatically
                 testing software that combines three main techniques:
                 (1) automated extraction of the interface of a program
                 with its external environment using static source-code
                 parsing; (2) automatic generation of a test driver for
                 this interface that performs random testing to simulate
                 the most general environment the program can operate
                 in; and (3) dynamic analysis of how the program behaves
                 under random testing and automatic generation of new
                 test inputs to direct systematically the execution
                 along alternative program paths. Together, these three
                 techniques constitute Directed Automated Random
                 Testing, or {DART} for short. The main strength of
                 {DART} is thus that testing can be performed completely
                 automatically on any program that compiles -- there is
                 no need to write any test driver or harness code.
                 During testing, {DART} detects standard errors such as
                 program crashes, assertion violations, and
                 non-termination. Preliminary experiments to unit test
                 several examples of C programs are very encouraging.",
  x-address =    "New York, NY, USA",
  x-doi =        "10.1145/1065010.1065036",
  x-isbn =       "1-59593-056-6",
  x-month =      jun,
  x-url =        "http://dx.doi.org/10.1145/1065010.1065036",
  xpages =       "213--223",
  year =         "2005",
}

@InProceedings{concolic-testing,
  author =       "Koushik Sen",
  booktitle =    "Proceedings of the twenty-second IEEE/ACM
                 international conference on Automated software
                 engineering",
  citeulike-article-id = "2672141",
  citeulike-linkout-0 = "http://portal.acm.org/citation.cfm?id=1321631.1321746",
  citeulike-linkout-1 = "http://dx.doi.org/10.1145/1321631.1321746",
  date-added =   "2011-12-07 23:55:40",
  location =     "Atlanta, Georgia, USA",
  priority =     "2",
  publisher =    "ACM",
  title =        "Concolic testing",
  x-abstract =   "Concolic testing automates test input generation by
                 combining the concrete and symbolic (concolic)
                 execution of the code under test. Traditional test
                 input generation techniques use either (1) concrete
                 execution or (2) symbolic execution that builds
                 constraints and is followed by a generation of concrete
                 test inputs from these constraints. In contrast,
                 concolic testing tightly couples both concrete and
                 symbolic executions: they run simultaneously, and each
                 gets feedback from the other. We have implemented
                 concolic testing in tools for testing both C and Java
                 programs. We have used the tools to find bugs in
                 several real-world software systems including {SGLIB},
                 a popular C data structure library used in a commercial
                 tool, a third-party implementation of the
                 {Needham-Schroeder} protocol and the {TMN} protocol,
                 the scheduler of Honeywell's {DEOS} real-time operating
                 system, and the Sun Microsystems' {JDK} 1.4 collection
                 framework. In this tutorial, we will describe concolic
                 testing and some of its recent extensions",
  x-address =    "New York, NY, USA",
  x-doi =        "10.1145/1321631.1321746",
  x-isbn =       "978-1-59593-882-4",
  x-series =     "ASE '07",
  x-url =        "http://dx.doi.org/10.1145/1321631.1321746",
  xpages =       "571--572",
  year =         "2007",
}

@InProceedings{jack-security,
  author =       "Gilles Barthe and Lilian Burdy and Julien Charles and
                 Benjamin Gr\'{e}goire and Marieke Huisman and Jean L.
                 Lanet and Mariela Pavlova and Antoine Requet",
  booktitle =    "Proceedings of the 5th international conference on
                 Formal methods for components and objects",
  citeulike-article-id = "10100399",
  citeulike-linkout-0 = "http://portal.acm.org/citation.cfm?id=1777717",
  date-added =   "2011-12-06 22:54:30",
  location =     "Amsterdam, The Netherlands",
  priority =     "2",
  publisher =    "Springer-Verlag",
  title =        "{JACK}: a tool for validation of security and
                 behaviour of Java applications",
  x-abstract =   "We describe the main features of {JACK} (Java Applet
                 Correctness Kit), a tool for the validation of Java
                 applications, annotated with {JML} specifications.
                 {JACK} has been especially designed to improve the
                 quality of trusted personal device applications. {JACK}
                 is fully integrated with the {IDE} Eclipse, and
                 provides an easily accessible user interface. In
                 particular, it allows to inspect the generated proof
                 obligations in a Java syntax, and to trace them back to
                 the source code that gave rise to them. Further, {JACK}
                 provides support for annotation generation, and for
                 interactive verification. The whole platform works both
                 for source code and for bytecode, which makes it
                 particularly suitable for a proof carrying code
                 scenario.",
  x-address =    "Berlin, Heidelberg",
  x-isbn =       "3-540-74791-5, 978-3-540-74791-8",
  x-series =     "FMCO'06",
  x-url =        "http://portal.acm.org/citation.cfm?id=1777717",
  xpages =       "152--174",
  year =         "2007",
}

@InCollection{boogie,
  author =       "Mike Barnett and Bor-YuhEvan Chang and Robert DeLine
                 and Bart Jacobs and Leino",
  booktitle =    "Formal Methods for Components and Objects",
  chapter =      "17",
  citeulike-article-id = "6397611",
  citeulike-linkout-0 = "http://dx.doi.org/10.1007/11804192\_17",
  citeulike-linkout-1 = "http://www.springerlink.com/content/d5618027k6v50257",
  citeulike-linkout-2 = "http://link.springer.com/chapter/10.1007/11804192\_17",
  date-added =   "2011-12-06 22:53:46",
  priority =     "2",
  publisher =    "Springer Berlin Heidelberg",
  title =        "Boogie: {A} Modular Reusable Verifier for
                 {Object-Oriented} Programs",
  volume =       "4111",
  x-abstract =   "A program verifier is a complex system that uses
                 compiler technology, program semantics, property
                 inference, verification-condition generation, automatic
                 decision procedures, and a user interface. This paper
                 describes the architecture of a state-of-the-art
                 program verifier for object-oriented programs.",
  x-doi =        "10.1007/11804192\_17",
  x-editor =     "de Boer, FrankS and Bonsangue, MarcelloM and Graf,
                 Susanne and de Roever, Willem-Paul",
  x-series =     "Lecture Notes in Computer Science",
  x-url =        "http://dx.doi.org/10.1007/11804192\_17",
  xpages =       "364--387",
  year =         "2006",
}

@InCollection{vericool,
  author =       "Jan Smans and Bart Jacobs and Frank Piessens and Jan
                 Smans and Bart Jacobs and Frank Piessens",
  booktitle =    "Formal Methods for Open Object-Based Distributed
                 Systems",
  chapter =      "14",
  citeulike-article-id = "10100387",
  citeulike-linkout-0 = "http://dx.doi.org/10.1007/978-3-540-68863-1\_14",
  citeulike-linkout-1 = "http://www.springerlink.com/content/012476kt801r6n07",
  date-added =   "2011-12-06 22:47:24",
  priority =     "2",
  publisher =    "Springer Berlin / Heidelberg",
  title =        "{VeriCool}: An Automatic Verifier for a Concurrent
                 {Object-Oriented} Language Formal Methods for Open
                 {Object-Based} Distributed Systems",
  volume =       "5051",
  x-abstract =   "Reasoning about object-oriented programs is hard, due
                 to aliasing, dynamic binding and the need for data
                 abstraction and framing. Reasoning about concurrent
                 object-oriented programs is even harder, since in
                 general interference by other threads has to be taken
                 into account at each program point. In this paper, we
                 propose an approach to the automatic verification of
                 concurrent Java-like programs. The cornerstone of the
                 approach is a programming model, a set of rules, which
                 limits thread inference to synchronization points such
                 that one can reason sequentially about most code. In
                 particular, programs conforming to the programming
                 model are guaranteed to be data race free. Compared to
                 previous incarnations of the programming model, our
                 approach is more flexible in describing the set of
                 memory locations protected by an object's lock. In
                 addition, we combine the model with an approach for
                 data abstraction and framing based on dynamic frames.
                 To the best of our knowledge, this is the first paper
                 combining dynamic frames and concurrency. We
                 implemented the approach in a tool, called {VeriCool},
                 and used it to verify several small concurrent
                 programs.",
  x-address =    "Berlin, Heidelberg",
  x-doi =        "10.1007/978-3-540-68863-1\_14",
  x-editor =     "Barthe, Gilles and de Boer, Frank and Barthe, Gilles
                 and Boer, Frank S.",
  x-isbn =       "978-3-540-68862-4",
  x-series =     "Lecture Notes in Computer Science",
  x-url =        "http://dx.doi.org/10.1007/978-3-540-68863-1\_14",
  xpages =       "220--239",
  year =         "2008",
}

@Article{esc-java,
  author =       "Cormac Flanagan and Rustan and Mark Lillibridge and
                 Greg Nelson and James B. Saxe and Raymie Stata",
  citeulike-article-id = "514997",
  citeulike-linkout-0 = "http://portal.acm.org/citation.cfm?id=543552.512558",
  citeulike-linkout-1 = "http://dx.doi.org/10.1145/543552.512558",
  date-added =   "2011-12-06 22:46:53",
  journal =      "SIGPLAN Not.",
  number =       "5",
  priority =     "2",
  publisher =    "ACM",
  title =        "Extended static checking for Java",
  volume =       "37",
  x-abstract =   "Software development and maintenance are costly
                 endeavors. The cost can be reduced if more software
                 defects are detected earlier in the development cycle.
                 This paper introduces the Extended Static Checker for
                 Java ({ESC}/Java), an experimental compile-time program
                 checker that finds common programming errors. The
                 checker is powered by verification-condition generation
                 and automatic theorem-proving techniques. It provides
                 programmers with a simple annotation language with
                 which programmer design decisions can be expressed
                 formally. {ESC}/Java examines the annotated software
                 and warns of inconsistencies between the design
                 decisions recorded in the annotations and the actual
                 code, and also warns of potential runtime errors in the
                 code. This paper gives an overview of the checker
                 architecture and annotation language and describes our
                 experience applying the checker to tens of thousands of
                 lines of Java programs.",
  x-address =    "New York, NY, USA",
  x-doi =        "10.1145/543552.512558",
  x-isbn =       "1581134630",
  x-issn =       "0362-1340",
  x-month =      may,
  x-url =        "http://dx.doi.org/10.1145/543552.512558",
  xpages =       "234--245",
  year =         "2002",
}

@InProceedings{why-verify,
  author =       "Jean C. Filli\^{a}tre and Claude March\'{e}",
  booktitle =    "Proceedings of the 19th international conference on
                 Computer aided verification",
  citeulike-article-id = "10100383",
  citeulike-linkout-0 = "http://portal.acm.org/citation.cfm?id=1770379",
  date-added =   "2011-12-06 22:46:47",
  location =     "Berlin, Germany",
  priority =     "2",
  publisher =    "Springer-Verlag",
  title =        "The {Why/Krakatoa}/Caduceus platform for deductive
                 program verification",
  x-abstract =   "We present the {Why/Krakatoa}/Caduceus set of tools
                 for deductive verification of Java and C source code.",
  x-address =    "Berlin, Heidelberg",
  x-isbn =       "978-3-540-73367-6",
  x-series =     "CAV'07",
  x-url =        "http://portal.acm.org/citation.cfm?id=1770379",
  xpages =       "173--177",
  year =         "2007",
}

@InProceedings{embedded-contract,
  author =       "Manuel F{\"{a}}hndrich and Michael Barnett and
                 Francesco Logozzo",
  booktitle =    "Proceedings of the 2010 ACM Symposium on Applied
                 Computing",
  citeulike-article-id = "7965240",
  citeulike-linkout-0 = "http://portal.acm.org/citation.cfm?id=1774531",
  citeulike-linkout-1 = "http://dx.doi.org/10.1145/1774088.1774531",
  date-added =   "2011-12-06 22:46:36",
  location =     "Sierre, Switzerland",
  priority =     "2",
  publisher =    "ACM",
  title =        "Embedded contract languages",
  x-abstract =   "Specifying application interfaces ({APIs}) with
                 information that goes beyond method argument and return
                 types is a long-standing quest of programming language
                 researchers and practitioners. The number of type
                 system extensions or specification languages is a
                 testament to that. Unfortunately, the number of such
                 systems is also roughly equal to the number of tools
                 that consume them. In other words, every tool comes
                 with its own specification language. In this paper we
                 argue that for modern object-oriented languages, using
                 an embedding of contracts as code is a better approach.
                 We exemplify our embedding of Code Contracts on the
                 Microsoft managed execution platform (.{NET}) using the
                 C\# programming language. The embedding works as well
                 in Visual Basic. We discuss the numerous advantages of
                 our approach and the technical challenges, as well as
                 the status of tools that consume the embedded
                 contracts.",
  x-address =    "New York, NY, USA",
  x-doi =        "10.1145/1774088.1774531",
  x-isbn =       "978-1-60558-639-7",
  x-series =     "SAC '10",
  x-url =        "http://dx.doi.org/10.1145/1774088.1774531",
  xpages =       "2103--2110",
  year =         "2010",
}

@InProceedings{jstar,
  author =       "Dino Distefano and Matthew",
  booktitle =    "Proceedings of the 23rd ACM SIGPLAN conference on
                 Object-oriented programming systems languages and
                 applications",
  citeulike-article-id = "3690401",
  citeulike-linkout-0 = "http://portal.acm.org/citation.cfm?id=1449764.1449782",
  citeulike-linkout-1 = "http://dx.doi.org/10.1145/1449764.1449782",
  date-added =   "2011-12-06 22:46:27",
  location =     "Nashville, TN, USA",
  priority =     "2",
  publisher =    "ACM",
  title =        "{jStar}: towards practical verification for java",
  x-abstract =   "In this paper we introduce a novel methodology for
                 verifying a large set of Java programs which builds on
                 recent theoretical developments in program
                 verification: it combines the idea of abstract
                 predicate families and the idea of symbolic execution
                 and abstraction using separation logic. The proposed
                 technology has been implemented in a new automatic
                 verification system, called {jStar}, which combines
                 theorem proving and abstract interpretation techniques.
                 We demonstrate the effectiveness of our methodology by
                 using {jStar} to verify example programs implementing
                 four popular design patterns (subject/observer,
                 visitor, factory, and pooling). Although these patterns
                 are extensively used by object-oriented developers in
                 real-world applications, so far they have been highly
                 challenging for existing object-oriented verification
                 techniques.",
  x-address =    "New York, NY, USA",
  x-doi =        "10.1145/1449764.1449782",
  x-isbn =       "978-1-60558-215-3",
  x-series =     "OOPSLA '08",
  x-url =        "http://dx.doi.org/10.1145/1449764.1449782",
  xpages =       "213--226",
  year =         "2008",
}

@InProceedings{Fahndrich2011Static,
  author =       "Manuel F{\"{a}}hndrich and Francesco Logozzo",
  booktitle =    "Proceedings of the 2010 international conference on
                 Formal verification of object-oriented software",
  citeulike-article-id = "9539828",
  citeulike-linkout-0 = "http://portal.acm.org/citation.cfm?id=1949305",
  date-added =   "2011-12-06 22:42:54",
  location =     "Paris, France",
  priority =     "2",
  publisher =    "Springer-Verlag",
  title =        "Static contract checking with abstract
                 interpretation",
  x-abstract =   "We present an overview of Clousot, our current tool to
                 statically check {CodeContracts}. {CodeContracts}
                 enable a compiler and language-independent
                 specification of Contracts (precondition,
                 postconditions and object invariants). Clousot checks
                 every method in isolation using an assume/guarantee
                 reasoning: For each method under analysis Clousot
                 assumes its precondition and asserts the postcondition.
                 For each invoked method, Clousot asserts its
                 precondition and assumes the postcondition. Clousot
                 also checks the absence of common runtime errors, such
                 as null-pointer errors, buffer or array overruns,
                 divisions by zero, as well as less common ones such as
                 checked integer overflows or floating point precision
                 mismatches in comparisons. At the core of Clousot there
                 is an abstract interpretation engine which infers
                 program facts. Facts are used to discharge the
                 assertions. The use of abstract interpretation (vs
                 usual weakest precondition-based checkers) has two main
                 advantages: (i) the checker automatically infers loop
                 invariants letting the user focus only on boundary
                 specifications; (ii) the checker is deterministic in
                 its behavior (which abstractly mimics the flowof the
                 program) and it can be tuned for precision and cost.
                 Clousot embodies other techniques, such as iterative
                 domain refinement, goal-directed backward propagation,
                 precondition and postcondition inference, and message
                 prioritization.",
  x-address =    "Berlin, Heidelberg",
  x-isbn =       "3-642-18069-8, 978-3-642-18069-9",
  x-series =     "FoVeOOS'10",
  x-url =        "http://portal.acm.org/citation.cfm?id=1949305",
  xpages =       "10--30",
  year =         "2011",
}

@InProceedings{liquid,
  author =       "Patrick M. Rondon and Ming Kawaguci and Ranjit Jhala",
  booktitle =    "Programming Languages Design and Implementation",
  citeulike-article-id = "9539571",
  citeulike-linkout-0 = "http://portal.acm.org/citation.cfm?id=1375602",
  citeulike-linkout-1 = "http://dx.doi.org/10.1145/1379022.1375602",
  date-added =   "2011-07-12 17:46:34",
  priority =     "2",
  publisher =    "ACM",
  title =        "Liquid types",
  x-abstract =   "We present Logically Qualified Data Types, abbreviated
                 to Liquid Types, a system that combines
                 {Hindley-Milner} type inference with Predicate
                 Abstraction to automatically infer dependent types
                 precise enough to prove a variety of safety properties.
                 Liquid types allow programmers to reap many of the
                 benefits of dependent types, namely static verification
                 of critical properties and the elimination of expensive
                 run-time checks, without the heavy price of manual
                 annotation. We have implemented liquid type inference
                 in {DSOLVE}, which takes as input an {OCAML} program
                 and a set of logical qualifiers and infers dependent
                 types for the expressions in the {OCAML} program. To
                 demonstrate the utility of our approach, we describe
                 experiments using {DSOLVE} to statically verify the
                 safety of array accesses on a set of {OCAML} benchmarks
                 that were previously annotated with dependent types as
                 part of the {DML} project. We show that when used in
                 conjunction with a fixed set of array bounds checking
                 qualifiers, {DSOLVE} reduces the amount of manual
                 annotation required for proving safety from 31\% of
                 program text to under 1\%.",
  x-address =    "New York, NY, USA",
  x-doi =        "10.1145/1379022.1375602",
  x-month =      jun,
  x-series =     "PLDI '08",
  x-url =        "http://dx.doi.org/10.1145/1379022.1375602",
  xpages =       "159--169",
  year =         "2008",
}

@Article{langlib,
  author =       "Sam Tobin-Hochstadt and Vincent St-Amour and Ryan
                 Culpepper and Matthew Flatt and Matthias Felleisen",
  booktitle =    "Proceedings of the 32nd ACM SIGPLAN conference on
                 Programming language design and implementation",
  citeulike-article-id = "9534653",
  citeulike-linkout-0 = "http://portal.acm.org/citation.cfm?id=1993514",
  citeulike-linkout-1 = "http://dx.doi.org/10.1145/1993498.1993514",
  date-added =   "2011-07-12 01:35:46",
  journal =      "SIGPLAN Not.",
  location =     "San Jose, California, USA",
  number =       "6",
  priority =     "2",
  publisher =    "ACM",
  title =        "Languages As Libraries",
  volume =       "46",
  x-abstract =   "Programming language design benefits from constructs
                 for extending the syntax and semantics of a host
                 language. While C's string-based macros empower
                 programmers to introduce notational shorthands, the
                 parser-level macros of Lisp encourage experimentation
                 with domain-specific languages. The Scheme programming
                 language improves on Lisp with macros that respect
                 lexical scope. The design of Racket---a descendant of
                 Scheme---goes even further with the introduction of a
                 full-fledged interface to the static semantics of the
                 language. A Racket extension programmer can thus add
                 constructs that are indistinguishable from {"}native{"}
                 notation, large and complex embedded domain-specific
                 languages, and even optimizing transformations for the
                 compiler backend. This power to experiment with
                 language design has been used to create a series of
                 sub-languages for programming with first-class classes
                 and modules, numerous languages for implementing the
                 Racket system, and the creation of a complete and fully
                 integrated typed sister language to Racket's untyped
                 base language. This paper explains Racket's language
                 extension {API} via an implementation of a small typed
                 sister language. The new language provides a rich type
                 system that accommodates the idioms of untyped Racket.
                 Furthermore, modules in this typed language can safely
                 exchange values with untyped modules. Last but not
                 least, the implementation includes a type-based
                 optimizer that achieves promising speedups. Although
                 these extensions are complex, their Racket
                 implementation is just a library, like any other
                 library, requiring no changes to the Racket
                 implementation.",
  x-address =    "New York, NY, USA",
  x-doi =        "10.1145/1993498.1993514",
  x-isbn =       "978-1-4503-0663-8",
  x-issn =       "0362-1340",
  x-month =      jun,
  x-series =     "PLDI '11",
  x-url =        "http://dx.doi.org/10.1145/1993498.1993514",
  xpages =       "132--141",
  year =         "2011",
}

@InProceedings{dimoulas-POPL2011,
  author =       "Christos Dimoulas and Robert B. Findler and Cormac
                 Flanagan and Matthias Felleisen",
  booktitle =    "Proceedings of the 38th annual ACM SIGPLAN-SIGACT
                 Symposium on Principles of Programming Languages",
  citeulike-article-id = "9525777",
  citeulike-linkout-0 = "http://doi.acm.org/10.1145/1926385.1926410",
  date-added =   "2011-07-10 01:38:04",
  keywords =     "assignment, behavioral, blame, contracts,
                 higher-order, programming",
  location =     "Austin, Texas, USA",
  priority =     "2",
  publisher =    "ACM",
  title =        "Correct blame for contracts: no more scapegoating",
  x-series =     "POPL '11",
  x-url =        "http://doi.acm.org/10.1145/1926385.1926410",
  xpages =       "215--226",
  year =         "2011",
}

@Article{kobayashi-popl09,
  author =       "Naoki Kobayashi",
  booktitle =    "Proceedings of the 36th annual ACM SIGPLAN-SIGACT
                 symposium on Principles of programming languages",
  citeulike-article-id = "5154855",
  citeulike-linkout-0 = "http://portal.acm.org/citation.cfm?id=1480881.1480933",
  citeulike-linkout-1 = "http://dx.doi.org/10.1145/1480881.1480933",
  date-added =   "2011-07-09 03:42:11",
  journal =      "SIGPLAN Not.",
  location =     "Savannah, GA, USA",
  number =       "1",
  priority =     "2",
  publisher =    "ACM",
  title =        "Types and higher-order recursion schemes for
                 verification of higher-order programs",
  volume =       "44",
  x-abstract =   "We propose a new verification method for temporal
                 properties of higher-order functional programs, which
                 takes advantage of Ong's recent result on the
                 decidability of the model-checking problem for
                 higher-order recursion schemes ({HORS}'s). A program is
                 transformed to an {HORS} that generates a tree
                 representing all the possible event sequences of the
                 program, and then the {HORS} is model-checked. Unlike
                 most of the previous methods for verification of
                 higher-order programs, our verification method is sound
                 and complete. Moreover, this new verification framework
                 allows a smooth integration of abstract model checking
                 techniques into verification of higher-order programs.
                 We also present a type-based verification algorithm for
                 {HORS}'s. The algorithm can deal with only a fragment
                 of the properties expressed by modal mu-calculus, but
                 the algorithm and its correctness proof are (arguably)
                 much simpler than those of Ong's game-semantics-based
                 algorithm. Moreover, while the {HORS} model checking
                 problem is {n-EXPTIME} in general, our algorithm is
                 linear in the size of {HORS}, under the assumption that
                 the sizes of types and specification formulas are
                 bounded by a constant.",
  x-address =    "New York, NY, USA",
  x-doi =        "10.1145/1480881.1480933",
  x-isbn =       "978-1-60558-379-2",
  x-issn =       "0362-1340",
  x-month =      jan,
  x-series =     "POPL '09",
  x-url =        "http://dx.doi.org/10.1145/1480881.1480933",
  xpages =       "416--428",
  year =         "2009",
}

@Article{kobayashi-cegar,
  author =       "Naoki Kobayashi and Ryosuke Sato and Hiroshi Unno",
  citeulike-article-id = "9524695",
  citeulike-linkout-0 = "http://portal.acm.org/citation.cfm?id=1993525",
  citeulike-linkout-1 = "http://dx.doi.org/10.1145/1993316.1993525",
  date-added =   "2011-07-09 03:40:30",
  journal =      "SIGPLAN Not.",
  number =       "6",
  priority =     "2",
  publisher =    "ACM",
  title =        "Predicate abstraction and {CEGAR} for higher-order
                 model checking",
  volume =       "46",
  x-abstract =   "Higher-order model checking (more precisely, the model
                 checking of higher-order recursion schemes) has been
                 extensively studied recently, which can automatically
                 decide properties of programs written in the
                 simply-typed λ-calculus with recursion and finite data
                 domains. This paper formalizes predicate abstraction
                 and counterexample-guided abstraction refinement
                 ({CEGAR}) for higher-order model checking, enabling
                 automatic verification of programs that use infinite
                 data domains such as integers. A prototype verifier for
                 higher-order functional programs based on the
                 formalization has been implemented and tested for
                 several programs.",
  x-address =    "New York, NY, USA",
  x-doi =        "10.1145/1993316.1993525",
  x-issn =       "0362-1340",
  x-month =      jun,
  x-url =        "http://dx.doi.org/10.1145/1993316.1993525",
  xpages =       "222--233",
  year =         "2011",
}

@Article{mcallester-contracts,
  author =       "Matthias Blume and David McAllester",
  citeulike-article-id = "9524694",
  citeulike-linkout-0 = "http://portal.acm.org/citation.cfm?id=1166016",
  citeulike-linkout-1 = "http://dx.doi.org/10.1017/s0956796806005971",
  date-added =   "2011-07-09 03:38:29",
  journal =      "Journal of Functional Programming",
  number =       "4-5",
  priority =     "2",
  publisher =    "Cambridge University Press",
  title =        "Sound and Complete Models of Contracts",
  volume =       "16",
  x-abstract =   "Even in statically typed languages it is useful to
                 have certain invariants checked dynamically. Findler
                 and Felleisen gave an algorithm for dynamically
                 checking expressive higher-order types called
                 contracts. They did not, however, give a semantics of
                 contracts. The lack of a semantics makes it impossible
                 to define and prove soundness and completeness of the
                 checking algorithm. (Given a semantics, a sound checker
                 never reports violations that do not exist under that
                 semantics; a complete checker is – in principle –
                 able to find violations when violations exist.)
                 Ideally, a semantics should capture what programmers
                 intuitively feel is the meaning of a contract or
                 otherwise clearly point out where intuition does not
                 match reality. In this paper we give an interpretation
                 of contracts for which we prove the {Findler-Felleisen}
                 algorithm sound and (under reasonable assumptions)
                 complete. While our semantics mostly matches intuition,
                 it also exposes a problem with predicate contracts
                 where an arguably more intuitive interpretation than
                 ours would render the checking algorithm unsound. In
                 our semantics we have to make use of a notion of safety
                 (which we define in the paper) to avoid unsoundness. We
                 are able to eliminate the ” leakage” of safety into
                 the semantics by changing the language, replacing the
                 original version of unrestricted predicate contracts
                 with a restricted form. The corresponding loss in
                 expressive power can be recovered by making safety
                 explicit as a contract. This can be done either in
                 ad-hoc fashion or by including general recursive
                 contracts. The addition of recursive contracts has
                 far-reaching implications, deeply affecting the
                 formulation of our model and requiring different
                 techniques for proving soundness.",
  x-address =    "New York, NY, USA",
  x-doi =        "10.1017/s0956796806005971",
  x-issn =       "0956-7968",
  x-month =      jul,
  x-url =        "http://dx.doi.org/10.1017/s0956796806005971",
  xpages =       "375--414",
  year =         "2006",
}

@Article{symexec,
  author =       "James C. King",
  citeulike-article-id = "80858",
  citeulike-linkout-0 = "http://portal.acm.org/citation.cfm?id=360252",
  citeulike-linkout-1 = "http://dx.doi.org/10.1145/360248.360252",
  date-added =   "2011-07-09 01:08:23",
  journal =      "Commun. ACM",
  number =       "7",
  priority =     "2",
  publisher =    "ACM",
  title =        "Symbolic Execution and Program Testing",
  volume =       "19",
  x-abstract =   "This paper describes the symbolic execution of
                 programs. Instead of supplying the normal inputs to a
                 program (e.g. numbers) one supplies symbols
                 representing arbitrary values. The execution proceeds
                 as in a normal execution except that values may be
                 symbolic formulas over the input symbols. The
                 difficult, yet interesting issues arise during the
                 symbolic execution of conditional branch type
                 statements. A particular system called {EFFIGY} which
                 provides symbolic execution for program testing and
                 debugging is also described. It interpretively executes
                 programs written in a simple {PL}/I style programming
                 language. It includes many standard debugging features,
                 the ability to manage and to prove things about
                 symbolic expressions, a simple program testing manager,
                 and a program verifier. A brief discussion of the
                 relationship between symbolic execution and program
                 proving is also included.",
  x-address =    "New York, NY, USA",
  x-doi =        "10.1145/360248.360252",
  x-issn =       "0001-0782",
  x-month =      jul,
  x-url =        "http://dx.doi.org/10.1145/360248.360252",
  xpages =       "385--394",
  year =         "1976",
}

@Book{meyer-eiffel,
  author =       "Bertrand Meyer",
  citeulike-article-id = "9524408",
  citeulike-linkout-0 = "http://www.amazon.ca/exec/obidos/redirect?tag=citeulike09-20\&amp;path=ASIN/0132479257",
  citeulike-linkout-1 = "http://www.amazon.de/exec/obidos/redirect?tag=citeulike01-21\&amp;path=ASIN/0132479257",
  citeulike-linkout-2 = "http://www.amazon.fr/exec/obidos/redirect?tag=citeulike06-21\&amp;path=ASIN/0132479257",
  citeulike-linkout-3 = "http://www.amazon.jp/exec/obidos/ASIN/0132479257",
  citeulike-linkout-4 = "http://www.amazon.co.uk/exec/obidos/ASIN/0132479257/citeulike00-21",
  citeulike-linkout-5 = "http://www.amazon.com/exec/obidos/redirect?tag=citeulike07-20\&path=ASIN/0132479257",
  citeulike-linkout-6 = "http://www.worldcat.org/isbn/0132479257",
  citeulike-linkout-7 = "http://books.google.com/books?vid=ISBN0132479257",
  citeulike-linkout-8 = "http://www.amazon.com/gp/search?keywords=0132479257\&index=books\&linkCode=qs",
  citeulike-linkout-9 = "http://www.librarything.com/isbn/0132479257",
  date-added =   "2011-07-09 00:02:07",
  day =          "01",
  howpublished = "Paperback",
  priority =     "2",
  publisher =    "Prentice Hall",
  title =        "Eiffel : The Language",
  x-isbn =       "0132479257",
  x-month =      oct,
  x-url =        "http://www.amazon.com/exec/obidos/redirect?tag=citeulike07-20\&path=ASIN/0132479257",
  year =         "1991",
}

@InProceedings{Xu2009Static,
  author =       "Dana N. Xu and Simon Peyton Jones and Simon Claessen",
  booktitle =    "POPL '09: Proceedings of the 36th annual ACM
                 SIGPLAN-SIGACT Symposium on Principles of Programming
                 Languages",
  citeulike-article-id = "6647620",
  citeulike-linkout-0 = "http://portal.acm.org/citation.cfm?id=1480881.1480889",
  citeulike-linkout-1 = "http://dx.doi.org/10.1145/1480881.1480889",
  date-added =   "2010-10-07 16:59:43",
  location =     "Savannah, GA, USA",
  priority =     "0",
  publisher =    "ACM",
  title =        "Static contract checking for {H}askell",
  x-abstract =   "Program errors are hard to detect and are costly both
                 to programmers who spend significant efforts in
                 debugging, and for systems that are guarded by runtime
                 checks. Static verification techniques have been
                 applied to imperative and object-oriented languages,
                 like Java and C\#, but few have been applied to a
                 higher-order lazy functional language, like Haskell. In
                 this paper, we describe a sound and automatic static
                 verification framework for Haskell, that is based on
                 contracts and symbolic execution. Our approach is
                 modular and gives precise blame assignments at
                 compile-time in the presence of higher-order functions
                 and laziness.",
  x-address =    "New York, NY, USA",
  x-doi =        "10.1145/1480881.1480889",
  x-isbn =       "978-1-60558-379-2",
  x-url =        "http://dx.doi.org/10.1145/1480881.1480889",
  xpages =       "41--52",
  year =         "2009",
}

@Book{Kaufmann2000ComputerAided,
  author =       "Matt Kaufmann and J. Strother Moore and Panagiotis
                 Manolios",
  citeulike-article-id = "6014020",
  citeulike-linkout-0 = "http://portal.acm.org/citation.cfm?id=555902",
  comment =      "short title",
  date-added =   "2009-10-27 03:43:26",
  priority =     "2",
  publisher =    "Kluwer Academic Publishers",
  title =        "{Computer-Aided} Reasoning: An Approach",
  x-abstract =   {From the {Publisher:An} Approach {Computer-Aided}
                 Reasoning: An Approach is a textbook introduction to
                 computer-aided reasoning. It can be used in graduate
                 and upper-division undergraduate courses on software
                 engineering or formal methods. It is also suitable in
                 conjunction with other books in courses on hardware
                 design, discrete mathematics, or theory, especially
                 courses stressing formalism, rigor, or mechanized
                 support. It is also appropriate for courses on
                 artificial intelligence or automated reasoning and as a
                 reference for business and industry. Current hardware
                 and software systems are often very complex and the
                 trend is towards increased complexity. Many of these
                 systems are of critical importance; therefore making
                 sure that they behave as expected is also of critical
                 importance. By modeling computing systems
                 mathematically, we obtain models that we can prove
                 behave correctly. The complexity of computing systems
                 makes such proofs very long, complicated, and
                 error-prone. To further increase confidence in our
                 reasoning, we can use a computer program to check our
                 proofs and even to automate some of their construction.
                 In this book we present: A practical functional
                 programming language closely related to Common Lisp
                 which is used to define functions (which can model
                 computing systems) and to make assertions about defined
                 functions; A formal logic in which defined functions
                 correspond to axioms; the logic is first-order,
                 includes induction, and allows us to prove theorems
                 about the functions; The computer-aided reasoning
                 system {ACL2}, which includes the programming language,
                 the logic, and mechanical support for the proof
                 process. The {ACL2} system hasbeen successfully applied
                 to projects of commercial interest, including
                 microprocessor, modeling, hardware verification,
                 microcode verification, and software verification. This
                 book gives a methodology for modeling computing systems
                 formally and for reasoning about those models with
                 mechanized assistance. The practicality of
                 computer-aided reasoning is further demonstrated in the
                 companion book, {Computer-Aided} Reasoning: {ACL2} Case
                 Studies. Approximately 140 exercises are distributed
                 throughout the book. Additional material is freely
                 available from the {ACL2} home page on the Web,
                 http://www.cs.utexas.edu/users/moore/ac12, including
                 solutions to the exercises, additional exercises, case
                 studies from the companion book, research papers, and
                 the {ACL2} system with detailed documentation. {ACL2}
                 Case Studies {Computer-Aided} Reasoning: {ACL2} Case
                 Studies illustrates how the computer-aided reasoning
                 system {ACL2} can be used in productive and innovative
                 ways to design, build, and maintain hardware and
                 software systems. Included here are technical papers
                 written by twenty-one contributors that report on
                 self-contained case studies, some of which are
                 sanitized industrial projects. The papers deal with a
                 wide variety of ideas, including floating-point
                 arithmetic, microprocessor simulation, model checking,
                 symbolic trajectory evaluation, compilation, proof
                 checking, real analysis, and several others.
                 {Computer-Aided} Reasoning: {ACL2} Case Studies is
                 meant for two audiences: those looking for innovative
                 ways to design, build, and maintain hardware and
                 software systems faster and more reliably, and those
                 wishing to learn how to do this. The former audience
                 includes project managers and students in
                 survey-oriented courses. The latter audience includes
                 students and professionals pursuing rigorous approaches
                 to hardware and software engineering or formal methods.
                 {Computer-Aided} Reasoning: {ACL2} Case Studies can be
                 used in graduate and upper-division undergraduate
                 courses on Software Engineering, Formal Methods,
                 Hardware Design, Theory of Computation, Artificial
                 Intelligence, and Automated Reasoning. The book is
                 divided into two parts. Part I begins with a discussion
                 of the effort involved in using {ACL2}. It also
                 contains a brief introduction to the {ACL2} logic and
                 its mechanization, which is intended to give the reader
                 sufficient background to read the case studies. A m
?? BibTeX string too long for field ``x-abstract''.
ore thorough, textbook introduction to {ACL2} may be found in the companion book, {Computer-Aided} Reasoning: An Approach.  The heart of the book is Part {II}, where the case studies are presented. The case studies contain exercises whose solutions are on the Web. In addition, the complete {ACL2} scripts necessary to formalize the models and prove all the properties discussed are on the Web. For example, when we say that one of the case studies formalizes a floating-point multiplier and proves it correct, we mean that not only can you read an English description of the model and how it was proved correct, but you can obtain the entire formal content of the project and replay the proofs, if you wish, with your copy of {ACL2}. {ACL2} may be obtained from its home page, http://www.cs.utexas.edu/users/moore/ac12. The results reported in each case study, as {ACL2} input scripts, as well as exercise solutions for both books, are available from this page.},
    x-address = {Norwell, MA, USA},
    x-isbn = {0792377443},
    x-url = {http://portal.acm.org/citation.cfm?id=555902},
    year = {2000}
}

@Book{2000ComputerAided,
  citeulike-article-id = "6014012",
  citeulike-linkout-0 = "http://www.amazon.ca/exec/obidos/redirect?tag=citeulike09-20\&amp;path=ASIN/0792378490",
  citeulike-linkout-1 = "http://www.amazon.de/exec/obidos/redirect?tag=citeulike01-21\&amp;path=ASIN/0792378490",
  citeulike-linkout-2 = "http://www.amazon.fr/exec/obidos/redirect?tag=citeulike06-21\&amp;path=ASIN/0792378490",
  citeulike-linkout-3 = "http://www.amazon.jp/exec/obidos/ASIN/0792378490",
  citeulike-linkout-4 = "http://www.amazon.co.uk/exec/obidos/ASIN/0792378490/citeulike00-21",
  citeulike-linkout-5 = "http://www.amazon.com/exec/obidos/redirect?tag=citeulike07-20\&path=ASIN/0792378490",
  citeulike-linkout-6 = "http://www.worldcat.org/isbn/0792378490",
  citeulike-linkout-7 = "http://books.google.com/books?vid=ISBN0792378490",
  citeulike-linkout-8 = "http://www.amazon.com/gp/search?keywords=0792378490\&index=books\&linkCode=qs",
  citeulike-linkout-9 = "http://www.librarything.com/isbn/0792378490",
  date-added =   "2009-10-27 03:40:30",
  day =          "30",
  edition =      "1",
  howpublished = "Hardcover",
  keywords =     "acl2",
  priority =     "2",
  publisher =    "Springer",
  title =        "{Computer-Aided} Reasoning: {ACL2} Case Studies
                 (Advances in Formal Methods)",
  x-isbn =       "0792378490",
  x-month =      jun,
  x-url =        "http://www.amazon.com/exec/obidos/redirect?tag=citeulike07-20\&path=ASIN/0792378490",
  year =         "2000",
}

@Book{VanRossum2009Python,
  author =       "Guido Van Rossum and Fred L. Drake",
  citeulike-article-id = "5937268",
  citeulike-linkout-0 = "http://www.amazon.ca/exec/obidos/redirect?tag=citeulike09-20\&amp;path=ASIN/1441412697",
  citeulike-linkout-1 = "http://www.amazon.de/exec/obidos/redirect?tag=citeulike01-21\&amp;path=ASIN/1441412697",
  citeulike-linkout-2 = "http://www.amazon.fr/exec/obidos/redirect?tag=citeulike06-21\&amp;path=ASIN/1441412697",
  citeulike-linkout-3 = "http://www.amazon.jp/exec/obidos/ASIN/1441412697",
  citeulike-linkout-4 = "http://www.amazon.co.uk/exec/obidos/ASIN/1441412697/citeulike00-21",
  citeulike-linkout-5 = "http://www.amazon.com/exec/obidos/redirect?tag=citeulike07-20\&path=ASIN/1441412697",
  citeulike-linkout-6 = "http://www.worldcat.org/isbn/1441412697",
  citeulike-linkout-7 = "http://books.google.com/books?vid=ISBN1441412697",
  citeulike-linkout-8 = "http://www.amazon.com/gp/search?keywords=1441412697\&index=books\&linkCode=qs",
  citeulike-linkout-9 = "http://www.librarything.com/isbn/1441412697",
  date-added =   "2009-10-13 16:55:03",
  day =          "20",
  howpublished = "Paperback",
  keywords =     "python",
  priority =     "2",
  publisher =    "CreateSpace",
  title =        "Python 3 Reference Manual: (Python Documentation
                 Manual Part 2)",
  x-isbn =       "1441412697",
  x-month =      mar,
  x-url =        "http://www.amazon.com/exec/obidos/redirect?tag=citeulike07-20\&path=ASIN/1441412697",
  year =         "2009",
}

@TechReport{m:nisp,
  author =       "Drew McDermott",
  citeulike-article-id = "5917483",
  date-added =   "2009-10-09 20:21:49",
  institution =  "Yale University, Department of Computer Science",
  keywords =     "dissertation",
  number =       "YALE/DCS/RR-642",
  priority =     "0",
  title =        "Revised {NISP} Manual",
  year =         "2004",
}

@InProceedings{Reynolds68,
  author =       "John C. Reynolds",
  booktitle =    "IFIP Congress (1)",
  citeulike-article-id = "5917482",
  citeulike-linkout-0 = "ftp://ftp.cs.cmu.edu/user/jcr/autodataset.pdf",
  date-added =   "2009-10-09 20:21:49",
  keywords =     "dissertation, shape-analysis",
  priority =     "0",
  title =        "Automatic computation of data set definitions.",
  x-url =        "ftp://ftp.cs.cmu.edu/user/jcr/autodataset.pdf",
  xpages =       "456--461",
  year =         "1968",
}

@InProceedings{krcf:occurrence,
  author =       "Raghavan Komondoor and G. Ramalingam and Satish
                 Chandra and John Field",
  booktitle =    "TACAS",
  citeulike-article-id = "5917481",
  date-added =   "2009-10-09 20:21:49",
  keywords =     "dissertation",
  priority =     "0",
  title =        "Dependent types for program understanding",
  volume =       "3440",
  x-series =     "LNCS",
  xpages =       "157--173",
  year =         "2005",
}

@Article{mf:multilang-toplas,
  author =       "Jacob Matthews and Robert B. Findler",
  citeulike-article-id = "5917480",
  date-added =   "2009-10-09 20:21:49",
  journal =      "ACM Transactions on Programming Languages and
                 Systems",
  keywords =     "dissertation",
  number =       "3",
  priority =     "0",
  publisher =    "ACM",
  title =        "Operational semantics for multi-language programs",
  volume =       "31",
  x-address =    "New York, NY, USA",
  xpages =       "1--44",
  year =         "2009",
}

@InProceedings{fff:classes,
  author =       "Matthew Flatt and Robert B. Findler and Matthias
                 Felleisen",
  booktitle =    "Asian Symposium on Programming Languages and Systems
                 (APLAS) 2006",
  citeulike-article-id = "5917479",
  date-added =   "2009-10-09 20:21:48",
  keywords =     "dissertation",
  priority =     "0",
  title =        "Scheme with Classes, Mixins, and Traits",
  x-month =      nov,
  xpages =       "270--289",
  year =         "2006",
}

@InProceedings{mf:multilang,
  author =       "Jacob Matthews and Robert B. Findler",
  booktitle =    "POPL '07: Proceedings of the 34th annual ACM
                 SIGPLAN-SIGACT symposium on Principles of programming
                 languages",
  citeulike-article-id = "5917478",
  date-added =   "2009-10-09 20:21:48",
  keywords =     "dissertation",
  location =     "Nice, France",
  priority =     "0",
  publisher =    "ACM",
  title =        "Operational semantics for multi-language programs",
  x-address =    "New York, NY, USA",
  xpages =       "3--10",
  year =         "2007",
}

@InProceedings{mw:erlang,
  author =       "Simon Marlow and Philip Wadler",
  booktitle =    "ICFP '97: Proceedings of the second ACM SIGPLAN
                 international conference on Functional programming",
  citeulike-article-id = "5917477",
  date-added =   "2009-10-09 20:21:48",
  keywords =     "dissertation",
  location =     "Amsterdam, The Netherlands",
  priority =     "0",
  publisher =    "ACM Press",
  title =        "A practical subtyping system for {Erlang}",
  x-address =    "New York, NY, USA",
  xpages =       "136--149",
  year =         "1997",
}

@Book{boyer-moore97,
  author =       "R. S. Boyer and J. S. Moore",
  citeulike-article-id = "5917476",
  date-added =   "2009-10-09 20:21:48",
  keywords =     "dissertation",
  priority =     "0",
  publisher =    "Academic Press",
  title =        "A Computation Logic (2nd Edition)",
  x-address =    "New York, NY",
  year =         "1997",
}

@InProceedings{hilsdale00writing,
  author =       "Erik Hilsdale and Daniel P. Friedman",
  booktitle =    "Scheme and Functional Programming",
  citeulike-article-id = "5917475",
  date-added =   "2009-10-09 20:21:48",
  keywords =     "dissertation",
  priority =     "0",
  title =        "Writing macros in continuation-passing style",
  year =         "2000",
}

@InProceedings{culpepper05units,
  author =       "Ryan Culpepper and Scott Owens and Matthew Flatt",
  booktitle =    "Proc. Fourth International Conference on Generative
                 Programming and Component Engineering",
  citeulike-article-id = "5917474",
  date-added =   "2009-10-09 20:21:48",
  keywords =     "dissertation",
  priority =     "0",
  title =        "Syntactic Abstraction in Component Interfaces.",
  xpages =       "373--388",
  year =         "2005",
}

@InProceedings{girard71,
  author =       "J. Y. Girard",
  booktitle =    "Proceedings of the Second Scandinavian Logic
                 Symposium",
  citeulike-article-id = "5917473",
  date-added =   "2009-10-09 20:21:48",
  keywords =     "dissertation",
  priority =     "0",
  publisher =    "North-Holland Publishing Co.",
  title =        "Une extension de l'interpr\'{e}tation de {G\"{o}del}
                 \`{a} l'analyse, et son application \`{a}
                 l'\'{e}limination de coupures dans l'analyse et la
                 th\'{e}orie des types",
  x-editor =     "Fenstad, J. E.",
  xpages =       "63--92",
  year =         "1971",
}

@InProceedings{zip-calc,
  author =       "Mark Tullsen",
  booktitle =    "MPC 2000",
  citeulike-article-id = "5917472",
  date-added =   "2009-10-09 20:21:48",
  keywords =     "dissertation",
  priority =     "0",
  publisher =    "Springer-Verlag",
  title =        "The {Zip} {Calculus}",
  volume =       "1837",
  x-editor =     "Backhouse, Roland and Oliveira, Jose N.",
  x-month =      jul,
  x-series =     "LNCS",
  xpages =       "28--44",
  year =         "2000",
}

@TechReport{dots-tr,
  author =       "T. Stephen Strickland and Sam T. Hochstadt and
                 Matthias Felleisen",
  citeulike-article-id = "5917471",
  citeulike-linkout-0 = "http://www.ccs.neu.edu/scheme/pubs/NU-CCIS-08-03.pdf",
  date-added =   "2009-10-09 20:21:48",
  institution =  "Northeastern University",
  keywords =     "dissertation",
  number =       "NU-CCIS-08-03",
  priority =     "0",
  title =        "{Variable-Arity Polymorphism}",
  x-url =        "http://www.ccs.neu.edu/scheme/pubs/NU-CCIS-08-03.pdf",
  year =         "2008",
}

@Misc{moggi,
  author =       "Eugenio Moggi",
  citeulike-article-id = "5917470",
  date-added =   "2009-10-09 20:21:48",
  howpublished = "Invited talk, APPSEM Workshop on Subtyping and
                 Dependent Types in Programming",
  keywords =     "dissertation",
  priority =     "0",
  title =        "Arity Polymorphism and Dependent Types",
  x-month =      jul,
  year =         "2000",
}

@Article{faking-it,
  author =       "Conor McBride",
  citeulike-article-id = "5917469",
  date-added =   "2009-10-09 20:21:48",
  journal =      "Journal of Functional Programming",
  keywords =     "dissertation",
  number =       "5",
  priority =     "0",
  publisher =    "Cambridge University Press",
  title =        "Faking it: Simulating {Dependent} {Types} in
                 {Haskell}",
  volume =       "12",
  xpages =       "375--392",
  year =         "2002",
}

@TechReport{flexijava,
  author =       "T. Stephen Strickland and Richard Cobbe and Matthias
                 Felleisen",
  citeulike-article-id = "5917468",
  date-added =   "2009-10-09 20:21:48",
  institution =  "Northeastern University",
  keywords =     "dissertation",
  number =       "NU-CCIS-08-01",
  priority =     "0",
  title =        "Variable-arity Generic Interfaces",
  year =         "2008",
}

@InProceedings{cpp-varity,
  author =       "Douglas Gregor and Jaakko J{\"{a}}rvi",
  booktitle =    "{SAC} '07",
  citeulike-article-id = "5917467",
  date-added =   "2009-10-09 20:21:48",
  keywords =     "dissertation",
  location =     "Seoul, Korea",
  priority =     "0",
  publisher =    "ACM Press",
  title =        "Variadic templates for {C++}",
  x-address =    "New York, NY, USA",
  xpages =       "1101--1108",
  year =         "2007",
}

@InProceedings{wand84,
  author =       "Mitchell Wand",
  booktitle =    "{SIGPLAN '84: Proceedings of the 1984 SIGPLAN
                 Symposium on Compiler Construction}",
  citeulike-article-id = "5917466",
  date-added =   "2009-10-09 20:21:48",
  keywords =     "dissertation",
  location =     "Montreal, Canada",
  priority =     "0",
  publisher =    "ACM Press",
  title =        "A semantic prototyping system",
  x-address =    "New York, NY, USA",
  xpages =       "213--221",
  year =         "1984",
}

@InProceedings{pcmkf:continuations,
  author =       "G. Pettyjohn and J. Clements and J. Marshall and S.
                 Krishnamurthi and M. Felleisen",
  citeulike-article-id = "5917465",
  date-added =   "2009-10-09 20:21:48",
  keywords =     "dissertation",
  priority =     "0",
  title =        "Continuations from Generalized Stack Inspection",
  x-month =      sep,
  xpages =       "216--227",
  year =         "2005",
}

@Article{fs:ziggurat-jfp,
  author =       "David Fisher and Olin Shivers",
  citeulike-article-id = "5917464",
  date-added =   "2009-10-09 20:21:48",
  eprint =       "http://journals.cambridge.org/article\_S0956796808006928",
  journal =      "Journal of Functional Programming",
  keywords =     "dissertation",
  number =       "Special Double Issue 5-6",
  priority =     "0",
  title =        "Building language towers with {Ziggurat}",
  volume =       "18",
  xpages =       "707--780",
  year =         "2008",
}

@TechReport{plt-tr2009-reference-v4.2.1,
  author =       "Matthew Flatt and T. Pl",
  citeulike-article-id = "5917463",
  citeulike-linkout-0 = "http://download.plt-scheme.org/doc/4.2.1/pdf/reference.pdf",
  comment =      "\url{http://plt-scheme.org/techreports/}",
  date-added =   "2009-10-09 20:21:48",
  institution =  "PLT Scheme Inc.",
  keywords =     "dissertation",
  number =       "PLT-TR2009-reference-v4.2.1",
  priority =     "0",
  title =        "Reference: {PLT} Scheme",
  type =         "Reference Manual",
  x-month =      jul,
  x-url =        "http://download.plt-scheme.org/doc/4.2.1/pdf/reference.pdf",
  year =         "2009",
}

@TechReport{leavens,
  author =       "Gary T. Leavens and Curtis Clifton and Brian Dorn",
  citeulike-article-id = "5917462",
  date-added =   "2009-10-09 20:21:48",
  institution =  "Iowa State University",
  keywords =     "dissertation",
  number =       "05-18a",
  priority =     "0",
  title =        "{A Type Notation for Scheme}",
  x-month =      aug,
  year =         "2005",
}

@InProceedings{dh:var-ar,
  author =       "Hsianlin Dzeng and Christopher T. Haynes",
  booktitle =    "LFP '94: Proceedings of the 1994 ACM conference on
                 LISP and Functional Programming",
  citeulike-article-id = "5917461",
  date-added =   "2009-10-09 20:21:48",
  keywords =     "dissertation",
  location =     "Orlando, Florida, United States",
  priority =     "0",
  publisher =    "ACM Press",
  title =        "Type reconstruction for variable-arity procedures",
  x-address =    "New York, NY, USA",
  xpages =       "239--249",
  year =         "1994",
}

@TechReport{h:infer,
  author =       "Christopher T. Haynes",
  citeulike-article-id = "5917460",
  date-added =   "2009-10-09 20:21:48",
  institution =  "Indiana University",
  keywords =     "dissertation",
  number =       "367",
  priority =     "0",
  title =        "Infer: {A} Statically-typed Dialect of Scheme",
  type =         "Technical Report",
  year =         "1995",
}

@InProceedings{sthf:variable-arity,
  author =       "T. Stephen Strickland and Sam T. Hochstadt and
                 Matthias Felleisen",
  booktitle =    "{ESOP} '09: Proceedings of the Eighteenth European
                 Symposium On Programming",
  citeulike-article-id = "5917459",
  date-added =   "2009-10-09 20:21:48",
  keywords =     "dissertation",
  location =     "York, UK",
  priority =     "0",
  title =        "Practical {Variable-Arity} Polymorphism",
  x-month =      mar,
  xpages =       "32--46",
  year =         "2009",
}

@InProceedings{might:lfa,
  author =       "Matthew Might",
  booktitle =    "POPL '07: Proceedings of the 34th annual ACM
                 SIGPLAN-SIGACT symposium on Principles of programming
                 languages",
  citeulike-article-id = "5917458",
  date-added =   "2009-10-09 20:21:48",
  keywords =     "dissertation",
  location =     "Nice, France",
  priority =     "0",
  publisher =    "ACM",
  title =        "Logic-flow analysis of higher-order programs",
  x-address =    "New York, NY, USA",
  xpages =       "185--198",
  year =         "2007",
}

@PhdThesis{aw:soft-typing,
  author =       "Andrew Wright",
  citeulike-article-id = "5917457",
  date-added =   "2009-10-09 20:21:48",
  keywords =     "dissertation",
  priority =     "0",
  school =       "{R}ice {U}niversity",
  title =        "Practical Soft Typing",
  year =         "1994",
}

@InProceedings{mwh:refinement,
  author =       "Yitzhak Mandelbaum and David Walker and Robert
                 Harper",
  booktitle =    "ICFP '03: Proceedings of the eighth ACM SIGPLAN
                 international conference on Functional programming",
  citeulike-article-id = "5917456",
  date-added =   "2009-10-09 20:21:48",
  keywords =     "dissertation",
  location =     "Uppsala, Sweden",
  priority =     "0",
  publisher =    "ACM",
  title =        "An effective theory of type refinements",
  x-address =    "New York, NY, USA",
  xpages =       "213--225",
  year =         "2003",
}

@InProceedings{cf:hybrid,
  author =       "Cormac Flanagan",
  booktitle =    "POPL '06: Conference record of the 33rd ACM
                 SIGPLAN-SIGACT symposium on Principles of programming
                 languages",
  citeulike-article-id = "5917455",
  date-added =   "2009-10-09 20:21:48",
  keywords =     "dissertation",
  location =     "Charleston, South Carolina, USA",
  priority =     "0",
  publisher =    "ACM",
  title =        "Hybrid type checking",
  x-address =    "New York, NY, USA",
  xpages =       "245--256",
  year =         "2006",
}

@InProceedings{palsberg01,
  author =       "Jens Palsberg and Christina Pavlopoulou",
  booktitle =    "POPL '98: Proceedings of the 25th ACM SIGPLAN-SIGACT
                 symposium on Principles of programming languages",
  citeulike-article-id = "5917454",
  date-added =   "2009-10-09 20:21:48",
  keywords =     "dissertation",
  location =     "San Diego, California, United States",
  priority =     "0",
  publisher =    "ACM",
  title =        "From polyvariant flow information to intersection and
                 union types",
  x-address =    "New York, NY, USA",
  xpages =       "197--208",
  year =         "1998",
}

@Article{palsberg95,
  author =       "Jens Palsberg and Patrick O'Keefe",
  citeulike-article-id = "5917453",
  date-added =   "2009-10-09 20:21:48",
  journal =      "ACM Trans. Program. Lang. Syst.",
  keywords =     "dissertation",
  number =       "4",
  priority =     "0",
  publisher =    "ACM",
  title =        "A type system equivalent to flow analysis",
  volume =       "17",
  x-address =    "New York, NY, USA",
  xpages =       "576--599",
  year =         "1995",
}

@InProceedings{c:typed-lisp,
  author =       "Robert Cartwright",
  citeulike-article-id = "5917452",
  date-added =   "2009-10-09 20:21:48",
  keywords =     "dissertation",
  priority =     "0",
  title =        "User-Defined Data Types as an Aid to Verifying {LISP}
                 Programs",
  xpages =       "228--256",
  year =         "1976",
}

@InProceedings{ruby-static09,
  author =       "Michael Furr and Jong hoon David An and Jeffrey S.
                 Foster and Michael Hicks",
  booktitle =    "SAC '09: Proceedings of the 2009 ACM Symposium on
                 Applied Computing",
  citeulike-article-id = "5917451",
  date-added =   "2009-10-09 20:21:48",
  keywords =     "dissertation",
  location =     "Honolulu, Hawaii",
  priority =     "0",
  publisher =    "ACM",
  title =        "Static type inference for Ruby",
  x-address =    "New York, NY, USA",
  xpages =       "1859--1866",
  year =         "2009",
}

@PhdThesis{agda,
  author =       "Ulf Norell",
  citeulike-article-id = "5917450",
  date-added =   "2009-10-09 20:21:48",
  keywords =     "dissertation",
  priority =     "0",
  school =       "Chalmers University of Technology",
  title =        "Towards a practical programming language based on
                 dependent type theory",
  year =         "2007",
}

@Book{COQBook,
  author =       "Yves Bertot and Pierre Cast\'{e}ran",
  citeulike-article-id = "5917449",
  date-added =   "2009-10-09 20:21:48",
  keywords =     "dissertation",
  priority =     "0",
  publisher =    "Springer-Verlag",
  title =        "Interactive Theorem Proving and Program Development",
  volume =       "XXV",
  x-series =     "EATCS Texts in Theoretical Computer Science",
  year =         "2004",
}

@InCollection{Howard80,
  author =       "William A. Howard",
  booktitle =    "To H. B. Curry: Essays on Combinatory Logic, Lambda
                 Calculus, and Formalism",
  citeulike-article-id = "5917448",
  comment =      "Reprint of 1969 article",
  date-added =   "2009-10-09 20:21:48",
  keywords =     "dissertation",
  priority =     "0",
  publisher =    "Academic Press",
  title =        "The formulas-as-types notion of construction",
  x-editor =     "Seldin, J. P. and Hindley, J. R.",
  xpages =       "479--490",
  year =         "1980",
}

@InProceedings{thf:popl08,
  author =       "Sam T. Hochstadt and Matthias Felleisen",
  citeulike-article-id = "5917447",
  date-added =   "2009-10-09 20:21:48",
  keywords =     "dissertation",
  priority =     "0",
  title =        "{The Design and Implementation of {Typed} {Scheme}}",
  xpages =       "395--406",
  year =         "2008",
}

@InProceedings{cartwright:paths,
  author =       "Robert Cartwright and Robert Hood and Philip
                 Matthews",
  booktitle =    "POPL '81: Proceedings of the 8th ACM SIGPLAN-SIGACT
                 Symposium on Principles of Programming Languages",
  citeulike-article-id = "5917446",
  date-added =   "2009-10-09 20:21:48",
  keywords =     "dissertation",
  location =     "Williamsburg, Virginia",
  priority =     "0",
  publisher =    "ACM",
  title =        "Paths: an abstract alternative to pointers",
  x-address =    "New York, NY, USA",
  xpages =       "14--27",
  year =         "1981",
}

@Book{ltm:php,
  author =       "Rasmus Lerdorf and Kevin Tatroe and Peter MacIntyre",
  citeulike-article-id = "5917444",
  citeulike-linkout-0 = "http://www.amazon.ca/exec/obidos/redirect?tag=citeulike09-20\&amp;path=ASIN/0596006810",
  citeulike-linkout-1 = "http://www.amazon.de/exec/obidos/redirect?tag=citeulike01-21\&amp;path=ASIN/0596006810",
  citeulike-linkout-2 = "http://www.amazon.fr/exec/obidos/redirect?tag=citeulike06-21\&amp;path=ASIN/0596006810",
  citeulike-linkout-3 = "http://www.amazon.jp/exec/obidos/ASIN/0596006810",
  citeulike-linkout-4 = "http://www.amazon.co.uk/exec/obidos/ASIN/0596006810/citeulike00-21",
  citeulike-linkout-5 = "http://www.amazon.com/exec/obidos/redirect?tag=citeulike07-20\&path=ASIN/0596006810",
  citeulike-linkout-6 = "http://www.worldcat.org/isbn/0596006810",
  citeulike-linkout-7 = "http://books.google.com/books?vid=ISBN0596006810",
  citeulike-linkout-8 = "http://www.amazon.com/gp/search?keywords=0596006810\&index=books\&linkCode=qs",
  citeulike-linkout-9 = "http://www.librarything.com/isbn/0596006810",
  date-added =   "2009-10-09 20:20:25",
  day =          "28",
  edition =      "2",
  howpublished = "Paperback",
  keywords =     "php, scripting",
  priority =     "1",
  publisher =    "O'Reilly Media, Inc.",
  title =        "Programming {PHP}",
  x-isbn =       "0596006810",
  x-month =      apr,
  x-url =        "http://www.amazon.com/exec/obidos/redirect?tag=citeulike07-20\&path=ASIN/0596006810",
  year =         "2006",
}

@InProceedings{Sheard2002Template,
  author =       "Tim Sheard and Simon P. Jones",
  booktitle =    "Haskell '02: Proceedings of the 2002 ACM SIGPLAN
                 workshop on Haskell",
  citeulike-article-id = "3211",
  citeulike-linkout-0 = "http://portal.acm.org/citation.cfm?id=581691",
  citeulike-linkout-1 = "http://dx.doi.org/10.1145/581690.581691",
  date-added =   "2009-10-09 20:18:25",
  keywords =     "macros",
  location =     "Pittsburgh, Pennsylvania",
  priority =     "0",
  publisher =    "ACM",
  title =        "Template meta-programming for Haskell",
  x-abstract =   "We propose a new extension to the purely functional
                 programming language Haskell that supports compile-time
                 meta-programming. The purpose of the system is to
                 support the algorithmic construction of programs at
                 {compile-time.The} ability to generate code at compile
                 time allows the programmer to implement such features
                 as polytypic programs, macro-like expansion, user
                 directed optimization (such as inlining), and the
                 generation of supporting data structures and functions
                 from existing data structures and {functions.Our}
                 design is being implemented in the Glasgow Haskell
                 Compiler, ghc.",
  x-address =    "New York, NY, USA",
  x-doi =        "10.1145/581690.581691",
  x-isbn =       "1-58113-605-6",
  x-url =        "http://dx.doi.org/10.1145/581690.581691",
  xpages =       "1--16",
  year =         "2002",
}

@Misc{Krishnamurthi2001Linguistic,
  author =       "S. Krishnamurthi",
  citeulike-article-id = "3249",
  citeulike-linkout-0 = "http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.29.878",
  date-added =   "2009-10-09 20:18:12",
  priority =     "2",
  title =        "Linguistic Reuse",
  x-abstract =   "Programmers employ a multitude of languages to build
                 systems. Some are general purpose languages. Others are
                 specific to individual domains. These assist
                 programmers with at least three different tasks: domain
                 modeling, system validation and representing the
                 stucture of their general purpose program. As a result,
                 programming languages have become key factors in the
                 software engineering process. They are, however, rarely
                 codified into the process and treated systematically.
                 My dissertation...",
  x-url =        "http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.29.878",
  year =         "2001",
}

@Proceedings{Bawden1999Quasiquotation,
  author =       "Alan Bawden",
  booktitle =    "Partial Evaluation and Semantic-Based Program
                 Manipulation",
  citeulike-article-id = "4871",
  citeulike-linkout-0 = "http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.5.2566",
  date-added =   "2009-10-09 20:17:55",
  priority =     "2",
  title =        "Quasiquotation in Lisp",
  x-abstract =   "Quasiquotation is the technology commonly used in Lisp
                 to write program-generating programs. This paper
                 explains how quasiquotation works, why it works well,
                 and what its limitations are. A brief history of
                 quasiquotation is included.",
  x-url =        "http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.5.2566",
  xpages =       "4--12",
  year =         "1999",
}

@Misc{Mcbride2001Faking,
  author =       "C. Mcbride",
  citeulike-article-id = "4850",
  citeulike-linkout-0 = "http://citeseer.ist.psu.edu/mcbride01faking.html",
  citeulike-linkout-1 = "http://citeseer.lcs.mit.edu/mcbride01faking.html",
  citeulike-linkout-2 = "http://citeseer.ifi.unizh.ch/mcbride01faking.html",
  citeulike-linkout-3 = "http://citeseer.comp.nus.edu.sg/mcbride01faking.html",
  date-added =   "2009-10-09 20:17:18",
  keywords =     "dots",
  priority =     "2",
  title =        "Faking it---simulating dependent types in Haskell",
  x-abstract =   "Dependent types reflect the fact that validity of data
                 is often a relative notion by allowing prior data to
                 affect the types of subsequent data. Not only does this
                 make for a precise type system, but also a highly
                 generic one: both the type and the program for each
                 instance of a family of operations can be computed from
                 the data which codes for that instance. Recent
                 experimental extensions to the Haskell type class
                 mechanism give us strong tools to relativize types to
                 other types. We may...",
  x-url =        "http://citeseer.ist.psu.edu/mcbride01faking.html",
  year =         "2001",
}

@InProceedings{Findler1999Modular,
  author =       "Robert B. Findler and Matthew Flatt",
  booktitle =    "Proceedings of the ACM SIGPLAN International
                 Conference on Functional Programming (ICFP '98)",
  citeulike-article-id = "157601",
  citeulike-linkout-0 = "http://citeseer.ist.psu.edu/findler98modular.html",
  citeulike-linkout-1 = "http://citeseer.lcs.mit.edu/findler98modular.html",
  citeulike-linkout-2 = "http://citeseer.ifi.unizh.ch/findler98modular.html",
  citeulike-linkout-3 = "http://citeseer.comp.nus.edu.sg/findler98modular.html",
  date-added =   "2009-10-09 20:17:11",
  keywords =     "modules",
  priority =     "0",
  title =        "Modular {Object-Oriented} Programming with Units and
                 Mixins",
  volume =       "34(1)",
  x-abstract =   "Module and class systems have evolved to meet the
                 demand for reuseable software components. Considerable
                 effort has been invested in developing new module and
                 class systems, and in demonstrating how each promotes
                 code reuse. However, relatively little has been said
                 about the interaction of these constructs, and how
                 using modules and classes together can improve
                 programs. In this paper, we demonstrate the synergy of
                 a particular form of modules and classes---called units
                 and mixins,...",
  x-url =        "http://citeseer.ist.psu.edu/findler98modular.html",
  xpages =       "94--104",
  year =         "1999",
}

@InBook{Felleisen1990Expressive,
  author =       "Matthias Felleisen",
  booktitle =    "ESOP '90 3rd European Symposium on Programming,
                 Copenhagen, Denmark",
  citeulike-article-id = "96217",
  citeulike-linkout-0 = "http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.51.4656",
  date-added =   "2009-10-09 20:16:50",
  priority =     "0",
  publisher =    "Springer-Verlag",
  title =        "On the Expressive Power of Programming Languages",
  volume =       "432",
  x-abstract =   "The literature on programming languages contains an
                 abundance of informal claims on the relative expressive
                 power of programming languages, but there is no
                 framework for formalizing such statements nor for
                 deriving interesting consequences. As a first step in
                 this direction, we develop a formal notion of
                 expressiveness and investigate its properties. To
                 validate the theory, we analyze some widely held
                 beliefs about the expressive power of several
                 extensions of functional languages. Based on...",
  x-address =    "New York, N.Y.",
  x-editor =     "Jones, N.",
  x-url =        "http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.51.4656",
  xpages =       "134--151",
  year =         "1990",
}

@Book{PeytonJones2003Haskell,
  author =       "Simon L. Peyton Jones",
  citeulike-article-id = "1643124",
  citeulike-linkout-0 = "http://www.amazon.ca/exec/obidos/redirect?tag=citeulike09-20\&amp;path=ASIN/0521826144",
  citeulike-linkout-1 = "http://www.amazon.de/exec/obidos/redirect?tag=citeulike01-21\&amp;path=ASIN/0521826144",
  citeulike-linkout-10 = "http://www.worldcat.org/oclc/51271691",
  citeulike-linkout-2 = "http://www.amazon.fr/exec/obidos/redirect?tag=citeulike06-21\&amp;path=ASIN/0521826144",
  citeulike-linkout-3 = "http://www.amazon.jp/exec/obidos/ASIN/0521826144",
  citeulike-linkout-4 = "http://www.amazon.co.uk/exec/obidos/ASIN/0521826144/citeulike00-21",
  citeulike-linkout-5 = "http://www.amazon.com/exec/obidos/redirect?tag=citeulike07-20\&path=ASIN/0521826144",
  citeulike-linkout-6 = "http://www.worldcat.org/isbn/0521826144",
  citeulike-linkout-7 = "http://books.google.com/books?vid=ISBN0521826144",
  citeulike-linkout-8 = "http://www.amazon.com/gp/search?keywords=0521826144\&index=books\&linkCode=qs",
  citeulike-linkout-9 = "http://www.librarything.com/isbn/0521826144",
  date-added =   "2007-09-11 03:11:57",
  day =          "05",
  howpublished = "Hardcover",
  keywords =     "haskell",
  priority =     "2",
  publisher =    "Cambridge University Press",
  title =        "Haskell 98 language and libraries : the revised
                 report",
  x-abstract =   "{Haskell is the world's leading lazy functional
                 programming language and is widely used in teaching,
                 research, and applications. The language continues to
                 develop rapidly, but in 1998 the programming community
                 decided to capture a stable snapshot of the language by
                 introducing Haskell 98. This book constitutes the
                 agreed definition of Haskell 98, the language itself as
                 well as its supporting libraries, and should be a
                 standard reference work for anyone involved in
                 research, teaching, or applications. All Haskell
                 compilers support Haskell 98, so professioanls and
                 educators have a stable base for their work.}",
  x-isbn =       "0521826144",
  x-month =      may,
  x-url =        "http://www.amazon.com/exec/obidos/redirect?tag=citeulike07-20\&path=ASIN/0521826144",
  year =         "2003",
}

@Book{Urban2005Nominal,
  author =       "Christian Urban and Christine Tasson",
  citeulike-article-id = "1211438",
  citeulike-linkout-0 = "http://dx.doi.org/10.1007/11532231\_4",
  date-added =   "2007-04-05 20:25:33",
  journal =      ": Automated Deduction – CADE-20",
  keywords =     "nominal",
  priority =     "0",
  title =        "Nominal Techniques in {Isabelle/HOL}",
  x-doi =        "10.1007/11532231\_4",
  x-url =        "http://dx.doi.org/10.1007/11532231\_4",
  xpages =       "38--53",
  year =         "2005",
}

@Article{Dybvig1988ExpansionPassing,
  author =       "R. Kent Dybvig and Daniel P. Friedman and Christopher
                 T. Haynes",
  citeulike-article-id = "4634",
  citeulike-linkout-0 = "http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.50.4332",
  date-added =   "2006-08-03 22:10:42",
  journal =      "Lisp and Symbolic Computation: An International
                 Journal",
  keywords =     "macros",
  number =       "1",
  priority =     "0",
  publisher =    "Kluwer Academic Publishers",
  title =        "{Expansion-Passing} Style: {A} General Macro
                 Mechanism",
  volume =       "1",
  x-abstract =   "The traditional Lisp macro expansion facility inhibits
                 several important forms of expansion control. These
                 include selective expansion of subexpressions,
                 expansion of subexpressions using modified expansion
                 functions, and expansion of application and variable
                 expressions. Furthermore, the expansion algorithm must
                 treat every special form as a separate case. The result
                 is limited expressive power and poor modularity. We
                 propose an alternative facility that avoids these
                 problems, using a...",
  x-url =        "http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.50.4332",
  xpages =       "53--76",
  year =         "1988",
}

@Book{Beck2002Test,
  author =       "Kent Beck",
  citeulike-article-id = "225134",
  citeulike-linkout-0 = "http://www.amazon.ca/exec/obidos/redirect?tag=citeulike09-20\&amp;path=ASIN/0321146530",
  citeulike-linkout-1 = "http://www.amazon.de/exec/obidos/redirect?tag=citeulike01-21\&amp;path=ASIN/0321146530",
  citeulike-linkout-2 = "http://www.amazon.fr/exec/obidos/redirect?tag=citeulike06-21\&amp;path=ASIN/0321146530",
  citeulike-linkout-3 = "http://www.amazon.jp/exec/obidos/ASIN/0321146530",
  citeulike-linkout-4 = "http://www.amazon.co.uk/exec/obidos/ASIN/0321146530/citeulike00-21",
  citeulike-linkout-5 = "http://www.amazon.com/exec/obidos/redirect?tag=citeulike07-20\&path=ASIN/0321146530",
  citeulike-linkout-6 = "http://www.worldcat.org/isbn/0321146530",
  citeulike-linkout-7 = "http://books.google.com/books?vid=ISBN0321146530",
  citeulike-linkout-8 = "http://www.amazon.com/gp/search?keywords=0321146530\&index=books\&linkCode=qs",
  citeulike-linkout-9 = "http://www.librarything.com/isbn/0321146530",
  date-added =   "2006-04-10 16:27:57",
  day =          "18",
  edition =      "1",
  howpublished = "Paperback",
  keywords =     "interlang, xp",
  priority =     "1",
  publisher =    "Addison-Wesley Professional",
  title =        "Test Driven Development: By Example",
  x-isbn =       "0321146530",
  x-month =      nov,
  x-url =        "http://www.amazon.com/exec/obidos/redirect?tag=citeulike07-20\&path=ASIN/0321146530",
  year =         "2002",
}

@Article{Dybvig1992Syntactic,
  author =       "R. Kent Dybvig and Robert Hieb and Carl Bruggeman",
  booktitle =    "LISP and Symbolic Computation",
  citeulike-article-id = "162160",
  citeulike-linkout-0 = "http://portal.acm.org/citation.cfm?id=173620",
  citeulike-linkout-1 = "http://dx.doi.org/10.1007/bf01806308",
  citeulike-linkout-2 = "http://link.springer.com/article/10.1007/BF01806308",
  date-added =   "2005-04-15 22:17:01",
  journal =      "Lisp Symb. Comput.",
  keywords =     "macros, scheme, syntax-case",
  number =       "4",
  priority =     "0",
  publisher =    "Kluwer Academic Publishers",
  title =        "Syntactic Abstraction in Scheme",
  volume =       "5",
  x-abstract =   "An abstract is not available.",
  x-address =    "Hingham, MA, USA",
  x-doi =        "10.1007/bf01806308",
  x-issn =       "0892-4635",
  x-month =      dec,
  x-url =        "http://dx.doi.org/10.1007/bf01806308",
  xpages =       "295--326",
  year =         "1992",
}

@Book{Vaughan2000GNU,
  author =       "Gary V. Vaughan",
  citeulike-article-id = "130549",
  citeulike-linkout-0 = "http://www.amazon.ca/exec/obidos/redirect?tag=citeulike09-20\&amp;path=ASIN/1578701902",
  citeulike-linkout-1 = "http://www.amazon.de/exec/obidos/redirect?tag=citeulike01-21\&amp;path=ASIN/1578701902",
  citeulike-linkout-2 = "http://www.amazon.fr/exec/obidos/redirect?tag=citeulike06-21\&amp;path=ASIN/1578701902",
  citeulike-linkout-3 = "http://www.amazon.co.uk/exec/obidos/ASIN/1578701902/citeulike00-21",
  citeulike-linkout-4 = "http://www.amazon.com/exec/obidos/redirect?tag=citeulike07-20\&path=ASIN/1578701902",
  citeulike-linkout-5 = "http://www.worldcat.org/isbn/1578701902",
  citeulike-linkout-6 = "http://books.google.com/books?vid=ISBN1578701902",
  citeulike-linkout-7 = "http://www.amazon.com/gp/search?keywords=1578701902\&index=books\&linkCode=qs",
  citeulike-linkout-8 = "http://www.librarything.com/isbn/1578701902",
  citeulike-linkout-9 = "http://www.worldcat.org/oclc/807257411",
  date-added =   "2005-03-17 03:20:37",
  day =          "06",
  howpublished = "Paperback",
  keywords =     "oopsla-paper",
  priority =     "2",
  publisher =    "New Riders",
  title =        "{GNU} Autoconf, Automake and Libtool",
  x-abstract =   {{The success of "open-source" software is dependent on
                 programmers around the world being able to develop
                 software that runs on many flavors of Unix and Linux.
                 The GNU <I>autoconf</I>, <I>automake</I>, and
                 <I>libtool</I> "autotools" are powerful tools that
                 simplify writing software on different platforms.
                 <I>GNU Autoconf, Automake, and Libtool</I> is a
                 technically adept and expert guide to using these
                 utilities effectively. Any C/C++ or script programmer
                 who writes software under Unix/Linux will want to have
                 a copy of this book to make better use of these
                 powerful and sometimes obscurely documented tools.<p>
                 This text is filled with the nuts-and-bolts details of
                 running these three utilities, including command-line
                 switches and the actual, generated files that automate
                 the build process and help programmers port code
                 between different environments. As such, this title
                 will be appreciated by those at their workstations who
                 want a hands-on guide to using the autotools.<p>
                 There's a danger of missing the forest for the trees
                 here, with all of this necessary detail, but the middle
                 sections of this book pull back a little with several
                 useful chapters on the bigger picture of code
                 "portability." Chapters on both C and C++ portability
                 explore language features that likely will cause
                 trouble when code is moved between different versions
                 of Unix (or even between Unix and Windows). A similar
                 section also discusses the issues when developing
                 portable shell scripts.<p> Readers will appreciate also
                 sections that are devoted to actual source code that's
                 built with the autotools. Starting out simply, the
                 authors also provide examples of more complex
                 source-code modules (including projects that make use
                 of dynamic loading and cross-platform builds). The
                 genius of the autotools utilities is certainly in the
                 details of command-line switches, and the expert tips
                 that are offered here. But it's good also to get a
                 perspective on why you use these tools, and what they
                 do for the working Unix developer.<p> By covering both
                 the nitty-gritty and the higher level issues of
                 "portability" in a broader sense, this title succeeds
                 as both a hands-on reference and as a guide to
                 understanding how to write more portable code
                 generally. It'll be a virtual must-have for any serious
                 Unix C/C++ programmer. Although it's not a book you
                 necessarily read from cover to cover, it's chock-full
                 of useful advice that can save considerable time for
                 anyone who writes software for Unix and Linux.
                 <I>--Richard Dragan</I><p> <B>Topics covered:</B>
                 <table cellspacing="7"
                 border="0"><ul><ol><tr><td><li>Introduction and history
                 of Unix and configuration tools <li>The
                 <I>configure</I> tool <li>Makefile and dependencies
                 <li>GNU autotools used for a simple program <li>Porting
                 options and <I>configure.in</I> <li>Bootstrapping
                 techniques <li>Comprehensive introduction to the GNU
                 <I>libtool</I> utility (building and linking options)
                 <li>Using <I>libtool</I> with <I>configure.in</I>
                 and<I>makefile.am</I> <li>A larger GNU autotools
                 project <li>Distributing files in tarballs
                 <li>Installing and uninstalling packages <li>Strategies
                 and tips for writing portable C code with the GNU
                 autotools (including data types, cross-Unix and
                 Unix/Windows portability issues) <li>Guide to C++
                 portability (includes issues with variable scoping,
                 exceptions, template, and the Standard Template
                 Library) <li>Dynamic loading and the GNU
                 <I>libltdll</I> tool <li>Advanced <I>automake</I> tips
                 <li>A complex GNU autotools example (including dynamic
                 linking) <li>Introduction to M4 (the underlying
                 language of the autotools) <li>Script portability
                 issues for the Bourne shell and its variants
                 <li>Cygnus's Cygwin and the GNU autotools
                 <li>Cross-compilation techniques <li>Reference for
                 installing the GNU autotools</ol></ul></table> }
                 {<HTML>If you are a developer and are looking to
                 participate in the Open Source development growth area
                 you will need to learn new Open Source tools. GNU
                 autoconf, GNU automake and GNU libtool are key tools
                 for Open Source application development. These tools
                 are not easy to learn, s
?? BibTeX string too long for field ``x-abstract''.
o some of the leading authorities on these tools have agreed to work together on this book to teach developers how to boost their productivity and the portability of their application.  This book place New Riders/MTP at the center of the Open Source development community.  Autoconf, Automake and Libtool is an efficient discourse on the use of autoconf, automake and libtool aimed at reducing the steep learning curve normally associated with these tools.  This is a study guide to the interactions between the tools, and how best to get them to cooperate.  If you are a developer and have no GNU build environment expertise, this book will help you develop these tools completely and confidently.</HTML>}},
    x-isbn = {1578701902},
    x-month = oct,
    x-url = {http://www.amazon.com/exec/obidos/redirect?tag=citeulike07-20\&path=ASIN/1578701902},
    year = {2000}
}

@InProceedings{macqueen84,
  author =       "David B. Macqueen",
  booktitle =    "Proceedings of the 1984 ACM Conference on LISP and
                 Functional Programming",
  citeulike-article-id = "126967",
  citeulike-linkout-0 = "http://citeseer.ist.psu.edu/macqueen84modules.html",
  citeulike-linkout-1 = "http://citeseer.lcs.mit.edu/macqueen84modules.html",
  citeulike-linkout-2 = "http://citeseer.ifi.unizh.ch/macqueen84modules.html",
  citeulike-linkout-3 = "http://citeseer.comp.nus.edu.sg/macqueen84modules.html",
  date-added =   "2005-03-14 23:30:07",
  keywords =     "ml, oopsla-paper",
  priority =     "2",
  publisher =    "ACM Press",
  title =        "Modules for Standard {ML}",
  x-abstract =   "The functional programming language {ML} has been
                 undergoing a thorough redesign during the past year,
                 and the module facility described here has been
                 proposed as part of the revised language, now called
                 Standard {ML}. The design has three main goals: (1) to
                 facilitate the structuring of large {ML} programs; (2)
                 to support separate compilation and generic library
                 units; and (3) to employ new ideas in the semantics of
                 data types to extend the power of {ML}'s polymorphic
                 type system. It is based on...",
  x-address =    "New York",
  x-url =        "http://citeseer.ist.psu.edu/macqueen84modules.html",
  xpages =       "198--207",
  year =         "1984",
}

@Proceedings{Gabbay1999New,
  author =       "Murdoch Gabbay and Andrew Pitts",
  booktitle =    "Proceedings of the 14th Annual Symposium on Logic in
                 Computer Science (LICS'99)",
  citeulike-article-id = "3208",
  citeulike-linkout-0 = "http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.38.9383",
  date-added =   "2005-03-10 23:02:33",
  keywords =     "alpha",
  priority =     "5",
  publisher =    "IEEE Computer Society Press",
  title =        "A New Approach to Abstract Syntax Involving Binders",
  x-abstract =   "Syntax Involving Binders Murdoch Gabbay Cambridge
                 University {DPMMS} Cambridge {CB2} {1SB}, {UK}
                 {M.J}.Gabbay@cantab.com Andrew Pitts Cambridge
                 University Computer Laboratory Cambridge {CB2} {3QG},
                 {UK} ap@cl.cam.ac.uk Abstract The {Fraenkel-Mostowski}
                 permutation model of set theory with atoms ({FM}-sets)
                 can serve as the semantic basis of meta-logics for
                 specifying and reasoning about formal systems involving
                 name binding, ff-conversion, capture avoiding
                 substitution, and so on. We show that in...",
  x-address =    "Trento, Italy",
  x-editor =     "Longo, G.",
  x-url =        "http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.38.9383",
  xpages =       "214--224",
  year =         "1999",
}

@Proceedings{Armstrong1999Toward,
  author =       "R. Armstrong and D. Gannon and A. Geist and K. Keahey
                 and S. Kohn and L. Mcinnes and S. Parker and B.
                 Smolinski",
  citeulike-article-id = "113635",
  citeulike-linkout-0 = "http://dx.doi.org/10.1109/hpdc.1999.805289",
  citeulike-linkout-1 = "http://ieeexplore.ieee.org/xpls/abs\_all.jsp?arnumber=805289",
  date-added =   "2005-03-03 20:50:24",
  journal =      "High Performance Distributed Computing, 1999.
                 Proceedings. The Eighth International Symposium on",
  keywords =     "components, hpc, oopsla-paper",
  priority =     "2",
  title =        "Toward a common component architecture for
                 high-performance scientific computing",
  x-abstract =   "Describes work in progress to develop a standard for
                 interoperability among high-performance scientific
                 components. This research stems from the growing
                 recognition that the scientific community needs to
                 better manage the complexity of multidisciplinary
                 simulations and better address scalable performance
                 issues on parallel and distributed architectures. The
                 driving force for this is the need for fast connections
                 among components that perform numerically intensive
                 work and for parallel collective interactions among
                 components that use multiple processes or threads. This
                 paper focuses on the areas we believe are most crucial
                 in this context, namely an interface definition
                 language that supports scientific abstractions for
                 specifying component interfaces and a port connection
                 model for specifying component interactions",
  x-doi =        "10.1109/hpdc.1999.805289",
  x-url =        "http://dx.doi.org/10.1109/hpdc.1999.805289",
  xpages =       "115--124",
  year =         "1999",
}

@Article{feldman79,
  author =       "Stuart I. Feldman",
  citeulike-article-id = "113479",
  citeulike-linkout-0 = "http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.39.7058",
  date-added =   "2005-03-03 20:10:42",
  journal =      "Software - Practice and Experience",
  keywords =     "configuration-management, oopsla-paper",
  number =       "4",
  priority =     "2",
  title =        "{Make-A} Program for Maintaining Computer Programs",
  volume =       "9",
  x-abstract =   "In a programming project, it is easy to lose track of
                 which files need to be reprocessed or recompiled after
                 a change is made in some part of the source. Make
                 provides a simple mechanism for maintaining up-to-date
                 versions of programs that result from many operations
                 on a number of files. It is possible to tell Make the
                 sequence of commands that create certain files, and the
                 list of files that require other files to be current
                 before the operations can be done. Whenever a change is
                 made in any...",
  x-url =        "http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.39.7058",
  xpages =       "255--65",
  year =         "1979",
}

@TechReport{vesta02,
  author =       "Allan Heydon and Roy Levin and Timothy Mann and Yuan
                 Yu",
  citeulike-article-id = "113384",
  citeulike-linkout-0 = "http://gatekeeper.research.compaq.com/pub/DEC/SRC/research-reports/abstracts/src-rr-177.html",
  date-added =   "2005-03-03 18:42:57",
  day =          "22",
  institution =  "Compaq Systems Research Center",
  keywords =     "configuration-management, oopsla-paper",
  priority =     "2",
  title =        "The Vesta Software Configuration Management System",
  x-month =      jan,
  x-url =        "http://gatekeeper.research.compaq.com/pub/DEC/SRC/research-reports/abstracts/src-rr-177.html",
  year =         "2002",
}

@Electronic{planet-website,
  author =       "Jacob Matthews and Robby Findler",
  citeulike-article-id = "113356",
  citeulike-linkout-0 = "http://planet.plt-scheme.org/",
  comment =      "Ask Jacob how to cite PLaneT.",
  date-added =   "2005-03-03 18:37:35",
  keywords =     "oopsla-paper, plt, scheme",
  priority =     "0",
  title =        "{PLaneT}",
  x-url =        "http://planet.plt-scheme.org/",
}

@Book{java98,
  author =       "Ken Arnold and James Gosling",
  citeulike-article-id = "113355",
  citeulike-linkout-0 = "http://portal.acm.org/citation.cfm?id=291374",
  date-added =   "2005-03-03 18:36:03",
  keywords =     "java, oopsla-paper",
  priority =     "2",
  publisher =    "ACM Press/Addison-Wesley Publishing Co.",
  title =        "The Java programming language (2nd ed.)",
  x-isbn =       "0201310066",
  x-url =        "http://portal.acm.org/citation.cfm?id=291374",
  year =         "1998",
}

@Proceedings{moby99,
  author =       "Kathleen Fisher and John Reppy",
  booktitle =    "PLDI '99: Proceedings of the ACM SIGPLAN 1999
                 conference on Programming language design and
                 implementation",
  citeulike-article-id = "113354",
  citeulike-linkout-0 = "http://portal.acm.org/citation.cfm?id=301638",
  citeulike-linkout-1 = "http://dx.doi.org/10.1145/301618.301638",
  date-added =   "2005-03-03 18:35:23",
  keywords =     "ml, oopsla-paper",
  number =       "5",
  priority =     "2",
  publisher =    "ACM Press",
  title =        "The design of a class mechanism for Moby",
  volume =       "34",
  x-doi =        "10.1145/301618.301638",
  x-issn =       "0362-1340",
  x-month =      may,
  x-url =        "http://dx.doi.org/10.1145/301618.301638",
  xpages =       "37--49",
  year =         "1999",
}

@Article{r5rs,
  author =       "Richard Kelsey and William Clinger and (editors),
                 Jonathan R.",
  citeulike-article-id = "4855",
  citeulike-linkout-0 = "http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.41.4808",
  date-added =   "2005-03-03 18:33:23",
  journal =      "ACM SIGPLAN Notices",
  keywords =     "oopsla-paper, scheme",
  number =       "9",
  priority =     "0",
  title =        "Revised\$^5\$ Report on the Algorithmic Language
                 Scheme",
  volume =       "33",
  x-abstract =   "Programming languages should be designed not by piling
                 feature on top of feature, but by removing the
                 weaknesses and restrictions that make additional
                 features appear necessary. Scheme demonstrates that a
                 very small number of rules for forming expressions,
                 with no restrictions on how they are composed, suffice
                 to form a practical and efficient programming language
                 that is flexible enough to support most of the major
                 programming paradigms in use today.",
  x-url =        "http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.41.4808",
  xpages =       "26--76",
  year =         "1998",
}

@Book{JLS,
  author =       "James Gosling and Bill Joy and Guy Steele and Gilad
                 Bracha",
  citeulike-article-id = "113341",
  citeulike-linkout-0 = "http://www.amazon.ca/exec/obidos/redirect?tag=citeulike09-20\&amp;path=ASIN/0321246780",
  citeulike-linkout-1 = "http://www.amazon.de/exec/obidos/redirect?tag=citeulike01-21\&amp;path=ASIN/0321246780",
  citeulike-linkout-2 = "http://www.amazon.fr/exec/obidos/redirect?tag=citeulike06-21\&amp;path=ASIN/0321246780",
  citeulike-linkout-3 = "http://www.amazon.jp/exec/obidos/ASIN/0321246780",
  citeulike-linkout-4 = "http://www.amazon.co.uk/exec/obidos/ASIN/0321246780/citeulike00-21",
  citeulike-linkout-5 = "http://www.amazon.com/exec/obidos/redirect?tag=citeulike07-20\&path=ASIN/0321246780",
  citeulike-linkout-6 = "http://www.worldcat.org/isbn/0321246780",
  citeulike-linkout-7 = "http://books.google.com/books?vid=ISBN0321246780",
  citeulike-linkout-8 = "http://www.amazon.com/gp/search?keywords=0321246780\&index=books\&linkCode=qs",
  citeulike-linkout-9 = "http://www.librarything.com/isbn/0321246780",
  date-added =   "2005-03-03 18:28:44",
  day =          "24",
  edition =      "3",
  howpublished = "Paperback",
  keywords =     "java, oopsla-paper",
  priority =     "2",
  publisher =    "Addison-Wesley Professional",
  title =        "The Java¿ Language Specification (3rd Edition)",
  x-isbn =       "0321246780",
  x-month =      jul,
  x-url =        "http://www.amazon.com/exec/obidos/redirect?tag=citeulike07-20\&path=ASIN/0321246780",
  year =         "2005",
}

@Electronic{debian,
  citeulike-article-id = "113340",
  citeulike-linkout-0 = "http://www.debian.org/",
  date-added =   "2005-03-03 18:24:56",
  howpublished = "Available at http://www.debian.org",
  keywords =     "components, oopsla-paper",
  priority =     "2",
  title =        "Debian",
  x-url =        "http://www.debian.org/",
}

@Book{SML97,
  author =       "Robin Milner and Mads Tofte and Robert Harper and
                 David Macqueen",
  citeulike-article-id = "113339",
  citeulike-linkout-0 = "http://www.amazon.ca/exec/obidos/redirect?tag=citeulike09-20\&amp;path=ASIN/0262631814",
  citeulike-linkout-1 = "http://www.amazon.de/exec/obidos/redirect?tag=citeulike01-21\&amp;path=ASIN/0262631814",
  citeulike-linkout-2 = "http://www.amazon.fr/exec/obidos/redirect?tag=citeulike06-21\&amp;path=ASIN/0262631814",
  citeulike-linkout-3 = "http://www.amazon.jp/exec/obidos/ASIN/0262631814",
  citeulike-linkout-4 = "http://www.amazon.co.uk/exec/obidos/ASIN/0262631814/citeulike00-21",
  citeulike-linkout-5 = "http://www.amazon.com/exec/obidos/redirect?tag=citeulike07-20\&path=ASIN/0262631814",
  citeulike-linkout-6 = "http://www.worldcat.org/isbn/0262631814",
  citeulike-linkout-7 = "http://books.google.com/books?vid=ISBN0262631814",
  citeulike-linkout-8 = "http://www.amazon.com/gp/search?keywords=0262631814\&index=books\&linkCode=qs",
  citeulike-linkout-9 = "http://www.librarything.com/isbn/0262631814",
  date-added =   "2005-03-03 18:23:07",
  day =          "15",
  edition =      "Rev Sub",
  howpublished = "Paperback",
  keywords =     "components, oopsla-paper",
  priority =     "2",
  publisher =    "The MIT Press",
  title =        "The Definition of Standard {ML} - Revised",
  x-abstract =   "Standard {ML} is a general-purpose programming
                 language designed for large projects. This book
                 provides a formal definition of Standard {ML} for the
                 benefit of all concerned with the language, including
                 users and implementers. Because computer programs are
                 increasingly required to withstand rigorous analysis,
                 it is all the more important that the language in which
                 they are written be defined with full rigor.<br /> <br
                 /> One purpose of a language definition is to establish
                 a theory of meanings upon which the understanding of
                 particular programs may rest. To properly define a
                 programming language, it is necessary to use some form
                 of notation other than a programming language. Given a
                 concern for rigor, mathematical notation is an obvious
                 choice. The authors have defined their semantic objects
                 in mathematical notation that is completely independent
                 of Standard {ML}.<br /> <br /> In defining a language
                 one must also define the rules of evaluation
                 precisely--that is, define what meaning results from
                 evaluating any phrase of the language. The definition
                 thus constitutes a formal specification for an
                 implementation. The authors have developed enough of
                 their theory to give sense to their rules of
                 evaluation.<br /> <br /> <{I>The} Definition of
                 Standard {ML}</I> is the essential point of reference
                 for Standard {ML}. Since its publication in 1990, the
                 implementation technology of the language has advanced
                 enormously and the number of users has grown. The
                 revised edition includes a number of new features,
                 omits little-used features, and corrects mistakes of
                 definition.",
  x-isbn =       "0262631814",
  x-month =      may,
  x-url =        "http://www.amazon.com/exec/obidos/redirect?tag=citeulike07-20\&path=ASIN/0262631814",
  year =         "1997",
}

@Electronic{CORBA,
  citeulike-article-id = "113313",
  citeulike-linkout-0 = "http://www.corba.org/",
  date-added =   "2005-03-03 18:06:38",
  keywords =     "components, oopsla-paper",
  priority =     "2",
  title =        "{CORBA}",
  x-url =        "http://www.corba.org/",
}

@Book{FosterJohnson2003Red,
  author =       "Eric Foster-Johnson",
  citeulike-article-id = "113312",
  citeulike-linkout-0 = "http://www.amazon.ca/exec/obidos/redirect?tag=citeulike09-20\&amp;path=ASIN/0764549650",
  citeulike-linkout-1 = "http://www.amazon.de/exec/obidos/redirect?tag=citeulike01-21\&amp;path=ASIN/0764549650",
  citeulike-linkout-2 = "http://www.amazon.fr/exec/obidos/redirect?tag=citeulike06-21\&amp;path=ASIN/0764549650",
  citeulike-linkout-3 = "http://www.amazon.co.uk/exec/obidos/ASIN/0764549650/citeulike00-21",
  citeulike-linkout-4 = "http://www.amazon.com/exec/obidos/redirect?tag=citeulike07-20\&path=ASIN/0764549650",
  citeulike-linkout-5 = "http://www.worldcat.org/isbn/0764549650",
  citeulike-linkout-6 = "http://books.google.com/books?vid=ISBN0764549650",
  citeulike-linkout-7 = "http://www.amazon.com/gp/search?keywords=0764549650\&index=books\&linkCode=qs",
  citeulike-linkout-8 = "http://www.librarything.com/isbn/0764549650",
  comment =      "A book on RPM, the redhat package manager.",
  date-added =   "2005-03-03 18:04:17",
  day =          "01",
  howpublished = "Paperback",
  keywords =     "components, oopsla-paper, rpm",
  priority =     "2",
  publisher =    "{Red Hat}",
  title =        "Red Hat {RPM} Guide",
  x-abstract =   "{<UL><LI>RPM is the Linux industry standard for making
                 application installation easy and its use is gaining
                 mindshare amongst users and administrators of other
                 Unix platforms <LI>Offers insight and examples to
                 creating applications that rely upon or enhance RPM,
                 enabling users to package and deploy software in RPM
                 format <LI>Discusses the use of RPM to manage software
                 and examines the tools provided for user control
                 <LI>Book will be technically reviewed by the key RPM
                 programmer at Red Hat</UL>RED HAT PRESS(TM)<br> Linux
                 Solutions from the Experts at Red Hat<br> Red Hat-the
                 world's leading Linux company-presents a series of
                 unrivaled guides that are reviewed and approved by the
                 experts at Red Hat. Each book is packed with invaluable
                 tips and techniques that are ideal for everyone from
                 beginning to advanced network and systems
                 professionals, as well as home and small businesses.}",
  x-isbn =       "0764549650",
  x-month =      mar,
  x-url =        "http://www.amazon.com/exec/obidos/redirect?tag=citeulike07-20\&path=ASIN/0764549650",
  year =         "2003",
}

@Book{Szyperski1997Component,
  author =       "Clemens Szyperski",
  citeulike-article-id = "113266",
  citeulike-linkout-0 = "http://www.amazon.ca/exec/obidos/redirect?tag=citeulike09-20\&amp;path=ASIN/0201178885",
  citeulike-linkout-1 = "http://www.amazon.de/exec/obidos/redirect?tag=citeulike01-21\&amp;path=ASIN/0201178885",
  citeulike-linkout-2 = "http://www.amazon.fr/exec/obidos/redirect?tag=citeulike06-21\&amp;path=ASIN/0201178885",
  citeulike-linkout-3 = "http://www.amazon.jp/exec/obidos/ASIN/0201178885",
  citeulike-linkout-4 = "http://www.amazon.co.uk/exec/obidos/ASIN/0201178885/citeulike00-21",
  citeulike-linkout-5 = "http://www.amazon.com/exec/obidos/redirect?tag=citeulike07-20\&path=ASIN/0201178885",
  citeulike-linkout-6 = "http://www.worldcat.org/isbn/0201178885",
  citeulike-linkout-7 = "http://books.google.com/books?vid=ISBN0201178885",
  citeulike-linkout-8 = "http://www.amazon.com/gp/search?keywords=0201178885\&index=books\&linkCode=qs",
  citeulike-linkout-9 = "http://www.librarything.com/isbn/0201178885",
  date-added =   "2005-03-03 17:00:11",
  day =          "19",
  howpublished = "Hardcover",
  keywords =     "components, oopsla-paper",
  priority =     "0",
  publisher =    "Addison-Wesley Pub (Sd)",
  title =        "Component Software: Beyond {Object-Oriented}
                 Programming (Acm Press)",
  x-isbn =       "0201178885",
  x-month =      dec,
  x-url =        "http://www.amazon.com/exec/obidos/redirect?tag=citeulike07-20\&path=ASIN/0201178885",
  year =         "1997",
}

@InProceedings{cardelli:multiple,
  author =       "Luca Cardelli",
  booktitle =    "Proc. of the international symposium on Semantics of
                 data types",
  citeulike-article-id = "104351",
  date-added =   "2005-02-26 03:29:52",
  priority =     "0",
  publisher =    "Springer-Verlag New York, Inc.",
  title =        "A semantics of multiple inheritance.",
  xpages =       "51--67",
  year =         "1984",
}

@PhdThesis{cook:thesis,
  author =       "William R. Cook",
  citeulike-article-id = "104350",
  date-added =   "2005-02-26 03:29:52",
  priority =     "0",
  school =       "Brown University",
  title =        "A Denotational Semantics of Inheritance",
  x-month =      may,
  year =         "1989",
}

@InProceedings{objvlisp,
  author =       "Pierre Cointe",
  booktitle =    "Proceedings of the \mbox{OOPSLA}\~{}'87 Conference on
                 Object-Oriented Programming Systems, Languages and
                 Applications",
  citeulike-article-id = "104349",
  date-added =   "2005-02-26 03:29:52",
  priority =     "0",
  publisher =    "ACM Press",
  title =        "Metaclasses are First Class: the {ObjVLisp} Model",
  xpages =       "156--162",
  year =         "1987",
}

@InProceedings{graver:90,
  author =       "Justin O. Graver and Ralph E. Johnson",
  booktitle =    "Conference Record of the Seventeenth Annual ACM
                 Symposium on Principles of Programming Languages",
  citeulike-article-id = "104348",
  date-added =   "2005-02-26 03:29:52",
  priority =     "0",
  title =        "A Type System for {Smalltalk}",
  x-address =    "San Francisco, California",
  x-month =      jan,
  xpages =       "136--150",
  year =         "1990",
}

@TechReport{SyntaxCase,
  author =       "R. Kent Dybvig",
  citeulike-article-id = "104347",
  date-added =   "2005-02-26 03:29:52",
  institution =  "Indiana University Computer Science Dept.",
  priority =     "0",
  title =        "{Writing Hygienic Macros in Scheme with Syntax-Case}",
  x-month =      jul,
  year =         "1992",
}

@Book{steele-90,
  author =       "G. L. {.} Guy",
  citeulike-article-id = "104346",
  date-added =   "2005-02-26 03:29:52",
  priority =     "0",
  publisher =    "Digital Press",
  title =        "{Common Lisp: The Language, Second Edition}",
  x-address =    "Bedford, Massachusetts",
  year =         "1990",
}

@InProceedings{FellExpress,
  author =       "Matthias Felleisen",
  booktitle =    "{ESOP}'90, 3rd European Symposium on Programming",
  citeulike-article-id = "104345",
  date-added =   "2005-02-26 03:29:52",
  priority =     "0",
  publisher =    "Springer",
  title =        "On the Expressive Power of Programming Languages",
  volume =       "432",
  x-address =    "Copenhagen, Denmark",
  x-editor =     "Jones, Neil D.",
  x-month =      may,
  x-series =     "Lecture Notes in Computer Science",
  xpages =       "134--151",
  year =         "1990",
}

@InProceedings{Starkiller,
  author =       "Michael Salib",
  booktitle =    "PyCon DC",
  citeulike-article-id = "104344",
  date-added =   "2005-02-26 03:29:52",
  priority =     "0",
  title =        "{Static Type Inference} With {Starkiller}",
  year =         "2004",
}

@Unpublished{PythonMeta,
  author =       "Guido v. van Rossum",
  citeulike-article-id = "104343",
  date-added =   "2005-02-26 03:29:52",
  priority =     "0",
  title =        "Unifying types and classes in {Python} 2.2",
  year =         "2002",
}

@InProceedings{FJ,
  author =       "Atshushi Igarashi and Benjamin Pierce and Philip
                 Wadler",
  booktitle =    "Proceedings of the 1999 ACM SIGPLAN Conference on
                 Object-Oriented Programming, Systems, Languages, and
                 Applications",
  citeulike-article-id = "104342",
  date-added =   "2005-02-26 03:29:52",
  priority =     "0",
  publisher =    "ACM Press",
  title =        "Featherweight {Java}: {A} minimal core calculus for
                 {Java and GJ}",
  x-doi =        "10.1145/320384.320395",
  xpages =       "132--146",
  year =         "1999",
}

@Book{ArtMOP,
  author =       "Gregor Kiczales and Jim d. Rivi\`{e}res and Daniel G.
                 Bobrow",
  citeulike-article-id = "104341",
  date-added =   "2005-02-26 03:29:52",
  priority =     "0",
  publisher =    "MIT Press",
  title =        "The Art of the Metaobject Protocol",
  x-address =    "Cambridge, MA",
  year =         "1991",
}

@InProceedings{NextGen,
  author =       "Robert Cartwright and J. Guy",
  booktitle =    "Proceedings of the 1998 ACM SIGPLAN Conference on
                 Object-Oriented Programming, Systems, Languages, and
                 Applications",
  citeulike-article-id = "104340",
  date-added =   "2005-02-26 03:29:52",
  priority =     "0",
  publisher =    "ACM Press",
  title =        "Compatible genericity with run-time types for the
                 {Java Programming Language}",
  x-doi =        "10.1145/286936.286958",
  xpages =       "201--215",
  year =         "1998",
}

@InProceedings{DimUnits,
  author =       "Eric Allen and David Chase and Victor Luchangco and
                 Jan W. Maessen and Guy Steele",
  booktitle =    "Proceedings of the 2004 ACM SIGPLAN Conference on
                 Object-oriented Programing, Systems, Languages, and
                 Applications",
  citeulike-article-id = "104339",
  date-added =   "2005-02-26 03:29:52",
  priority =     "0",
  title =        "{Object-Oriented Units of Measurement}",
  year =         "2004",
}

@InProceedings{Self,
  author =       "David Ungar and Randall B. Smith",
  booktitle =    "Conference proceedings on Object-oriented Programming
                 Systems, Languages and Applications",
  citeulike-article-id = "104338",
  date-added =   "2005-02-26 03:29:52",
  priority =     "0",
  publisher =    "ACM Press",
  title =        "Self: The power of simplicity",
  x-doi =        "10.1145/38765.38828",
  xpages =       "227--242",
  year =         "1987",
}

@InProceedings{MixGen,
  author =       "Eric Allen and Jonathan Bannet and Robert Cartwright",
  booktitle =    "Proceedings of the 2003 ACM SIGPLAN conference on
                 Object-Oriented Programming, Systems, Languages, and
                 Applications",
  citeulike-article-id = "104337",
  date-added =   "2005-02-26 03:29:52",
  priority =     "0",
  publisher =    "ACM Press",
  title =        "A first-class approach to genericity",
  x-doi =        "10.1145/949305.949316",
  xpages =       "96--114",
  year =         "2003",
}

@Book{Smalltalk80,
  author =       "Adele Goldberg and David Robson",
  citeulike-article-id = "104336",
  date-added =   "2005-02-26 03:29:52",
  priority =     "0",
  publisher =    "Addison-Wesley, Reading, Massachusetts",
  title =        "Smalltalk-80: The Language and Its Implementation",
  year =         "1989",
}

@TechReport{FW96,
  author =       "Christopher A. Welty and David A. Ferrucci",
  citeulike-article-id = "104335",
  citeulike-linkout-0 = "http://citeseer.ist.psu.edu/92825.html;
                 http://www.cs.vassar.edu/faculty/welty/papers/instances/instances.ps",
  date-added =   "2005-02-26 03:29:52",
  institution =  "Rochester Polytechnic Institute Computer Science
                 Dept.",
  priority =     "0",
  title =        "What's in an Instance?",
  x-abstract =   "The abstraction relationship between a generic and
                 individual exists when a class is abstracted into an
                 individual in order that it may have properties
                 [Brachman83]. Looking back to Figure 7, we had a case
                 where eagle was split into two parts so that it could
                 have properties such as endangered. One of the problems
                 that arose from this approach was the relationship
                 between the two objects eagle and the eagle. The
                 abstraction relationship was described merely to point
                 out that, in a system where only instances can have
                 properties, if classes were to have properties they
                 would have to be {repreFIGURE} 9. An object that spans
                 universes. cfg program-01 U g U p instance instance
                 pascal What's in an Instance? 7 of 9 sented as
                 instances as well as classes. When represented in this
                 manner, there would have to be some relationship to
                 denote the fact that the two objects should be
                 interpreted as different views of the same object.
                 Figure 10 shows the use of the abstraction ...",
  x-url =        "http://citeseer.ist.psu.edu/92825.html;
                 http://www.cs.vassar.edu/faculty/welty/papers/instances/instances.ps",
  year =         "1994",
}

@Book{GOF,
  author =       "Erich Gamma and Richard Helm and Ralph Johnson and
                 John Vlissides",
  citeulike-article-id = "104334",
  date-added =   "2005-02-26 03:29:52",
  priority =     "0",
  publisher =    "Addison Wesley",
  title =        "Design Patterns: Elements of Reusable
                 {Object-Oriented} Software",
  x-address =    "Reading, Massachusetts",
  year =         "1994",
}

@Unpublished{scala,
  author =       "Martin Odersky and Others",
  citeulike-article-id = "104333",
  date-added =   "2005-02-26 03:29:52",
  priority =     "0",
  title =        "{The Scala Language Specification}",
  year =         "2004",
}

@InProceedings{Strongtalk,
  author =       "Gilad Bracha and David Griswold",
  booktitle =    "Proceedings of the \mbox{OOPSLA}\~{}'93 Conference on
                 Object-Oriented Programming Systems, Languages and
                 Applications",
  citeulike-article-id = "104332",
  date-added =   "2005-02-26 03:29:52",
  priority =     "0",
  title =        "{Strongtalk: Typechecking Smalltalk in a Production
                 Environment}",
  x-month =      sep,
  xpages =       "215--230",
  year =         "1993",
}

@Article{felleisen86secd,
  author =       "Matthias Felleisen and Daniel P. Friedman",
  booktitle =    "Formal Description of Programming Language Concepts
                 III",
  citeulike-article-id = "104331",
  date-added =   "2005-02-26 03:28:54",
  keywords =     "continuations",
  priority =     "0",
  publisher =    "North-Holland Pub. Co.",
  title =        "Control operators, the {SECD}-machine and the
                 \$\lambda\$-calculus",
  xpages =       "193--217",
}

@InProceedings{luc94partial,
  author =       "Luc Moreau and Christian Queinnec",
  booktitle =    "{PLILP}",
  citeulike-article-id = "104330",
  citeulike-linkout-0 = "\#",
  date-added =   "2005-02-26 03:28:54",
  keywords =     "continuations",
  priority =     "0",
  publisher =    "Springer-Verlag, LNCS 844",
  title =        "{P}artial {C}ontinuations as the {D}ifference of
                 {C}ontinuations: {A} {D}uumvi",
  x-editor =     "Hermenegildo, Manuel and Penjam, Jaan",
  x-month =      sep,
  x-url =        "citeseer.ist.psu.edu/moreau94partial.html",
  xpages =       "182--197",
  year =         "1994",
}

@Article{queinnec93library,
  author =       "Christian Queinnec",
  citeulike-article-id = "104329",
  citeulike-linkout-0 = "\#",
  date-added =   "2005-02-26 03:28:54",
  keywords =     "continuations",
  number =       "4",
  priority =     "0",
  title =        "A Library of high-level control operators",
  volume =       "6",
  x-url =        "citeseer.ist.psu.edu/queinnec93library.html",
  xpages =       "11--26",
  year =         "1993",
}

@InProceedings{monads,
  author =       "Andrzej Filinski",
  booktitle =    "Proceedings of the 21st ACM SIGPLAN-SIGACT symposium
                 on Principles of programming languages",
  citeulike-article-id = "104328",
  date-added =   "2005-02-26 03:28:54",
  keywords =     "continuations",
  priority =     "0",
  publisher =    "ACM Press",
  title =        "Representing monads",
  x-doi =        "10.1145/174675.178047",
  xpages =       "446--457",
  year =         "1994",
}

@InProceedings{581504,
  author =       "Martin Gasbichler and Michael Sperber",
  booktitle =    "Proceedings of the seventh ACM SIGPLAN international
                 conference on Functional programming",
  citeulike-article-id = "104327",
  date-added =   "2005-02-26 03:28:54",
  keywords =     "continuations",
  priority =     "0",
  publisher =    "ACM Press",
  title =        "Final shift for {\tt call/cc}: direct implementation
                 of {\tt shift} and {\tt reset}",
  x-doi =        "10.1145/581478.581504",
  xpages =       "271--282",
  year =         "2002",
}

@InProceedings{mf-prompts,
  author =       "M. Felleisen",
  booktitle =    "Proceedings of the 15th ACM SIGPLAN-SIGACT symposium
                 on Principles of programming languages",
  citeulike-article-id = "104326",
  date-added =   "2005-02-26 03:28:54",
  keywords =     "continuations",
  priority =     "0",
  publisher =    "ACM Press",
  title =        "The theory and practice of first-class prompts",
  x-doi =        "10.1145/73560.73576",
  xpages =       "180--190",
  year =         "1988",
}

@InProceedings{62686,
  author =       "Matthias Felleisen",
  booktitle =    "Proceedings of the 1988 ACM conference on LISP and
                 functional programming",
  citeulike-article-id = "104325",
  date-added =   "2005-02-26 03:28:54",
  keywords =     "continuations",
  priority =     "0",
  publisher =    "ACM Press",
  title =        "\$\lambda\$-v-{CS}: an extended \$\lambda\$-calculus
                 for scheme",
  x-doi =        "10.1145/62678.62686",
  xpages =       "72--85",
  year =         "1988",
}

@Article{gdp:cbn-cbv,
  author =       "Gordon D. Plotkin",
  citeulike-article-id = "104324",
  date-added =   "2005-02-26 03:28:54",
  journal =      "Theoretical Computer Science",
  keywords =     "continuations",
  priority =     "0",
  title =        "Call-by-name, call-by-value, and the
                 \$\lambda\$-calculus",
  xpages =       "125--159",
  year =         "1975",
}

@Article{felleisen87syntactic,
  author =       "M. Felleisen and D. P. Friedman and E. Kohlbecker and
                 B. Duba",
  citeulike-article-id = "104323",
  date-added =   "2005-02-26 03:28:54",
  journal =      "Theor. Comput. Sci.",
  keywords =     "continuations",
  number =       "3",
  priority =     "0",
  publisher =    "Elsevier Science Publishers Ltd.",
  title =        "A syntactic theory of sequential control",
  volume =       "52",
  x-doi =        "10.1016/0304-3975(87)90109-5",
  xpages =       "205--237",
  year =         "1987",
}

@PhdThesis{sitaram94thesis,
  author =       "Dorai Sitaram",
  citeulike-article-id = "104322",
  date-added =   "2005-02-26 03:28:54",
  keywords =     "continuations",
  priority =     "0",
  school =       "Rice University",
  title =        "Control Operators and their impact on programming
                 language design",
  year =         "1994",
}

@InProceedings{hieb90continuations,
  author =       "R. Hieb and R. Kent Dybvig",
  booktitle =    "Proceedings of the second ACM SIGPLAN symposium on
                 Principles \& practice of parallel programming",
  citeulike-article-id = "104321",
  date-added =   "2005-02-26 03:28:54",
  keywords =     "continuations",
  priority =     "0",
  publisher =    "ACM Press",
  title =        "Continuations and concurrency",
  x-doi =        "10.1145/99163.99178",
  xpages =       "128--136",
  year =         "1990",
}

@InProceedings{queinnec91dynamic,
  author =       "Christian Queinnec and Bernard Serpette",
  booktitle =    "Conference Record of the Eighteenth Annual {ACM}
                 Symposium on Principles of Programming Languages",
  citeulike-article-id = "104320",
  citeulike-linkout-0 = "\#",
  date-added =   "2005-02-26 03:28:54",
  keywords =     "continuations",
  priority =     "0",
  title =        "A Dynamic Extent Control Operator for Partial
                 Continuations",
  x-address =    "Orlando, Florida",
  x-url =        "citeseer.ist.psu.edu/queinnec91dynamic.html",
  xpages =       "174--184",
  year =         "1991",
}

@Article{sitaram90control,
  author =       "Dorai Sitaram and Matthias Felleisen",
  citeulike-article-id = "104319",
  date-added =   "2005-02-26 03:28:54",
  journal =      "Lisp Symb. Comput.",
  keywords =     "continuations",
  number =       "1",
  priority =     "0",
  publisher =    "Kluwer Academic Publishers",
  title =        "Control delimiters and their hierarchies",
  volume =       "3",
  xpages =       "67--99",
  year =         "1990",
}

@InProceedings{sitaram93handling,
  author =       "Dorai Sitaram",
  booktitle =    "{SIGPLAN} Conference on Programming Language Design
                 and Implementation",
  citeulike-article-id = "104318",
  citeulike-linkout-0 = "\#",
  date-added =   "2005-02-26 03:28:54",
  keywords =     "continuations",
  priority =     "0",
  title =        "Handling Control",
  x-url =        "citeseer.ist.psu.edu/sitaram93handling.html",
  xpages =       "147--155",
  year =         "1993",
}

@InProceedings{danvy90abstracting,
  author =       "O. Danvy and A. Filinski",
  booktitle =    "Proceedings of the 1990 {ACM} Conference on {LISP} and
                 Functional Programming, Nice",
  citeulike-article-id = "104317",
  citeulike-linkout-0 = "\#",
  date-added =   "2005-02-26 03:28:53",
  keywords =     "continuations",
  priority =     "0",
  publisher =    "ACM",
  title =        "Abstracting Control",
  x-address =    "New York, NY",
  x-url =        "citeseer.ist.psu.edu/danvy90abstracting.html",
  xpages =       "151--160",
  year =         "1990",
}

@InProceedings{col93,
  author =       "Alain Colmerauer and Philippe Roussel",
  booktitle =    "The second ACM SIGPLAN conference on History of
                 programming languages",
  citeulike-article-id = "104316",
  date-added =   "2005-02-26 03:27:05",
  keywords =     "logic-programming",
  priority =     "0",
  publisher =    "ACM Press",
  title =        "The birth of Prolog",
  x-doi =        "10.1145/154766.155362",
  xpages =       "37--52",
  year =         "1993",
}

@Article{kow76,
  author =       "M. H. V. Van Emden and R. A. Kowalski",
  citeulike-article-id = "104315",
  date-added =   "2005-02-26 03:27:05",
  journal =      "J. ACM",
  keywords =     "logic-programming",
  number =       "4",
  priority =     "0",
  publisher =    "ACM Press",
  title =        "The Semantics of Predicate Logic as a Programming
                 Language",
  volume =       "23",
  x-abstract =   "Sentences in first-order predicate logic can be
                 usefully interpreted as programs. In this paper the and
                 fixpoint semantics of predicate logic programs are
                 defined, and the connections with the proof theory and
                 model theory of logic are investigated It is concluded
                 that operational semantics is a part of proof theory
                 and that fixpoint semantics is a special case of
                 model-theoret:c semantics",
  xpages =       "733--742",
  year =         "1976",
}

@Article{kow79,
  author =       "Robert Kowalski",
  citeulike-article-id = "104314",
  date-added =   "2005-02-26 03:27:05",
  journal =      "Commun. ACM",
  keywords =     "logic-programming",
  number =       "7",
  priority =     "0",
  publisher =    "ACM Press",
  title =        "Algorithm = logic + control",
  volume =       "22",
  x-abstract =   "An algorithm can be regarded as consisting of a logic
                 component, which specifies the knowledge to be used in
                 solving problems, and a control component, which
                 determines the problem-solving strategies by means of
                 which that knowledge is used. The logic component
                 determines the meaning of the algorithm whereas the
                 control component only affects its effkiency. The
                 effkiency of an algorithm can often be improved by
                 improving the control component without changing the
                 logic of the algorithm. We argue that computer programs
                 would be more often correct and more easily improved
                 and modified if their logic and control aspects were
                 identified and separated in the program text.",
  x-doi =        "10.1145/359131.359136",
  xpages =       "424--436",
  year =         "1979",
}

@InProceedings{kow74,
  author =       "Robert Kowalski",
  citeulike-article-id = "104313",
  date-added =   "2005-02-26 03:27:05",
  keywords =     "logic-programming",
  organization = "IFIP",
  priority =     "0",
  publisher =    "North-Holland Pub Co",
  title =        "Predicate logic as a Programming Language",
  xpages =       "569--574",
  year =         "1974",
}

@InProceedings{PeytonJones1993Imperative,
  author =       "Simon L. Peyton Jones and Philip Wadler",
  booktitle =    "Proceedings of the 20th ACM SIGPLAN-SIGACT symposium
                 on Principles of programming languages - POPL '93",
  citeulike-article-id = "100052",
  citeulike-linkout-0 = "http://portal.acm.org/citation.cfm?id=158524",
  citeulike-linkout-1 = "http://dx.doi.org/10.1145/158511.158524",
  date-added =   "2005-02-21 16:05:01",
  keywords =     "haskell, monads",
  location =     "Charleston, South Carolina, United States",
  priority =     "0",
  publisher =    "ACM Press",
  title =        "Imperative functional programming",
  x-doi =        "10.1145/158511.158524",
  x-isbn =       "0897915607",
  x-url =        "http://dx.doi.org/10.1145/158511.158524",
  xpages =       "71--84",
  year =         "1993",
}

@Article{Boyapati2003Ownership,
  author =       "Chandrasekhar Boyapati and Barbara Liskov and Liuba
                 Shrira",
  booktitle =    "POPL '03: Proceedings of the 30th ACM SIGPLAN-SIGACT
                 symposium on Principles of programming languages",
  citeulike-article-id = "100050",
  citeulike-linkout-0 = "http://portal.acm.org/citation.cfm?id=604156",
  citeulike-linkout-1 = "http://dx.doi.org/10.1145/604131.604156",
  date-added =   "2005-02-21 16:03:11",
  journal =      "SIGPLAN Not.",
  keywords =     "ownership-types",
  number =       "1",
  priority =     "0",
  publisher =    "ACM",
  title =        "Ownership types for object encapsulation",
  volume =       "38",
  x-abstract =   "Ownership types provide a statically enforceable way
                 of specifying object encapsulation and enable local
                 reasoning about program correctness in object-oriented
                 languages. However, a type system that enforces strict
                 object encapsulation is too constraining: it does not
                 allow efficient implementation of important constructs
                 like iterators. This paper argues that the right way to
                 solve the problem is to allow objects of classes
                 defined in the same module to have privileged access to
                 each other's representations; we show how to do this
                 for inner classes. This approach allows programmers to
                 express constructs like iterators and yet supports
                 local reasoning about the correctness of the classes,
                 because a class and its inner classes together can be
                 reasoned about as a module. The paper also sketches how
                 we use our variant of ownership types to enable
                 efficient software upgrades in persistent object
                 stores.",
  x-address =    "New York, NY, USA",
  x-doi =        "10.1145/604131.604156",
  x-issn =       "0362-1340",
  x-month =      jan,
  x-url =        "http://dx.doi.org/10.1145/604131.604156",
  xpages =       "213--223",
  year =         "2003",
}

@InProceedings{Lammel2003Scrap,
  author =       "Ralf L{\"{a}}mmel and Simon P. Jones",
  booktitle =    "TLDI '03: Proceedings of the 2003 ACM SIGPLAN
                 international workshop on Types in languages design and
                 implementation",
  citeulike-article-id = "100044",
  citeulike-linkout-0 = "http://portal.acm.org/citation.cfm?id=604179",
  citeulike-linkout-1 = "http://dx.doi.org/10.1145/604174.604179",
  date-added =   "2005-02-21 16:01:32",
  journal =      "SIGPLAN Not.",
  keywords =     "haskell, polytypic, type-classes",
  location =     "New Orleans, Louisiana, USA",
  number =       "3",
  priority =     "0",
  publisher =    "ACM",
  title =        "Scrap your boilerplate: a practical design pattern for
                 generic programming",
  volume =       "38",
  x-abstract =   "We describe a design pattern for writing programs that
                 traverse data structures built from rich
                 mutually-recursive data types. Such programs often have
                 a great deal of {"}boilerplate{"} code that simply
                 walks the structure, hiding a small amount of
                 {"}real{"} code that constitutes the reason for the
                 {traversal.Our} technique allows most of this
                 boilerplate to be written once and for all, or even
                 generated mechanically, leaving the programmer free to
                 concentrate on the important part of the algorithm.
                 These generic programs are much more adaptive when
                 faced with data structure evolution because they
                 contain many fewer lines of type-specific {code.Our}
                 approach is simple to understand, reasonably efficient,
                 and it handles all the data types found in conventional
                 functional programming languages. It makes essential
                 use of rank-2 polymorphism, an extension found in some
                 implementations of Haskell. Further it relies on a
                 simple type-safe cast operator.",
  x-address =    "New York, NY, USA",
  x-doi =        "10.1145/604174.604179",
  x-isbn =       "1-58113-649-8",
  x-issn =       "0362-1340",
  x-month =      mar,
  x-url =        "http://dx.doi.org/10.1145/604174.604179",
  xpages =       "26--37",
  year =         "2003",
}

@InProceedings{Lammel2004Scrap,
  author =       "Ralf L{\"{a}}mmel and Simon P. Jones",
  booktitle =    "ICFP '04: Proceedings of the ninth ACM SIGPLAN
                 international conference on Functional programming",
  citeulike-article-id = "100046",
  citeulike-linkout-0 = "http://portal.acm.org/citation.cfm?id=1016883",
  citeulike-linkout-1 = "http://dx.doi.org/10.1145/1016850.1016883",
  date-added =   "2005-02-21 16:01:21",
  keywords =     "haskell, polytypic, type-classes",
  location =     "Snow Bird, UT, USA",
  number =       "9",
  priority =     "0",
  publisher =    "ACM",
  title =        "Scrap more boilerplate: reflection, zips, and
                 generalised casts",
  volume =       "39",
  x-abstract =   "Writing boilerplate code is a royal pain. Generic
                 programming promises to alleviate this pain by allowing
                 the programmer to write a generic {"}recipe{"} for
                 boilerplate code, and use that recipe in many places.
                 In earlier work we introduced the {"}Scrap your
                 boilerplate{"} approach to generic programming, which
                 exploits Haskell's existing type-class mechanism to
                 support generic transformations and {queries.This}
                 paper completes the picture. We add a few extra
                 {"}introspective{"} or {"}reflective{"} facilities,
                 that together support a rich variety of serialisation
                 and de-serialisation. We also show how to perform
                 generic {"}zips{"}, which at first appear to be
                 somewhat tricky in our framework. Lastly, we generalise
                 the ability to over-ride a generic function with a
                 type-specific {one.All} of this can be supported in
                 Haskell with independently-useful extensions:
                 higher-rank types and type-safe cast. The {GHC}
                 implementation of Haskell readily derives the required
                 type classes for user-defined data types.",
  x-address =    "New York, NY, USA",
  x-doi =        "10.1145/1016850.1016883",
  x-isbn =       "1-58113-905-5",
  x-month =      sep,
  x-url =        "http://dx.doi.org/10.1145/1016850.1016883",
  xpages =       "244--255",
  year =         "2004",
}

@Article{Hinze2004Generics,
  author =       "Ralf Hinze",
  booktitle =    "ICFP '04: Proceedings of the ninth ACM SIGPLAN
                 international conference on Functional programming",
  citeulike-article-id = "100045",
  citeulike-linkout-0 = "http://portal.acm.org/citation.cfm?id=1016882",
  citeulike-linkout-1 = "http://dx.doi.org/10.1145/1016850.1016882",
  date-added =   "2005-02-21 16:01:12",
  journal =      "SIGPLAN Not.",
  keywords =     "haskell, polytypic, type-classes",
  number =       "9",
  priority =     "0",
  publisher =    "ACM",
  title =        "Generics for the masses",
  volume =       "39",
  x-abstract =   "A generic function is a function that can be
                 instantiated on many data types to obtain data type
                 specific functionality. Examples of generic functions
                 are the functions that can be derived in Haskell, such
                 as show, read, and '=='. The recent years have seen a
                 number of proposals that support the definition of
                 generic functions. Some of the proposals define new
                 languages, some define extensions to existing
                 languages. As a common characteristic none of the
                 proposals can be made to work within Haskell 98: they
                 all require something extra, either a more
                 sophisticated type system or an additional language
                 construct. The purpose of this pearl is to show that
                 one can, in fact, program generically within Haskell 98
                 obviating to some extent the need for fancy type
                 systems or separate tools. Haskell's type classes are
                 at the heart of this approach: they ensure that generic
                 functions can be defined succinctly and, in particular,
                 that they can be used painlessly.",
  x-address =    "New York, NY, USA",
  x-doi =        "10.1145/1016850.1016882",
  x-issn =       "0362-1340",
  x-month =      sep,
  x-url =        "http://dx.doi.org/10.1145/1016850.1016882",
  xpages =       "236--243",
  year =         "2004",
}

@InProceedings{Chakravarty2005Associated,
  author =       "Manuel M. T. Chakravarty and Gabriele Keller and Simon
                 P. Jones and Simon Marlow",
  booktitle =    "Proceedings of the 32Nd ACM SIGPLAN-SIGACT Symposium
                 on Principles of Programming Languages",
  citeulike-article-id = "100047",
  citeulike-linkout-0 = "http://portal.acm.org/citation.cfm?id=1040306",
  citeulike-linkout-1 = "http://dx.doi.org/10.1145/1040305.1040306",
  date-added =   "2005-02-21 16:00:36",
  keywords =     "haskell, type-classes",
  location =     "Long Beach, California, USA",
  priority =     "0",
  publisher =    "ACM",
  title =        "Associated Types with Class",
  x-abstract =   "Haskell's type classes allow ad-hoc overloading, or
                 type-indexing, of functions. A natural generalisation
                 is to allow type-indexing of data types as well. It
                 turns out that this idea directly supports a powerful
                 form of abstraction called associated types, which are
                 available in C++ using traits classes. Associated types
                 are useful in many applications, especially for
                 self-optimising libraries that adapt their data
                 representations and algorithms in a type-directed
                 {manner.In} this paper, we introduce and motivate
                 associated types as a rather natural generalisation of
                 Haskell's existing type classes. Formally, we present a
                 type system that includes a type-directed translation
                 into an explicitly typed target language akin to System
                 F; the existence of this translation ensures that the
                 addition of associated data types to an existing
                 Haskell compiler only requires changes to the front
                 end.",
  x-address =    "New York, NY, USA",
  x-doi =        "10.1145/1040305.1040306",
  x-isbn =       "1-58113-830-X",
  x-series =     "POPL '05",
  x-url =        "http://dx.doi.org/10.1145/1040305.1040306",
  xpages =       "1--13",
  year =         "2005",
}

@Proceedings{Shinwell2003FreshML,
  author =       "Mark R. Shinwell and Andrew M. Pitts and Murdoch J.
                 Gabbay",
  booktitle =    "ICFP '03: Proceedings of the eighth ACM SIGPLAN
                 international conference on Functional programming",
  citeulike-article-id = "100048",
  citeulike-linkout-0 = "http://portal.acm.org/citation.cfm?id=944729",
  citeulike-linkout-1 = "http://dx.doi.org/10.1145/944705.944729",
  date-added =   "2005-02-21 16:00:20",
  keywords =     "binding",
  number =       "9",
  priority =     "4",
  publisher =    "ACM Press",
  title =        "{FreshML}: programming with binders made simple",
  volume =       "38",
  x-doi =        "10.1145/944705.944729",
  x-isbn =       "1581137567",
  x-month =      sep,
  x-url =        "http://dx.doi.org/10.1145/944705.944729",
  xpages =       "263--274",
  year =         "2003",
}

@Proceedings{Shao1994Unrolling,
  author =       "Zhong Shao and John H. Reppy and Andrew W. Appel",
  booktitle =    "LFP '94: Proceedings of the 1994 ACM conference on
                 LISP and functional programming",
  citeulike-article-id = "100038",
  citeulike-linkout-0 = "http://www.cs.princeton.edu/research/techreps/TR-453-94",
  citeulike-linkout-1 = "http://portal.acm.org/citation.cfm?id=182409.182453",
  citeulike-linkout-2 = "http://dx.doi.org/10.1145/182409.182453",
  date-added =   "2005-02-21 15:55:55",
  keywords =     "compiler, data-structures, optimization",
  priority =     "0",
  publisher =    "ACM Press",
  title =        "Unrolling lists",
  x-doi =        "10.1145/182409.182453",
  x-isbn =       "0897916433",
  x-url =        "http://www.cs.princeton.edu/research/techreps/TR-453-94",
  xpages =       "185--195",
  year =         "1994",
}

@TechReport{Appel1992Unrolling,
  author =       "Andrew W. Appel",
  citeulike-article-id = "80546",
  date-added =   "2005-02-21 15:54:11",
  day =          "10",
  institution =  "Princeton University",
  journal =      "University of Pennsylvania Law Review",
  keywords =     "compiler, loop-optimization",
  number =       "CS-TR-363-92",
  priority =     "0",
  title =        "Unrolling Recursions Saves Space",
  volume =       "154",
  x-issn =       "00419907",
  x-month =      mar,
  xpages =       "477+",
  year =         "1992",
}

@Article{Appel1994Loop,
  author =       "Andrew W. Appel",
  citeulike-article-id = "100028",
  citeulike-linkout-0 = "http://www.cs.princeton.edu/research/techreps/TR-460-94",
  citeulike-linkout-1 = "http://citeseer.ist.psu.edu/appel94loop.html",
  citeulike-linkout-2 = "http://portal.acm.org/citation.cfm?id=213278.213283",
  date-added =   "2005-02-21 15:46:22",
  journal =      "Lisp Symb. Comput.",
  keywords =     "compiler, cps, loop-optimization",
  number =       "4",
  priority =     "3",
  publisher =    "Kluwer Academic Publishers",
  title =        "Loop headers in \&lgr;-calculus or {CPS}",
  volume =       "7",
  x-issn =       "0892-4635",
  x-month =      dec,
  x-url =        "http://www.cs.princeton.edu/research/techreps/TR-460-94",
  xpages =       "337--343",
  year =         "1994",
}

@Article{Tarditi1992No,
  author =       "David Tarditi and Peter Lee and Anurag Acharya",
  citeulike-article-id = "4640",
  citeulike-linkout-0 = "http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.43.7510",
  date-added =   "2005-02-21 15:26:20",
  journal =      "ACM Letters on Programming Languages and Systems",
  keywords =     "compiler, ml",
  number =       "2",
  priority =     "2",
  publisher =    "ACM Press",
  title =        "No Assembly Required: Compiling Standard {ML} to {C}",
  volume =       "1",
  x-abstract =   "C has been used as a portable target language for
                 implementing languages like Standard {ML} and Scheme.
                 Previous efforts at compiling these languages to C have
                 produced efficient code, but also compromised on
                 portability and proper tail-recursion. We show how to
                 compile Standard {ML} to C without making such
                 compromises. The compilation technique is based on
                 converting Standard {ML} to a continuation-passing
                 style -calculus intermediate language, and then
                 compiling the continuationpassing style...",
  x-month =      jun,
  x-url =        "http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.43.7510",
  xpages =       "161--177",
  year =         "1992",
}

@Proceedings{Macqueen1993Reflections,
  author =       "David B. Macqueen",
  booktitle =    "Functional Programming, Concurrency, Simulation and
                 Automated Reasoning",
  citeulike-article-id = "71839",
  citeulike-linkout-0 = "http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.55.5152",
  date-added =   "2005-02-21 15:25:30",
  keywords =     "ml",
  priority =     "2",
  title =        "Reflections on Standard {ML}",
  x-abstract =   "Standard {ML} is one of a number of new programming
                 languages developed in the 1980s that are seen as
                 suitable vehicles for serious systems and applications
                 programming. It offers an excellent ratio of
                 expressiveness to language complexity, and provides
                 competitive efficiency. Because of its type and module
                 system, Standard {ML} manages to combine safety,
                 security, and robustness with much of the flexibility
                 of dynamically typed languages like Lisp. It is also
                 has the most well-developed scientific ...",
  x-url =        "http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.55.5152",
  xpages =       "32--46",
  year =         "1993",
}

@Article{Cilibrasi2007Google,
  archiveprefix = "arXiv",
  author =       "Rudi Cilibrasi and Paul M. B. Vitanyi",
  citeulike-article-id = "4487",
  citeulike-linkout-0 = "http://arxiv.org/abs/cs.CL/0412098",
  citeulike-linkout-1 = "http://arxiv.org/pdf/cs.CL/0412098",
  date-added =   "2005-02-21 15:16:02",
  day =          "30",
  eprint =       "cs.CL/0412098",
  keywords =     "google, web",
  priority =     "0",
  title =        "The Google Similarity Distance",
  x-abstract =   "Words and phrases acquire meaning from the way they
                 are used in society, from their relative semantics to
                 other words and phrases. For computers the equivalent
                 of `society' is `database,' and the equivalent of `use'
                 is `way to search the database.' We present a new
                 theory of similarity between words and phrases based on
                 information distance and Kolmogorov complexity. To fix
                 thoughts we use the world-wide-web as database, and
                 Google as search engine. The method is also applicable
                 to other search engines and databases. This theory is
                 then applied to construct a method to automatically
                 extract similarity, the Google similarity distance, of
                 words and phrases from the world-wide-web using Google
                 page counts. The world-wide-web is the largest database
                 on earth, and the context information entered by
                 millions of independent users averages out to provide
                 automatic semantics of useful quality. We give
                 applications in hierarchical clustering,
                 classification, and language translation. We give
                 examples to distinguish between colors and numbers,
                 cluster names of paintings by 17th century Dutch
                 masters and names of books by English novelists, the
                 ability to understand emergencies, and primes, and we
                 demonstrate the ability to do a simple automatic
                 {English-Spanish} translation. Finally, we use the
                 {WordNet} database as an objective baseline against
                 which to judge the performance of our method. We
                 conduct a massive randomized trial in binary
                 classification using support vector machines to learn
                 categories based on our Google distance, resulting in
                 an a mean agreement of 87\% with the expert crafted
                 {WordNet} categories.",
  x-month =      may,
  x-url =        "http://arxiv.org/abs/cs.CL/0412098",
  year =         "2007",
}

@Article{Barnett2004Verification,
  author =       "Mike Barnett and Robert Deline and Manuel
                 F{\"{a}}hndrich and K. R. M. Rustan and Wolfram
                 Schulte",
  booktitle =    "Special issue: ECOOP 2003 workshop on Formal
                 Techniques for Java-like Programs",
  citeulike-article-id = "99987",
  citeulike-linkout-0 = "http://www.jot.fm/issues/issue\_2004\_06/article2/index\_html",
  date-added =   "2005-02-21 15:05:59",
  journal =      "Jounnal of Object Technology",
  keywords =     "contracts, csharp, verification",
  number =       "6",
  priority =     "0",
  title =        "Verification of object-oriented programs with
                 invariants",
  volume =       "3",
  x-month =      jun,
  x-url =        "http://www.jot.fm/issues/issue\_2004\_06/article2/index\_html",
  xpages =       "27--56",
  year =         "2004",
}

@InProceedings{Wadler1987Views,
  author =       "P. Wadler",
  booktitle =    "Proceedings of the 14th ACM SIGACT-SIGPLAN symposium
                 on Principles of programming languages",
  citeulike-article-id = "4968",
  citeulike-linkout-0 = "http://portal.acm.org/citation.cfm?id=41653",
  citeulike-linkout-1 = "http://dx.doi.org/10.1145/41625.41653",
  date-added =   "2005-02-17 22:51:40",
  keywords =     "haskell, pattern-matching",
  location =     "Munich, West Germany",
  priority =     "3",
  publisher =    "ACM",
  title =        "Views: a way for pattern matching to cohabit with data
                 abstraction",
  x-abstract =   "Pattern matching and data abstraction are important
                 concepts in designing programs, but they do not fit
                 well together. Pattern matching depends on making
                 public a free data type representation, while data
                 abstraction depends on hiding the representation. This
                 paper proposes the views mechanism as a means of
                 reconciling this conflict. A view allows any type to be
                 viewed as a free data type, thus combining the clarity
                 of pattern matching with the efficiency of data
                 abstraction.",
  x-address =    "New York, NY, USA",
  x-doi =        "10.1145/41625.41653",
  x-isbn =       "0-89791-215-2",
  x-series =     "POPL '87",
  x-url =        "http://dx.doi.org/10.1145/41625.41653",
  xpages =       "307--313",
  year =         "1987",
}

@Proceedings{Igarashi1999Featherweight,
  author =       "Atshushi Igarashi and Benjamin Pierce and Philip
                 Wadler",
  booktitle =    "Proceedings of the 1999 ACM SIGPLAN Conference on
                 Object-Oriented Programming, Systems, Languages \&
                 Applications (OOPSLA`99)",
  citeulike-article-id = "87980",
  citeulike-linkout-0 = "http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.39.7779",
  date-added =   "2005-02-06 21:31:22",
  keywords =     "generics, java",
  priority =     "0",
  title =        "Featherweight Java: {A} Minimal Core Calculus for Java
                 and {GJ}",
  volume =       "34(10)",
  x-abstract =   "Several recent studies have introduced lightweight
                 versions of Java: reduced languages in which complex
                 features like threads and reflection are dropped to
                 enable rigorous arguments about key properties such as
                 type safety. We carry this process a step further,
                 omitting almost all features of the full language
                 (including interfaces and even assignment) to obtain a
                 small calculus, Featherweight Java, for which rigorous
                 proofs are not only possible but easy. Featherweight
                 Java bears a similar...",
  x-address =    "N. Y.",
  x-editor =     "Meissner, Loren",
  x-url =        "http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.39.7779",
  xpages =       "132--146",
  year =         "1999",
}

@Article{Wadler1998Why,
  author =       "Philip Wadler",
  citeulike-article-id = "4870",
  citeulike-linkout-0 = "http://portal.acm.org/citation.cfm?id=286385.286387",
  citeulike-linkout-1 = "http://dx.doi.org/10.1145/286385.286387",
  date-added =   "2005-02-06 21:30:56",
  journal =      "SIGPLAN Not.",
  keywords =     "functional-programming",
  number =       "8",
  priority =     "0",
  publisher =    "ACM",
  title =        "Why no one uses functional languages",
  volume =       "33",
  x-abstract =   "An abstract is not available.",
  x-address =    "New York, NY, USA",
  x-doi =        "10.1145/286385.286387",
  x-issn =       "0362-1340",
  x-month =      aug,
  x-url =        "http://dx.doi.org/10.1145/286385.286387",
  xpages =       "23--27",
  year =         "1998",
}

@InProceedings{jiazzi01,
  author =       "Sean Mcdirmid and Matthew Flatt and Wilson Hsieh",
  booktitle =    "Proc. of OOPSLA",
  citeulike-article-id = "4863",
  citeulike-linkout-0 = "http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.15.8885",
  date-added =   "2005-01-27 18:52:53",
  keywords =     "components, oopsla-paper, plt",
  priority =     "0",
  title =        "Jiazzi: {New-Age} Components for {Old-Fashioned}
                 Java",
  x-abstract =   "We present Jiazzi, a system that enables the
                 construction of largescale binary components in Java.
                 Jiazzi components can be thought of as generalizations
                 of Java packages with added support for external
                 linking and separate compilation. Jiazzi components are
                 practical because they are constructed out of standard
                 Java source code. Jiazzi requires neither extensions to
                 the Java language nor special conventions for writing
                 Java source code that will go inside a component. Our
                 components are...",
  x-month =      oct,
  x-url =        "http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.15.8885",
  year =         "2001",
}

@InProceedings{mj03,
  author =       "John Corwin and David F. Bacon and David Grove and
                 Chet Murthy",
  booktitle =    "OOPSLA '03: Proceedings of the 18th annual ACM SIGPLAN
                 conference on Object-oriented programing, systems,
                 languages, and applications",
  citeulike-article-id = "84629",
  citeulike-linkout-0 = "http://portal.acm.org/citation.cfm?id=949326",
  citeulike-linkout-1 = "http://dx.doi.org/10.1145/949305.949326",
  date-added =   "2005-01-27 18:49:58",
  keywords =     "components, oopsla-paper",
  number =       "11",
  priority =     "0",
  publisher =    "ACM Press",
  title =        "{MJ}: a rational module system for Java and its
                 applications",
  volume =       "38",
  x-doi =        "10.1145/949305.949326",
  x-issn =       "0362-1340",
  x-month =      oct,
  x-url =        "http://dx.doi.org/10.1145/949305.949326",
  xpages =       "241--254",
  year =         "2003",
}

@Misc{MeunierSelectors,
  author =       "Philippe Meunier and Robby Findler and Paul A.
                 Steckler and Mitchell Wand",
  citeulike-article-id = "83025",
  citeulike-linkout-0 = "http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.23.7295",
  date-added =   "2005-01-24 23:22:10",
  keywords =     "cfa, flow-analysis, plt, scheme",
  priority =     "0",
  title =        "Selectors Make Analyzing case-lambda Too Hard",
  x-abstract =   "Flanagan's set-based analysis ({SBA}) uses selectors
                 to choose data owing through expressions. For example,
                 the rng selector chooses the ranges of procedures owing
                 through an expression. The {MrSpidey} static debugger
                 for {PLT} Scheme is based on Flanagan's formalism. In
                 {PLT} Scheme, a caselambda is a procedure with possibly
                 several argument lists and clauses. When a case-lambda
                 is applied at a particular call site, at most one
                 clause is actually invoked, chosen by the number of
                 actual arguments....",
  x-url =        "http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.23.7295",
}

@Misc{Flanagan1998New,
  author =       "C. Flanagan and M. Felleisen",
  citeulike-article-id = "83024",
  citeulike-linkout-0 = "http://citeseer.ist.psu.edu/flanagan98new.html",
  citeulike-linkout-1 = "http://citeseer.lcs.mit.edu/flanagan98new.html",
  citeulike-linkout-2 = "http://citeseer.ifi.unizh.ch/flanagan98new.html",
  citeulike-linkout-3 = "http://citeseer.comp.nus.edu.sg/flanagan98new.html",
  date-added =   "2005-01-24 23:21:52",
  keywords =     "cfa, flow-analysis, plt, scheme",
  priority =     "2",
  title =        "A New Way of Debugging Lisp Programs",
  x-abstract =   "A major cause of software unreliability is the
                 misapplication of primitive operations, such as taking
                 the car of nil, dividing by zero, or using an invalid
                 array index. These errors are traditionally discovered
                 by extensive testing and debugging, but this approach
                 is unsatisfactory because it is time-consuming and may
                 not identify all potential errors. We suggest to
                 address this problem with sophisticated static
                 debugging systems. Recent advances in proof technology
                 have brought such advanced...",
  x-url =        "http://citeseer.ist.psu.edu/flanagan98new.html",
  year =         "1998",
}

@Article{Palsberg1998Equalitybased,
  author =       "Jens Palsberg",
  citeulike-article-id = "83014",
  citeulike-linkout-0 = "http://portal.acm.org/citation.cfm?id=295662",
  citeulike-linkout-1 = "http://dx.doi.org/10.1145/295656.295662",
  date-added =   "2005-01-24 22:19:17",
  journal =      "ACM Trans. Program. Lang. Syst.",
  keywords =     "flow-analysis, types",
  number =       "6",
  priority =     "2",
  publisher =    "ACM Press",
  title =        "Equality-based flow analysis versus recursive types",
  volume =       "20",
  x-doi =        "10.1145/295656.295662",
  x-issn =       "0164-0925",
  x-month =      nov,
  x-url =        "http://dx.doi.org/10.1145/295656.295662",
  xpages =       "1251--1264",
  year =         "1998",
}

@Article{Felleisen2003Programming,
  author =       "M. Felleisen and M. Flatt",
  citeulike-article-id = "83013",
  citeulike-linkout-0 = "http://www.cs.utah.edu/plt/publications/pllc.pdf",
  date-added =   "2005-01-24 22:17:26",
  day =          "27",
  keywords =     "plt",
  priority =     "2",
  title =        "Programming Languages and Lambda Calculi",
  x-month =      aug,
  x-url =        "http://www.cs.utah.edu/plt/publications/pllc.pdf",
  year =         "2003",
}

@Proceedings{Ruby2000Safely,
  author =       "Clyde Ruby and Gary T. Leavens",
  booktitle =    "OOPSLA '00: Proceedings of the 15th ACM SIGPLAN
                 conference on Object-oriented programming, systems,
                 languages, and applications",
  citeulike-article-id = "83012",
  citeulike-linkout-0 = "http://portal.acm.org/citation.cfm?id=353186",
  citeulike-linkout-1 = "http://dx.doi.org/10.1145/353171.353186",
  date-added =   "2005-01-24 22:14:00",
  keywords =     "honu, oop",
  number =       "10",
  priority =     "3",
  publisher =    "ACM Press",
  title =        "Safely creating correct subclasses without seeing
                 superclass code",
  volume =       "35",
  x-doi =        "10.1145/353171.353186",
  x-issn =       "0362-1340",
  x-month =      oct,
  x-url =        "http://dx.doi.org/10.1145/353171.353186",
  xpages =       "208--228",
  year =         "2000",
}

@PhdThesis{Tarditi1996Design,
  author =       "D. Tarditi",
  citeulike-article-id = "82940",
  citeulike-linkout-0 = "http://reports-archive.adm.cs.cmu.edu/anon/1997/CMU-CS-97-108.ps",
  citeulike-linkout-1 = "http://citeseer.ist.psu.edu/context/66726/0",
  date-added =   "2005-01-24 19:04:29",
  keywords =     "compiler, ml, ssa",
  priority =     "2",
  school =       "School of Computer Science, Carnegie Mellon
                 University",
  title =        "Design and Implementation of Code Optimizations for a
                 {Type-Directed} Compiler for Standard {ML}",
  x-abstract =   "The trends in software development are towards larger
                 programs, more complex programs, and more use of
                 programs as {"}component software.{"} These trends mean
                 that the features of modern programming languages are
                 becoming more important than ever before. Programming
                 languages need to have features such as strong typing,
                 a module system, polymorphism, automatic storage
                 management, and higher-order functions. In short,
                 modern programming languages are becoming more
                 important than ever before. Even though modern
                 programming lanuages are becoming more important than
                 ever before, programmers have traditionally faced a
                 dilemma: programs written in these languages
                 traditionally have had lower performance than programs
                 written in more conventional, but error-prone
                 languages. In this thesis, I study this problem in the
                 context of one particular modern programming language,
                 Standard {ML}. Standard {ML} contains all the language
                 features mentioned previously and more. I use an
                 empirical approach to understand where Standard {ML}
                 programs spend their time and how to improve the
                 performance of Standard {ML} programs through better
                 optimization. The thesis contains two main results.
                 First, I find that a {"}pay-as-you-go{"} compilation
                 strategy, where programmers pay for advanced language
                 features only when they use them, is a practical
                 strategy for compiling Standard {ML}. In fact, this
                 strategy produces better code overall than a strategy
                 that makes advanced language features run fast at the
                 expense of slowing down programs that do not use those
                 language features. Second, I find that compilers for
                 Standard {ML} should focus on generating good code for
                 the frequently-executed parts of programs.
                 Specifically, just as compilers for conventional
                 languages such as C focus on generating good code for
                 loops, compilers for lanuages such as Standard {ML}
                 should focus on generating good code for recursive
                 functions. These results suggest that compilation of
                 modern programming languages such as Standard {ML}
                 should have a great deal in common with compilation of
                 more conventional languages such as C. First, Standard
                 {ML} programs that do not use higher-order functions or
                 polymorphism should run just as fast as comparable C
                 programs. Second, Standard {ML} compilers should apply
                 the same sets of optimizations to recursive functions
                 that more conventional compilers apply to loops. These
                 results also suggest that programmers should be able to
                 avoid the dilemma mentioned earlier: they should be
                 able to write their programs in modern languages such
                 as Standard {ML}, confident that they can rewrite parts
                 of the programs in a subset of Standard {ML} if
                 necessary for efficiency.",
  x-month =      dec,
  x-url =        "http://reports-archive.adm.cs.cmu.edu/anon/1997/CMU-CS-97-108.ps",
  year =         "1996",
}

@Article{Appel1998SSA,
  author =       "Andrew W. Appel",
  citeulike-article-id = "4639",
  citeulike-linkout-0 = "http://portal.acm.org/citation.cfm?id=278285",
  citeulike-linkout-1 = "http://dx.doi.org/10.1145/278283.278285",
  date-added =   "2005-01-24 19:00:16",
  journal =      "SIGPLAN Not.",
  keywords =     "compiler, ssa",
  number =       "4",
  priority =     "2",
  publisher =    "ACM",
  title =        "{SSA} is functional programming",
  volume =       "33",
  x-abstract =   "An abstract is not available.",
  x-address =    "New York, NY, USA",
  x-doi =        "10.1145/278283.278285",
  x-issn =       "0362-1340",
  x-month =      apr,
  x-url =        "http://dx.doi.org/10.1145/278283.278285",
  xpages =       "17--20",
  year =         "1998",
}

@Proceedings{Clinger1984Scheme,
  author =       "William Clinger",
  booktitle =    "LFP '84: Proceedings of the 1984 ACM Symposium on LISP
                 and functional programming",
  citeulike-article-id = "82939",
  citeulike-linkout-0 = "http://portal.acm.org/citation.cfm?id=802052",
  date-added =   "2005-01-24 18:59:54",
  keywords =     "compiler, scheme",
  priority =     "2",
  publisher =    "ACM Press",
  title =        "The scheme 311 compiler an exercise in denotational
                 semantics",
  x-isbn =       "0897911423",
  x-url =        "http://portal.acm.org/citation.cfm?id=802052",
  xpages =       "356--364",
  year =         "1984",
}

@TechReport{Steele1978Rabbit,
  author =       "Guy L. Steele",
  citeulike-article-id = "82938",
  citeulike-linkout-0 = "http://portal.acm.org/citation.cfm?id=889478",
  date-added =   "2005-01-24 18:58:15",
  keywords =     "compiler, scheme",
  priority =     "2",
  publisher =    "Massachusetts Institute of Technology",
  title =        "Rabbit: {A} Compiler for Scheme",
  x-abstract =   "We have developed a compiler for the lexically-scoped
                 dialect of {LISP} known as {SCHEME}. The compiler knows
                 relatively little about specific data manipulation
                 primitives such as arithmetic operators, but
                 concentrates on general issues of environment and
                 control. Rather than having specialized knowledge about
                 a large variety of control and environment constructs,
                 the compiler handles only a small basis set which
                 reflects the semantics of lambda-calculus. All of the
                 traditional imperative constructs, such as sequencing,
                 assignment, looping, {GO} {TO}, as well as many
                 standard {LISP} constructs such as {AND}, {OR} and
                 {COND}, are expressed as macros in terms of the
                 applicative basis set. A small number of optimization
                 techniques, coupled with the treatment of function
                 calls as {GO} {TO} statements, serves to produce code
                 as good as that produced by more traditional
                 compilers.",
  x-address =    "Cambridge, MA, USA",
  x-url =        "http://portal.acm.org/citation.cfm?id=889478",
  year =         "1978",
}

@Article{Ashley1998Practical,
  author =       "J. Michael Ashley and R. Kent Dybvig",
  citeulike-article-id = "82937",
  citeulike-linkout-0 = "http://portal.acm.org/citation.cfm?id=291898",
  citeulike-linkout-1 = "http://dx.doi.org/10.1145/291891.291898",
  date-added =   "2005-01-24 18:58:05",
  journal =      "ACM Trans. Program. Lang. Syst.",
  keywords =     "cfa, compiler",
  number =       "4",
  priority =     "2",
  publisher =    "ACM",
  title =        "A practical and flexible flow analysis for
                 higher-order languages",
  volume =       "20",
  x-abstract =   "A flow analysis collects data-flow and control-flow
                 information about programs. A compiler can use this
                 information to enable optimizations. The analysis
                 described in this article unifies and extends previous
                 work on flow analysis for higher-order languages
                 supporting assignment and control operators. The
                 analysis is abstract interpretation based and is
                 parameterized over two polyvariance operators and a
                 projection operator. These operators are used to
                 regulate the speed and accuracy of the analysis. An
                 implementation of the analysis is incorporated into and
                 used in a production Scheme compiler. The analysis can
                 process any legal Scheme program without modification.
                 Others have demonstrated that a {0CFA} analysis can
                 enables the optimizations, but a {0CFA} analysis is
                 O(n)3). An O(n) instantiation of our analysis
                 successfully enables the optimization of closure
                 representations and procedure calls. Experiments with
                 the cheaper instantiation show that it is as effective
                 as {0CFA} for these optimizations.",
  x-address =    "New York, NY, USA",
  x-doi =        "10.1145/291891.291898",
  x-issn =       "0164-0925",
  x-month =      jul,
  x-url =        "http://dx.doi.org/10.1145/291891.291898",
  xpages =       "845--868",
  year =         "1998",
}

@PhdThesis{Shivers1991Controlflow,
  author =       "Olin G. Shivers",
  citeulike-article-id = "82936",
  citeulike-linkout-0 = "http://portal.acm.org/citation.cfm?id=124950",
  date-added =   "2005-01-24 18:57:49",
  keywords =     "cfa",
  priority =     "2",
  publisher =    "Carnegie Mellon University",
  title =        "Control-flow analysis of higher-order languages or
                 taming lambda",
  x-abstract =   "An abstract is not available.",
  x-address =    "Pittsburgh, PA, USA",
  x-url =        "http://portal.acm.org/citation.cfm?id=124950",
  year =         "1991",
}

@Article{Shivers2004Higherorder,
  author =       "Olin Shivers",
  citeulike-article-id = "82933",
  citeulike-linkout-0 = "http://portal.acm.org/citation.cfm?id=989421",
  citeulike-linkout-1 = "http://dx.doi.org/10.1145/989393.989421",
  date-added =   "2005-01-24 18:53:42",
  journal =      "SIGPLAN Not.",
  keywords =     "cfa, compiler, cps, flow-analysis",
  number =       "4",
  priority =     "0",
  publisher =    "ACM",
  title =        "Higher-order control-flow analysis in retrospect:
                 lessons learned, lessons abandoned",
  volume =       "39",
  x-abstract =   "Traditional flow analysis techniques, such as the ones
                 typically employed by optimising Fortran compilers, do
                 not work for Scheme-like languages. This paper presents
                 a flow analysis technique --- control flow analysis ---
                 which is applicable to Scheme-like languages. As a
                 demonstration application, the information gathered by
                 control flow analysis is used to perform a traditional
                 flow analysis problem, induction variable elimination.
                 Extensions and limitations are {discussed.The}
                 techniques presented in this paper are backed up by
                 working code. They are applicable not only to Scheme,
                 but also to related languages, such as Common Lisp and
                 {ML}.",
  x-address =    "New York, NY, USA",
  x-doi =        "10.1145/989393.989421",
  x-issn =       "0362-1340",
  x-month =      apr,
  x-url =        "http://dx.doi.org/10.1145/989393.989421",
  xpages =       "257--269",
  year =         "2004",
}

@Proceedings{Tarditi1996TIL,
  author =       "D. Tarditi and G. Morrisett and P. Cheng and C. Stone
                 and R. Harper and P. Lee",
  booktitle =    "Proc. ACM SIGPLAN '96 Conference on Programming
                 Language Design and Implementation",
  citeulike-article-id = "82934",
  citeulike-linkout-0 = "http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.43.8334",
  date-added =   "2005-01-24 18:53:09",
  keywords =     "compiler, ml",
  priority =     "2",
  title =        "{TIL}: {A} {Type-Directed} Optimizing Compiler for
                 {ML}",
  x-abstract =   "We describe a new compiler for Standard {ML} called
                 {TIL}, that is based on four technologies: intensional
                 polymorphism, tag-free garbage collection, conventional
                 functional language optimization, and loop
                 optimization. We use intensional polymorphism and
                 tag-free garbage collection to provide specialized
                 representations, even though {SML} is a polymorphic
                 language. We use conventional functional language
                 optimization to reduce the cost of intensional
                 polymorphism, and loop optimization to generate...",
  x-url =        "http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.43.8334",
  xpages =       "181--192",
  year =         "1996",
}

@Article{Flanagan2004Essence,
  author =       "Cormac Flanagan and Amr Sabry and Bruce F. Duba and
                 Matthias Felleisen",
  citeulike-article-id = "82932",
  citeulike-linkout-0 = "http://portal.acm.org/citation.cfm?id=989443",
  citeulike-linkout-1 = "http://dx.doi.org/10.1145/989393.989443",
  date-added =   "2005-01-24 18:49:56",
  journal =      "SIGPLAN Not.",
  keywords =     "compiler, continuations, cps, plt",
  number =       "4",
  priority =     "2",
  publisher =    "ACM",
  title =        "The essence of compiling with continuations",
  volume =       "39",
  x-abstract =   "In order to simplify the compilation process, many
                 compilers for higher-order languages use the
                 continuation-passing style ({CPS}) transformation in a
                 first phase to generate an intermediate representation
                 of the source program. The salient aspect of this
                 intermediate form is that all procedures take an
                 argument that represents the rest of the computation
                 (the {"}continuation{"}). Since the na{\"{i}}ve {CPS}
                 transformation considerably increases the size of
                 programs, {CPS} compilers perform reductions to produce
                 a more compact intermediate representation. Although
                 often implemented as a part of the {CPS}
                 transformation, this step is conceptually a second
                 phase. Finally, code generators for typical {CPS}
                 compilers treat continuations specially in order to
                 optimize the interpretation of continuation
                 {parameters.A} thorough analysis of the abstract
                 machine for {CPS} terms shows that the actions of the
                 code generator invert the na{\"{i}}ve {CPS} translation
                 step. Put differently, the combined effect of the three
                 phases is equivalent to a source-to-source
                 transformation that simulates the compaction phase.
                 Thus, fully developed {CPS} compilers do not need to
                 employ the {CPS} transformation but can achieve the
                 same results with a simple source-level
                 transformation.",
  x-address =    "New York, NY, USA",
  x-doi =        "10.1145/989393.989443",
  x-issn =       "0362-1340",
  x-month =      apr,
  x-url =        "http://dx.doi.org/10.1145/989393.989443",
  xpages =       "502--514",
  year =         "2004",
}

@InProceedings{Kelsey1995Correspondence,
  author =       "Richard A. Kelsey",
  booktitle =    "Papers from the 1995 ACM SIGPLAN workshop on
                 Intermediate representations",
  citeulike-article-id = "82931",
  citeulike-linkout-0 = "http://portal.acm.org/citation.cfm?id=202532",
  citeulike-linkout-1 = "http://dx.doi.org/10.1145/202529.202532",
  date-added =   "2005-01-24 18:49:00",
  keywords =     "compiler, cps, ssa",
  location =     "San Francisco, California, United States",
  number =       "3",
  priority =     "2",
  publisher =    "ACM",
  title =        "A correspondence between continuation passing style
                 and static single assignment form",
  volume =       "30",
  x-abstract =   "We define syntactic transformations that convert
                 continuation passing style ({CPS}) programs into static
                 single assignment form ({SSA}) and vice versa. Some
                 {CPS} programs cannot be converted to {SSA}, but these
                 are not produced by the usual {CPS} transformation. The
                 {CPS}→{SSA} transformation is especially helpful for
                 compiling functional programs. Many optimizations that
                 normally require flow analysis can be performed
                 directly on functional {CPS} programs by viewing them
                 as {SSA} programs. We also present a simple program
                 transformation that merges {CPS} procedures together
                 and by doing so greatly increases the scope of the
                 {SSA} flow information. This transformation is useful
                 for analyzing loops expressed as recursive
                 procedures.",
  x-address =    "New York, NY, USA",
  x-doi =        "10.1145/202529.202532",
  x-isbn =       "0-89791-754-5",
  x-month =      mar,
  x-series =     "IR '95",
  x-url =        "http://dx.doi.org/10.1145/202529.202532",
  xpages =       "13--22",
  year =         "1995",
}

@Article{Reppy2002Optimizing,
  author =       "John Reppy",
  citeulike-article-id = "82930",
  citeulike-linkout-0 = "http://portal.acm.org/citation.cfm?id=609235",
  date-added =   "2005-01-24 18:47:29",
  journal =      "Higher Order Symbol. Comput.",
  keywords =     "compiler, cps, loop-optimization",
  number =       "2-3",
  priority =     "3",
  publisher =    "Kluwer Academic Publishers",
  title =        "Optimizing Nested Loops Using Local {CPS} Conversion",
  volume =       "15",
  x-issn =       "1388-3690",
  x-url =        "http://portal.acm.org/citation.cfm?id=609235",
  xpages =       "161--180",
  year =         "2002",
}

@Proceedings{Thielecke2003From,
  author =       "Hayo Thielecke",
  booktitle =    "POPL '03: Proceedings of the 30th ACM SIGPLAN-SIGACT
                 symposium on Principles of programming languages",
  citeulike-article-id = "4963",
  citeulike-linkout-0 = "http://portal.acm.org/citation.cfm?id=604144",
  citeulike-linkout-1 = "http://dx.doi.org/10.1145/604131.604144",
  date-added =   "2005-01-10 16:17:20",
  keywords =     "continuations, effects",
  number =       "1",
  priority =     "2",
  publisher =    "ACM Press",
  title =        "From control effects to typed continuation passing",
  volume =       "38",
  x-doi =        "10.1145/604131.604144",
  x-isbn =       "1581136285",
  x-month =      jan,
  x-url =        "http://dx.doi.org/10.1145/604131.604144",
  xpages =       "139--149",
  year =         "2003",
}

@Proceedings{Jouvelot1989Reasoning,
  author =       "P. Jouvelot and D. K. Gifford",
  booktitle =    "PLDI '89: Proceedings of the ACM SIGPLAN 1989
                 Conference on Programming language design and
                 implementation",
  citeulike-article-id = "4966",
  citeulike-linkout-0 = "http://portal.acm.org/citation.cfm?id=74837",
  citeulike-linkout-1 = "http://dx.doi.org/10.1145/73141.74837",
  date-added =   "2005-01-10 16:16:54",
  keywords =     "continuations, effects, fx",
  number =       "7",
  priority =     "0",
  publisher =    "ACM Press",
  title =        "Reasoning about continuations with control effects",
  volume =       "24",
  x-doi =        "10.1145/73141.74837",
  x-issn =       "0362-1340",
  x-month =      jul,
  x-url =        "http://dx.doi.org/10.1145/73141.74837",
  xpages =       "218--226",
  year =         "1989",
}

@Article{Steele1999Growing,
  author =       "Guy L. Steele",
  citeulike-article-id = "4975",
  citeulike-linkout-0 = "http://portal.acm.org/citation.cfm?id=609197",
  citeulike-linkout-1 = "http://dx.doi.org/10.1023/a:1010085415024",
  date-added =   "2005-01-10 16:16:18",
  journal =      "Higher Order Symbol. Comput.",
  number =       "3",
  priority =     "0",
  publisher =    "Kluwer Academic Publishers",
  title =        "Growing a Language",
  volume =       "12",
  x-abstract =   "An abstract is not available.",
  x-address =    "Hingham, MA, USA",
  x-doi =        "10.1023/a:1010085415024",
  x-issn =       "1388-3690",
  x-month =      oct,
  x-url =        "http://dx.doi.org/10.1023/a:1010085415024",
  xpages =       "221--236",
  year =         "1999",
}

@InBook{Wadler1989Theorems,
  author =       "Philip Wadler",
  booktitle =    "Proceedings 4th Int.\ Conf.\ on Funct.\ Prog.\
                 Languages and Computer Arch., FPCA'89, London, UK,
                 11--13 Sept 1989",
  citeulike-article-id = "70811",
  citeulike-linkout-0 = "http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.38.9875",
  date-added =   "2005-01-10 16:15:32",
  keywords =     "haskell, programming, type-theory",
  priority =     "0",
  publisher =    "ACM Press",
  title =        "Theorems for Free!",
  x-abstract =   "From the type of a polymorphic function we can derive
                 a theorem that it satisfies. Every function of the same
                 type satisfies the same theorem. This provides a free
                 source of useful theorems, courtesy of Reynolds'
                 abstraction theorem for the polymorphic lambda
                 calculus. 1 Introduction Write down the definition of a
                 polymorphic function on a piece of paper. Tell me its
                 type, but be careful not to let me see the function's
                 definition. I will tell you a theorem that the function
                 satisfies. The...",
  x-address =    "New York",
  x-url =        "http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.38.9875",
  xpages =       "347--359",
  year =         "1989",
}

@Article{Wadler1987Critique,
  author =       "P. Wadler",
  citeulike-article-id = "72198",
  citeulike-linkout-0 = "http://portal.acm.org/citation.cfm?id=24706",
  citeulike-linkout-1 = "http://dx.doi.org/10.1145/24697.24706",
  date-added =   "2005-01-10 16:07:02",
  journal =      "SIGPLAN Not.",
  keywords =     "education, scheme",
  number =       "3",
  priority =     "0",
  publisher =    "ACM",
  title =        "A critique of Abelson and Sussman or why calculating
                 is better than scheming",
  volume =       "22",
  x-abstract =   "An abstract is not available.",
  x-address =    "New York, NY, USA",
  x-doi =        "10.1145/24697.24706",
  x-issn =       "0362-1340",
  x-month =      mar,
  x-url =        "http://dx.doi.org/10.1145/24697.24706",
  xpages =       "83--94",
  year =         "1987",
}

@Misc{Graunke2003Modeling,
  author =       "P. Graunke and R. Findler and S. Krishnamurthi and M.
                 Felleisen",
  citeulike-article-id = "71748",
  citeulike-linkout-0 = "http://citeseer.ist.psu.edu/graunke03modeling.html",
  citeulike-linkout-1 = "http://citeseer.lcs.mit.edu/graunke03modeling.html",
  citeulike-linkout-2 = "http://citeseer.ifi.unizh.ch/graunke03modeling.html",
  citeulike-linkout-3 = "http://citeseer.comp.nus.edu.sg/graunke03modeling.html",
  date-added =   "2005-01-03 17:14:39",
  keywords =     "continuations, plt, web",
  priority =     "3",
  title =        "Modeling Web interactions",
  x-abstract =   "Programmers confront a minefield when they design
                 interactive Web programs. Web interactions take place
                 via Web browsers. With browsers, consumers can
                 whimsically navigate among the various stages of a
                 dialog and can thus confuse the most sophisticated
                 corporate Web sites. In turn, Web services can fault in
                 frustrating and inexplicable ways. The quickening
                 transition from Web scripts to Web services lends these
                 problems immediacy.",
  x-url =        "http://citeseer.ist.psu.edu/graunke03modeling.html",
  year =         "2003",
}

@Proceedings{Lamping1993Typing,
  author =       "John Lamping",
  booktitle =    "OOPSLA '93: Proceedings of the eighth annual
                 conference on Object-oriented programming systems,
                 languages, and applications",
  citeulike-article-id = "4317",
  citeulike-linkout-0 = "http://portal.acm.org/citation.cfm?id=165891",
  citeulike-linkout-1 = "http://dx.doi.org/10.1145/165854.165891",
  date-added =   "2004-12-20 22:28:46",
  keywords =     "honu, oop",
  number =       "10",
  priority =     "0",
  publisher =    "ACM Press",
  title =        "Typing the specialization interface",
  volume =       "28",
  x-doi =        "10.1145/165854.165891",
  x-issn =       "0362-1340",
  x-month =      oct,
  x-url =        "http://dx.doi.org/10.1145/165854.165891",
  xpages =       "201--214",
  year =         "1993",
}

@InProceedings{Flanagan1995Semantics,
  author =       "Cormac Flanagan and Matthias Felleisen",
  booktitle =    "POPL '95: Proceedings of the 22nd ACM SIGPLAN-SIGACT
                 symposium on Principles of programming languages",
  citeulike-article-id = "4158",
  citeulike-linkout-0 = "http://portal.acm.org/citation.cfm?id=199484",
  citeulike-linkout-1 = "http://dx.doi.org/10.1145/199448.199484",
  date-added =   "2004-12-17 23:46:22",
  keywords =     "christmas-reading, static-analysis",
  location =     "San Francisco, California, United States",
  priority =     "2",
  publisher =    "ACM",
  title =        "The semantics of future and its use in program
                 optimization",
  x-abstract =   "The future annotations of {MultiLisp} provide a simple
                 method for taming the implicit parallelism of
                 functional programs. Past research concerning future s
                 has focused on implementation issues. In this paper, we
                 present a series of operational semantics for an
                 idealized functional language with future s with
                 varying degrees of intensionality. We develop a
                 set-based analysis algorithm from the most intensional
                 semantics, and use that algorithm to perform touch
                 optimization on programs. Experiments with the Gambit
                 compiler indicates that this optimization substantially
                 reduces program execution times.",
  x-address =    "New York, NY, USA",
  x-doi =        "10.1145/199448.199484",
  x-isbn =       "0-89791-692-1",
  x-url =        "http://dx.doi.org/10.1145/199448.199484",
  xpages =       "209--220",
  year =         "1995",
}

@Article{Palsberg1995Closure,
  author =       "Jens Palsberg",
  citeulike-article-id = "4157",
  citeulike-linkout-0 = "http://portal.acm.org/citation.cfm?id=201001",
  citeulike-linkout-1 = "http://dx.doi.org/10.1145/200994.201001",
  date-added =   "2004-12-17 23:44:36",
  journal =      "ACM Trans. Program. Lang. Syst.",
  keywords =     "christmas-reading, static-analysis",
  number =       "1",
  priority =     "0",
  publisher =    "ACM",
  title =        "Closure analysis in constraint form",
  volume =       "17",
  x-abstract =   "Flow analyses of untyped higher-order functional
                 programs have in the past decade been presented by
                 Ayers, Bondorf, Consel, Jones, Heintze, Sestoft,
                 Shivers, Steckler, Wand, and others. The analyses are
                 usually defined as abstract interpretations and are
                 used for rather different tasks such as type recovery,
                 globalization, and binding-time analysis. The analyses
                 all contain a global closure analysis that computes
                 information about higher-order control-flow. Sestoft
                 proved in 1989 and 1991 that closure analysis is
                 correct with respect to call-by-name and call-by-value
                 semantics, but it remained open if correctness holds
                 for arbitrary {beta-reduction.This} article answers the
                 question; both closure analysis and others are correct
                 with respect to arbitrary beta-reduction. We also prove
                 a subject-reduction result: closure information is
                 still valid after beta-reduction. The core of our proof
                 technique is to define closure analysis using a
                 constraint system. The constraint system is equivalent
                 to the closure analysis of Bondorf, which in turn is
                 based on Sestoft's.",
  x-address =    "New York, NY, USA",
  x-doi =        "10.1145/200994.201001",
  x-issn =       "0164-0925",
  x-month =      jan,
  x-url =        "http://dx.doi.org/10.1145/200994.201001",
  xpages =       "47--62",
  year =         "1995",
}

@InProceedings{Flanagan1996Catching,
  author =       "Cormac Flanagan and Matthew Flatt and Shriram
                 Krishnamurthi and Stephanie Weirich and Matthias
                 Felleisen",
  booktitle =    "PLDI '96: Proceedings of the ACM SIGPLAN 1996
                 conference on Programming language design and
                 implementation",
  citeulike-article-id = "4156",
  citeulike-linkout-0 = "http://portal.acm.org/citation.cfm?id=231387",
  citeulike-linkout-1 = "http://dx.doi.org/10.1145/231379.231387",
  date-added =   "2004-12-17 23:44:26",
  keywords =     "christmas-reading, static-analysis",
  location =     "Philadelphia, Pennsylvania, United States",
  number =       "5",
  priority =     "0",
  publisher =    "ACM",
  title =        "Catching bugs in the web of program invariants",
  volume =       "31",
  x-abstract =   "{MrSpidey} is a user-friendly, interactive static
                 debugger for Scheme. A static debugger supplements the
                 standard debugger by analyzing the program and
                 pinpointing those program operations that may cause
                 run-time errors such as dereferencing the null pointer
                 or applying non-functions. The program analysis of
                 {MrSpidey} computes value set descriptions for each
                 term in the program and constructs a value flow graph
                 connecting the set descriptions. Using the set
                 descriptions, {MrSpidey} can identify and highlight
                 potentially erroneous program operations, whose cause
                 the programmer can then explore by selectively exposing
                 portions of the value flow graph.",
  x-address =    "New York, NY, USA",
  x-doi =        "10.1145/231379.231387",
  x-isbn =       "0-89791-795-2",
  x-issn =       "0362-1340",
  x-month =      may,
  x-url =        "http://dx.doi.org/10.1145/231379.231387",
  xpages =       "23--32",
  year =         "1996",
}

@Article{Flanagan1999Componential,
  author =       "Cormac Flanagan and Matthias Felleisen",
  citeulike-article-id = "4155",
  citeulike-linkout-0 = "http://portal.acm.org/citation.cfm?id=316703",
  citeulike-linkout-1 = "http://dx.doi.org/10.1145/316686.316703",
  date-added =   "2004-12-17 23:43:02",
  journal =      "ACM Trans. Program. Lang. Syst.",
  keywords =     "christmas-reading, static-analysis",
  number =       "2",
  priority =     "2",
  publisher =    "ACM",
  title =        "Componential set-based analysis",
  volume =       "21",
  x-abstract =   "Set-based analysis ({SBA}) produces good predictions
                 about the behavior of functional and object-oriented
                 programs. The analysis proceeds by inferring
                 constraints that characterize the data flow
                 relationships of the analyzed program. Experiences with
                 {MrSpidey}, a static debugger based on {SBA}, indicate
                 that {SBA} can adequately deal with programs of up to a
                 couple of thousand lines of code. {SBA} fails, however,
                 to cope with larger programs because it generates
                 systems of constraints that are at least linear, and
                 possibility quadratic, in the size of the analyzed
                 program. This article presents theoretical and
                 practical results concerning methods for reducing the
                 size of constraint systems. The theoretical results
                 include of proof-theoretic characterization of the
                 observable behavior of constraint systems for program
                 components, and a complete algorithm for deciding the
                 observable equivalence of constraint systems. In the
                 course of this development we establish a close
                 connection between the observable equivalence of
                 constraint systems and the equivalence of regular-tree
                 grammars. We then exploit this connection to adapt a
                 variety of algoirthms for simplifying grammars to the
                 problem of simplifying constraint systems. Based on the
                 resulting algorithms, we have developed componential
                 set-based analysis, a modular and polymorphic variant
                 of {SBA}. Experimental results verify the effectiveness
                 of the simplification algorithms and the componential
                 analysis. The simplified constraint systems are
                 typically an order of magnitude smaller than the
                 original systems. These reductions in size produce
                 significant gains in the speed of the analysis.",
  x-address =    "New York, NY, USA",
  x-doi =        "10.1145/316686.316703",
  x-issn =       "0164-0925",
  x-month =      mar,
  x-url =        "http://dx.doi.org/10.1145/316686.316703",
  xpages =       "370--416",
  year =         "1999",
}

@Proceedings{Flanagan1997Componential,
  author =       "Cormac Flanagan and Matthias Felleisen",
  booktitle =    "PLDI '97: Proceedings of the ACM SIGPLAN 1997
                 conference on Programming language design and
                 implementation",
  citeulike-article-id = "4154",
  citeulike-linkout-0 = "http://portal.acm.org/citation.cfm?id=258937",
  citeulike-linkout-1 = "http://dx.doi.org/10.1145/258915.258937",
  date-added =   "2004-12-17 23:42:54",
  keywords =     "christmas-reading, static-analysis",
  number =       "5",
  priority =     "0",
  publisher =    "ACM Press",
  title =        "Componential set-based analysis",
  volume =       "32",
  x-doi =        "10.1145/258915.258937",
  x-isbn =       "0897919076",
  x-month =      may,
  x-url =        "http://dx.doi.org/10.1145/258915.258937",
  xpages =       "235--248",
  year =         "1997",
}

@Article{Aiken1999Introduction,
  author =       "Alexander Aiken",
  citeulike-article-id = "4153",
  citeulike-linkout-0 = "http://portal.acm.org/citation.cfm?id=339897",
  citeulike-linkout-1 = "http://dx.doi.org/10.1016/s0167-6423(99)00007-6",
  date-added =   "2004-12-17 23:42:01",
  journal =      "Sci. Comput. Program.",
  keywords =     "christmas-reading, static-analysis",
  number =       "2-3",
  priority =     "0",
  publisher =    "Elsevier North-Holland, Inc.",
  title =        "Introduction to set constraint-based program
                 analysis",
  volume =       "35",
  x-abstract =   "An abstract is not available.",
  x-address =    "Amsterdam, The Netherlands, The Netherlands",
  x-doi =        "10.1016/s0167-6423(99)00007-6",
  x-issn =       "0167-6423",
  x-month =      nov,
  x-url =        "http://dx.doi.org/10.1016/s0167-6423(99)00007-6",
  xpages =       "79--111",
  year =         "1999",
}

@Article{Heintze1994Setbased,
  author =       "Nevin Heintze",
  booktitle =    "Proceedings of the 1994 ACM conference on LISP and
                 functional programming",
  citeulike-article-id = "4152",
  citeulike-linkout-0 = "http://portal.acm.org/citation.cfm?id=182495",
  citeulike-linkout-1 = "http://dx.doi.org/10.1145/182409.182495",
  date-added =   "2004-12-17 23:26:03",
  journal =      "SIGPLAN Lisp Pointers",
  keywords =     "christmas-reading, static-analysis",
  location =     "Orlando, Florida, United States",
  number =       "3",
  priority =     "3",
  publisher =    "ACM",
  title =        "Set-based analysis of {ML} programs",
  volume =       "VII",
  x-abstract =   "Reasoning about program variables as sets of ”
                 values” leads to a simple, accurate and intuitively
                 appealing notion of program approximation. This paper
                 presents approach for the compile-time analysis of {ML}
                 programs. To develop the core ideas of the analysis, we
                 consider a simple untyped call-by-value functional
                 language. Starting with an operational semantics for
                 the language, we develop an approximate ”
                 set-based” operational semantics, which formalizes
                 the intuition of treating program variables as sets.
                 The key result of the paper is an O(n3) algorithm for
                 computing the set based approximation of a program. We
                 then extend this analysis in a natural way to deal with
                 arrays, arithmetic, exceptions and continuations. We
                 briefly describe our experience with an implementation
                 of this analysis for {ML} programs.",
  x-address =    "New York, NY, USA",
  x-doi =        "10.1145/182409.182495",
  x-isbn =       "0-89791-643-3",
  x-issn =       "1045-3563",
  x-month =      jul,
  x-series =     "LFP '94",
  x-url =        "http://dx.doi.org/10.1145/182409.182495",
  xpages =       "306--317",
  year =         "1994",
}

@InProceedings{Lucassen1988Polymorphic,
  author =       "J. M. Lucassen and D. K. Gifford",
  booktitle =    "Proceedings of the 15th ACM SIGPLAN-SIGACT symposium
                 on Principles of programming languages",
  citeulike-article-id = "3530",
  citeulike-linkout-0 = "http://portal.acm.org/citation.cfm?id=73564",
  citeulike-linkout-1 = "http://dx.doi.org/10.1145/73560.73564",
  date-added =   "2004-12-16 16:44:03",
  keywords =     "effects, fx",
  location =     "San Diego, California, United States",
  priority =     "0",
  publisher =    "ACM",
  title =        "Polymorphic effect systems",
  x-abstract =   "We present a new approach to programming languages for
                 parallel computers that uses an effect system to
                 discover expression scheduling constraints. This effect
                 system is part of a 'kinded' type system with three
                 base kinds: types, which describe the value that an
                 expression may return; effects, which describe the
                 side-effects that an expression may have; and regions,
                 which describe the area of the store in which
                 side-effects may occur. Types, effects and regions are
                 collectively called {descriptions.Expressions} can be
                 abstracted over any kind of description variable --
                 this permits type, effect and region polymorphism.
                 Unobservable side-effects can be masked by the effect
                 system; an effect soundness property guarantees that
                 the effects computed statically by the effect system
                 are a conservative approximation of the actual
                 side-effects that a given expression may {have.The}
                 effect system we describe performs certain kinds of
                 side-effect analysis that were not previously feasible.
                 Experimental data from the programming language {FX}
                 indicate that an effect system can be used effectively
                 to compile programs for parallel computers.",
  x-address =    "New York, NY, USA",
  x-doi =        "10.1145/73560.73564",
  x-isbn =       "0-89791-252-7",
  x-series =     "POPL '88",
  x-url =        "http://dx.doi.org/10.1145/73560.73564",
  xpages =       "47--57",
  year =         "1988",
}

@Article{FlattProgrammers,
  author =       "Matthew Flatt and Shriram Krishnamurthi and Matthias
                 Felleisen",
  citeulike-article-id = "3293",
  citeulike-linkout-0 = "http://www.metapress.com/content/5ND4J38F3GALFRJC",
  date-added =   "2004-12-10 18:22:32",
  journal =      "Lecture Notes in Computer Science",
  keywords =     "java, plt, semantics",
  priority =     "4",
  publisher =    "Springer-Verlag Heidelberg",
  title =        "A Programmer's Reduction Semantics for Classes and
                 Mixins",
  x-abstract =   "While class-based object-oriented programming
                 languages provide a flexible mechanism for re-using and
                 managing related pieces of code, they typically lack
                 linguistic facilities for specifying a uniform
                 extension of many classes with one set of fields and
                 methods. As a result, programmers are unable to express
                 certain abstractions over classes. In this paper we
                 develop a model of class-to-class functions that we
                 refer to as mixins. A mixin function maps a class to an
                 extended class by adding or overriding fields and
                 methods. Programming with mixins is similar to
                 programming with single inheritance classes, but mixins
                 more directly encourage programming to interfaces. The
                 paper develops these ideas within the context of Java.
                 The results are an intuitive model of an essential Java
                 subset; an extension that explains and models mixins;
                 and type soundness theorems for these languages.",
  x-url =        "http://www.metapress.com/content/5ND4J38F3GALFRJC",
}

@Article{ClementsTailRecursive,
  author =       "John Clements and Matthias Felleisen",
  citeulike-article-id = "3292",
  citeulike-linkout-0 = "http://www.metapress.com/content/5UF8U8T0KKLDCKU6",
  date-added =   "2004-12-10 18:21:45",
  journal =      "Lecture Notes in Computer Science",
  keywords =     "plt, scheme",
  priority =     "3",
  publisher =    "Springer-Verlag Heidelberg",
  title =        "A {Tail-Recursive} Semantics for Stack Inspections",
  x-abstract =   "Security folklore holds that a security mechanism
                 based on stack inspection is incompatible with a global
                 tail call optimization policy. An implementation of
                 such a language may have to allocate memory for a
                 source-code tail call, and a program that uses only
                 tail calls (and no other memory-allocating construct)
                 may nevertheless exhaust the available memory. In this
                 paper, we prove this widely held belief wrong. We
                 exhibit an abstract machine for a language with
                 security stack inspection whose space consumption
                 function is equivalent to that of the canonical tail
                 call optimizing abstract machine. Our machine is
                 surprisingly simple and suggests that tail-calls are as
                 easy to implement in a security setting as they are in
                 a conventional one.",
  x-url =        "http://www.metapress.com/content/5UF8U8T0KKLDCKU6",
  xpages =       "22--37",
}

@Article{ClementsModeling,
  author =       "John Clements and Matthew Flatt and Matthias
                 Felleisen",
  citeulike-article-id = "3291",
  citeulike-linkout-0 = "http://www.metapress.com/content/X5VLTM17EEGQKGLA",
  date-added =   "2004-12-10 18:21:10",
  journal =      "Lecture Notes in Computer Science",
  keywords =     "plt, scheme, stepper",
  priority =     "2",
  publisher =    "Springer-Verlag Heidelberg",
  title =        "Modeling an Algebraic Stepper",
  x-abstract =   "Programmers rely on the correctness of the tools in
                 their programming environments. In the past,
                 semanticists have studied the correctness of compilers
                 and compiler analyses, which are the most important
                 tools. In this paper, we make the case that other
                 tools, such as debuggers and steppers, deserve semantic
                 models, too, and that using these models can help in
                 developing these tools. Our concrete starting point is
                 the algebraic stepper in {DrScheme}, our Scheme
                 programming environment. The algebraic stepper explains
                 a Scheme computation in terms of an algebraic rewriting
                 of the program text. A program is rewritten until it is
                 in a canonical form (if it has one). The canonical form
                 is the final result. The stepper operates within the
                 existing evaluator, by placing breakpoints and by
                 reconstructing source expressions from source
                 information placed on the stack. This approach raises
                 two questions. First, do the run-time breakpoints
                 correspond to the steps of the reduction semantics?
                 Second, does the debugging mechanism insert enough
                 information to reconstruct source expressions? To
                 answer these questions, we develop a high-level
                 semantic model of the extended compiler and run-time
                 machinery. Rather than modeling the evaluation as a
                 low-level machine, we model the relevant low-level
                 features of the stepper's implementation in a
                 high-level reduction semantics. We expect the approach
                 to apply to other semantics-based tools.",
  x-url =        "http://www.metapress.com/content/X5VLTM17EEGQKGLA",
}

@Misc{Flatt2002Composable,
  author =       "M. Flatt",
  citeulike-article-id = "2111",
  citeulike-linkout-0 = "http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.11.4008",
  date-added =   "2004-12-07 03:30:39",
  keywords =     "macros, modules, plt, scheme",
  priority =     "0",
  title =        "Composable and compilable macros: You want it when",
  x-abstract =   "Many macro systems, especially for Lisp and Scheme,
                 allow macro transformers to perform general
                 computation. Moreover, the language for implementing
                 compile-time macro transformers is usually the same as
                 the language for implementing run-time functions. As a
                 side effect of this sharing, implementations tend to
                 allow the mingling of compile-time values and run-time
                 values, as well as values from separate compilations.
                 Such mingling breaks programming tools that must parse
                 code without executing...",
  x-url =        "http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.11.4008",
  year =         "2002",
}

@Proceedings{Weise1993Programmable,
  author =       "Daniel Weise and Roger F. Crew",
  booktitle =    "SIGPLAN Conference on Programming Language Design and
                 Implementation",
  citeulike-article-id = "2108",
  citeulike-linkout-0 = "http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.22.5371",
  date-added =   "2004-12-07 03:29:38",
  keywords =     "macros",
  priority =     "2",
  title =        "Programmable Syntax Macros",
  x-abstract =   "Lisp has shown that a programmable syntax macro system
                 acts as an adjunct to the compiler that gives the
                 programmer important and powerful abstraction
                 facilities not provided by the language. Unlike simple
                 token substitution macros, such as are provided by
                 {CPP} \#the C preprocessor\#, syntax macros operate on
                 Abstract Syntax Trees \#{ASTs}\#. Programmable syntax
                 macro systems have not yet been developed for
                 syntactically rich languages such as C because rich
                 concrete syntax requires the manual...",
  x-url =        "http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.22.5371",
  xpages =       "156--165",
  year =         "1993",
}

@InProceedings{MacQueen1984Modules,
  author =       "David MacQueen",
  booktitle =    "Proceedings of the 1984 ACM Symposium on LISP and
                 functional programming",
  citeulike-article-id = "1407",
  citeulike-linkout-0 = "http://portal.acm.org/citation.cfm?id=802036",
  citeulike-linkout-1 = "http://dx.doi.org/10.1145/800055.802036",
  date-added =   "2004-12-02 00:23:46",
  keywords =     "ml, modules",
  location =     "Austin, Texas, United States",
  priority =     "2",
  publisher =    "ACM",
  title =        "Modules for standard {ML}",
  x-abstract =   "The functional programming language {ML} has been
                 undergoing a thorough redesign during the past year,
                 and the module facility described here has been
                 proposed as part of the revised language, now called
                 Standard {ML}. The design has three main goals: (1) to
                 facilitate the structuring of large {ML} programs; (2)
                 to support separate compilation and generic library
                 units; and (3) to employ new ideas in the semantics of
                 data types to extend the power of {ML}'s polymorphic
                 type system. It is based on concepts inherent in the
                 structure of {ML}, primarily the notions of a
                 declaration, its type signature, and the environment
                 that it denotes.",
  x-address =    "New York, NY, USA",
  x-doi =        "10.1145/800055.802036",
  x-isbn =       "0-89791-142-3",
  x-series =     "LFP '84",
  x-url =        "http://dx.doi.org/10.1145/800055.802036",
  xpages =       "198--207",
  year =         "1984",
}

@InProceedings{MacQueen1986Using,
  author =       "David B. MacQueen",
  booktitle =    "Proceedings of the 13th ACM SIGACT-SIGPLAN symposium
                 on Principles of programming languages",
  citeulike-article-id = "1406",
  citeulike-linkout-0 = "http://portal.acm.org/citation.cfm?id=512644.512670",
  citeulike-linkout-1 = "http://dx.doi.org/10.1145/512644.512670",
  date-added =   "2004-12-02 00:23:39",
  keywords =     "ml, modules, types",
  location =     "St. Petersburg Beach, Florida",
  priority =     "2",
  publisher =    "ACM",
  title =        "Using dependent types to express modular structure",
  x-abstract =   "Writing any large program poses difficult problems of
                 organization. In many modern programming languages
                 these problems are addressed by special linguistic
                 constructs, variously known as modules, packages, or
                 clusters, which provide for partitioning programs into
                 manageable components and for securely combining these
                 components to form complete programs. Some general
                 purpose components are able to take on a life of their
                 own, being separately compiled and stored in libraries
                 of generic, reusable program units. Usually modularity
                 constructs also support some form of information
                 hiding, such as {"}abstract data types.{"}
                 {"}Programming in the large{"} is concerned with using
                 such constructs to impose structure on large programs,
                 in contrast to {"}programming in the small{"}, which
                 deals with the detailed implementation of algorithms in
                 terms of data structures and control constructs. Our
                 goal here is to examine some of the proposed linguistic
                 notions with respect to how they meet the pragmatic
                 requirements of programming in the large.",
  x-address =    "New York, NY, USA",
  x-doi =        "10.1145/512644.512670",
  x-series =     "POPL '86",
  x-url =        "http://dx.doi.org/10.1145/512644.512670",
  xpages =       "277--286",
  year =         "1986",
}

@Proceedings{Appel1987Standard,
  author =       "Andrew W. Appel and David B. Macqueen",
  booktitle =    "Proc. of a conference on Functional programming
                 languages and computer architecture",
  citeulike-article-id = "1405",
  citeulike-linkout-0 = "http://portal.acm.org/citation.cfm?id=36583.36600",
  date-added =   "2004-12-02 00:23:31",
  keywords =     "compiler, ml",
  priority =     "2",
  publisher =    "Springer-Verlag",
  title =        "A standard {ML} compiler",
  x-isbn =       "0387183175",
  x-url =        "http://portal.acm.org/citation.cfm?id=36583.36600",
  xpages =       "301--324",
  year =         "1987",
}

@Proceedings{Cardelli1994Extensible,
  author =       "Luca Cardelli and Florian Matthes and Mart\&\#237;n
                 Abadi",
  booktitle =    "Proceedings of the Fourth International Workshop on
                 Database Programming Languages - Object Models and
                 Languages",
  citeulike-article-id = "1404",
  citeulike-linkout-0 = "http://portal.acm.org/citation.cfm?id=754352",
  date-added =   "2004-12-02 00:14:19",
  keywords =     "macros",
  priority =     "2",
  publisher =    "Springer-Verlag",
  title =        "Extensible Grammars for Language Specialization",
  x-isbn =       "3540198539",
  x-url =        "http://portal.acm.org/citation.cfm?id=754352",
  xpages =       "11--31",
  year =         "1994",
}

@Article{Ganz2001Macros,
  author =       "Steven E. Ganz and Amr Sabry and Walid Taha",
  booktitle =    "ICFP '01: Proceedings of the sixth ACM SIGPLAN
                 international conference on Functional programming",
  citeulike-article-id = "1403",
  citeulike-linkout-0 = "http://portal.acm.org/citation.cfm?id=507646",
  citeulike-linkout-1 = "http://dx.doi.org/10.1145/507635.507646",
  date-added =   "2004-12-02 00:05:24",
  journal =      "SIGPLAN Not.",
  keywords =     "macros, ml, types",
  location =     "Florence, Italy",
  number =       "10",
  priority =     "0",
  publisher =    "ACM",
  title =        "Macros as multi-stage computations: type-safe,
                 generative, binding macros in {MacroML}",
  volume =       "36",
  x-abstract =   "With few exceptions, macros have traditionally been
                 viewed as operations on syntax trees or even on plain
                 strings. This view makes macros seem ad hoc, and is at
                 odds with two desirable features of contemporary typed
                 functional languages: static typing and static scoping.
                 At a deeper level, there is a need for a simple, usable
                 semantics for macros. This paper argues that these
                 problems can be addressed by formally viewing macros as
                 multi-stage computations. This view eliminates the need
                 for freshness conditions and tests on variable names,
                 and provides a compositional interpretation that can
                 serve as a basis for designing a sound type system for
                 languages supporting macros, or even for compilation.
                 To illustrate our approach, we develop and present
                 {MacroML}, an extension of {ML} that supports inlining,
                 recursive macros, and the definition of new binding
                 constructs. The latter is subtle, and is the most novel
                 addition in a statically typed setting. The semantics
                 of a core subset of {MacroML} is given by an
                 interpretation into {MetaML}, a statically-typed
                 multi-stage programming language. It is then easy to
                 show that {MacroML} is stage- and type-safe: macro
                 expansion does not depend on runtime evaluation, and
                 both stages do not {"}go wrong.",
  x-address =    "New York, NY, USA",
  x-doi =        "10.1145/507635.507646",
  x-isbn =       "1-58113-415-0",
  x-issn =       "0362-1340",
  x-month =      oct,
  x-url =        "http://dx.doi.org/10.1145/507635.507646",
  xpages =       "74--85",
  year =         "2001",
}

@Proceedings{Findler1997DrScheme,
  author =       "Robert B. Findler and Cormac Flanagan and Matthew
                 Flatt and Shriram Krishnamurthi and Matthias
                 Felleisen",
  booktitle =    "Proceedings of the9th International Symposium on
                 Programming Languages: Implementations, Logics, and
                 Programs",
  citeulike-article-id = "1402",
  citeulike-linkout-0 = "http://portal.acm.org/citation.cfm?id=692958",
  date-added =   "2004-12-02 00:05:09",
  keywords =     "education, plt, program-environment, scheme",
  priority =     "2",
  publisher =    "Springer-Verlag",
  title =        "{DrScheme}: {A} Pedagogic Programming Environment for
                 Scheme",
  x-isbn =       "3540633987",
  x-url =        "http://portal.acm.org/citation.cfm?id=692958",
  xpages =       "369--388",
  year =         "1997",
}

@Article{Wright1997Practical,
  author =       "Andrew K. Wright and Robert Cartwright",
  citeulike-article-id = "1400",
  citeulike-linkout-0 = "http://portal.acm.org/citation.cfm?id=239917",
  citeulike-linkout-1 = "http://dx.doi.org/10.1145/239912.239917",
  date-added =   "2004-12-02 00:04:37",
  journal =      "ACM Trans. Program. Lang. Syst.",
  keywords =     "scheme, static-analysis",
  number =       "1",
  priority =     "2",
  publisher =    "ACM",
  title =        "A practical soft type system for scheme",
  volume =       "19",
  x-abstract =   "A soft type system infers types for the procedures and
                 data structures of dynamically typed programs. Like
                 conventional static types, soft types express program
                 invariants and thereby provide valuable information for
                 program optimization and debugging. A soft type checker
                 uses the types inferred by a soft type system to
                 eliminate run-time checks that are provably
                 unnecessary; any remaining run-time checks are flagged
                 as potential program errors. Soft Scheme is a practical
                 soft type checker for {R4RS} Scheme. Its underlying
                 type system generalizes conventional {Hindley-Milner}
                 type inference by incorporating recursive types and a
                 limited form of union type. Soft Scheme accommodates
                 all of {R4RS} Scheme including uncurried procedures of
                 fixed and variable arity, assignment, and
                 continuations.",
  x-address =    "New York, NY, USA",
  x-doi =        "10.1145/239912.239917",
  x-issn =       "0164-0925",
  x-month =      jan,
  x-url =        "http://dx.doi.org/10.1145/239912.239917",
  xpages =       "87--152",
  year =         "1997",
}

@Proceedings{Goldberg2004Super,
  author =       "David S. Goldberg and Robert B. Findler and Matthew
                 Flatt",
  booktitle =    "Proceedings of the 19th annual ACM SIGPLAN Conference
                 on Object-oriented programming, systems, languages, and
                 applications",
  citeulike-article-id = "1399",
  citeulike-linkout-0 = "http://portal.acm.org/citation.cfm?id=1028987",
  citeulike-linkout-1 = "http://dx.doi.org/10.1145/1028976.1028987",
  date-added =   "2004-12-02 00:04:26",
  keywords =     "object-oriented, plt",
  priority =     "0",
  publisher =    "ACM Press",
  title =        "Super and inner: together at last!",
  x-doi =        "10.1145/1028976.1028987",
  x-isbn =       "1581138319",
  x-url =        "http://dx.doi.org/10.1145/1028976.1028987",
  xpages =       "116--129",
  year =         "2004",
}

@Article{Felleisen2004Structure,
  author =       "Matthias Felleisen and Robert B. Findler and Matthew
                 Flatt and Shriram Krishnamurthi",
  citeulike-article-id = "1398",
  citeulike-linkout-0 = "http://portal.acm.org/citation.cfm?id=997813",
  citeulike-linkout-1 = "http://journals.cambridge.org/action/displayAbstract?fromPage=online\&aid=227683",
  citeulike-linkout-2 = "http://dx.doi.org/10.1017/s0956796804005076",
  date-added =   "2004-12-02 00:04:12",
  journal =      "Journal of Functional Programming",
  keywords =     "education, plt, scheme",
  number =       "4",
  priority =     "0",
  publisher =    "Cambridge University Press",
  title =        "The structure and interpretation of the computer
                 science curriculum",
  volume =       "14",
  x-abstract =   "Twenty years ago Abelson and Sussman\&apos;s Structure
                 and Interpretation of Computer Programs radically
                 changed the intellectual landscape of introductory
                 computing courses. Instead of teaching some currently
                 fashionable programming language, it employed Scheme
                 and functional programming to teach important ideas.
                 Introductory courses based on the book showed up around
                 the world and made Scheme and functional programming
                 popular. Unfortunately, these courses quickly
                 disappeared again due to shortcomings of the book and
                 the whimsies of Scheme. Worse, the experiment left
                 people with a bad impression of Scheme and functional
                 programming in general. In this pearl, we propose an
                 alternative role for functional programming in the
                 first-year curriculum. Specifically, we present a
                 framework for discussing the first-year curriculum and,
                 based on it, the design rationale for our book and
                 course, dubbed How to Design Programs. The approach
                 emphasizes the systematic design of programs.
                 Experience shows that it works extremely well as a
                 preparation for a course on object-oriented
                 programming.",
  x-address =    "New York, NY, USA",
  x-doi =        "10.1017/s0956796804005076",
  x-issn =       "1469-7653",
  x-month =      jun,
  x-url =        "http://dx.doi.org/10.1017/s0956796804005076",
  xpages =       "365--378",
  year =         "2004",
}

@Proceedings{Flatt2004Killsafe,
  author =       "Matthew Flatt and Robert B. Findler",
  booktitle =    "Proceedings of the ACM SIGPLAN 2004 conference on
                 Programming language design and implementation",
  citeulike-article-id = "1397",
  citeulike-linkout-0 = "http://portal.acm.org/citation.cfm?id=996849",
  citeulike-linkout-1 = "http://dx.doi.org/10.1145/996841.996849",
  date-added =   "2004-12-02 00:04:03",
  keywords =     "concurrency, plt, scheme",
  number =       "6",
  priority =     "1",
  publisher =    "ACM Press",
  title =        "Kill-safe synchronization abstractions",
  volume =       "39",
  x-doi =        "10.1145/996841.996849",
  x-isbn =       "1581138075",
  x-month =      may,
  x-url =        "http://dx.doi.org/10.1145/996841.996849",
  xpages =       "47--58",
  year =         "2004",
}

@InProceedings{Flatt1999Programming,
  author =       "Matthew Flatt and Robert B. Findler and Shriram
                 Krishnamurthi and Matthias Felleisen",
  booktitle =    "Proceedings of the Fourth ACM SIGPLAN International
                 Conference on Functional Programming",
  citeulike-article-id = "1401",
  citeulike-linkout-0 = "http://portal.acm.org/citation.cfm?id=317793",
  citeulike-linkout-1 = "http://dx.doi.org/10.1145/317636.317793",
  date-added =   "2004-12-02 00:03:43",
  keywords =     "plt, program-environment, scheme",
  location =     "Paris, France",
  number =       "9",
  priority =     "0",
  publisher =    "ACM",
  title =        "Programming Languages As Operating Systems (or Revenge
                 of the Son of the Lisp Machine)",
  volume =       "34",
  x-abstract =   "The {MrEd} virtual machine serves both as the
                 implementation platform for the {DrScheme} programming
                 environment, and as the underlying Scheme engine for
                 executing expressions and programs entered into
                 {DrScheme}'s read-eval-print loop. We describe the key
                 elements of the {MrEd} virtual machine for building a
                 programming environment, and we step through the
                 implementation of a miniature version of {DrScheme} in
                 {MrEd}. More generally, we show how {MrEd} defines a
                 high-level operating system for graphical programs.",
  x-address =    "New York, NY, USA",
  x-doi =        "10.1145/317636.317793",
  x-isbn =       "1-58113-111-9",
  x-month =      sep,
  x-series =     "ICFP '99",
  x-url =        "http://dx.doi.org/10.1145/317636.317793",
  xpages =       "138--147",
  year =         "1999",
}

@Book{Felleisen2001How,
  author =       "Matthias Felleisen and Robert B. Findler and Matthew
                 Flatt and Shriram Krishnamurthi",
  citeulike-article-id = "1396",
  citeulike-linkout-0 = "http://portal.acm.org/citation.cfm?id=369273",
  date-added =   "2004-12-02 00:03:09",
  keywords =     "education, plt, scheme",
  priority =     "0",
  publisher =    "MIT Press",
  title =        "How to design programs: an introduction to programming
                 and computing",
  x-address =    "Cambridge, MA, USA",
  x-isbn =       "0-262-06218-6",
  x-url =        "http://portal.acm.org/citation.cfm?id=369273",
  year =         "2001",
}

@InProceedings{Findler2004Slideshow,
  author =       "Robert B. Findler and Matthew Flatt",
  booktitle =    "Proceedings of the ninth ACM SIGPLAN international
                 conference on Functional programming",
  citeulike-article-id = "1392",
  citeulike-linkout-0 = "http://portal.acm.org/citation.cfm?id=1016880",
  citeulike-linkout-1 = "http://dx.doi.org/10.1145/1016850.1016880",
  date-added =   "2004-12-02 00:02:22",
  keywords =     "plt, scheme",
  location =     "Snow Bird, UT, USA",
  number =       "9",
  priority =     "0",
  publisher =    "ACM",
  title =        "Slideshow: functional presentations",
  volume =       "39",
  x-abstract =   "Among slide-presentation systems, the dominant
                 application offers essentially no abstraction
                 capability. Slideshow, an extension of {PLT} Scheme,
                 represents our effort over the last several years to
                 build an abstraction-friendly slide system. We show how
                 functional programming is well suited to the task of
                 slide creation, we report on the programming
                 abstractions that we have developed for slides, and we
                 describe our solutions to practical problems in
                 rendering slides. We also describe a prototype
                 extension to {DrScheme} that supports a mixture of
                 programmatic and {WYSIWYG} slide creation.",
  x-address =    "New York, NY, USA",
  x-doi =        "10.1145/1016850.1016880",
  x-isbn =       "1-58113-905-5",
  x-month =      sep,
  x-series =     "ICFP '04",
  x-url =        "http://dx.doi.org/10.1145/1016850.1016880",
  xpages =       "224--235",
  year =         "2004",
}

@Proceedings{Wick2004Memory,
  author =       "Adam Wick and Matthew Flatt",
  booktitle =    "Proceedings of the 4th international symposium on
                 Memory management",
  citeulike-article-id = "1391",
  citeulike-linkout-0 = "http://portal.acm.org/citation.cfm?id=1029888",
  citeulike-linkout-1 = "http://dx.doi.org/10.1145/1029873.1029888",
  date-added =   "2004-12-02 00:02:14",
  keywords =     "garbage-collection, plt, scheme",
  priority =     "1",
  publisher =    "ACM Press",
  title =        "Memory accounting without partitions",
  x-doi =        "10.1145/1029873.1029888",
  x-isbn =       "1581139454",
  x-url =        "http://dx.doi.org/10.1145/1029873.1029888",
  xpages =       "120--130",
  year =         "2004",
}

@Proceedings{Clements2001Modeling,
  author =       "John Clements and Matthew Flatt and Matthias
                 Felleisen",
  booktitle =    "Proceedings of the 10th European Symposium on
                 Programming Languages and Systems",
  citeulike-article-id = "1395",
  citeulike-linkout-0 = "http://portal.acm.org/citation.cfm?id=651947",
  date-added =   "2004-12-02 00:02:03",
  keywords =     "plt, scheme, stepper",
  priority =     "3",
  publisher =    "Springer-Verlag",
  title =        "Modeling an Algebraic Stepper",
  x-isbn =       "3540418628",
  x-url =        "http://portal.acm.org/citation.cfm?id=651947",
  xpages =       "320--334",
  year =         "2001",
}

@Article{Clements2004Tailrecursive,
  author =       "John Clements and Matthias Felleisen",
  citeulike-article-id = "1394",
  citeulike-linkout-0 = "http://portal.acm.org/citation.cfm?id=1034778",
  citeulike-linkout-1 = "http://dx.doi.org/10.1145/1034774.1034778",
  date-added =   "2004-12-02 00:01:52",
  journal =      "ACM Trans. Program. Lang. Syst.",
  keywords =     "plt, scheme",
  number =       "6",
  priority =     "2",
  publisher =    "ACM",
  title =        "A Tail-recursive Machine with Stack Inspection",
  volume =       "26",
  x-abstract =   "Security folklore holds that a security mechanism
                 based on stack inspection is incompatible with a global
                 tail call optimization policy; that an implementation
                 of such a language must allocate memory for a
                 source-code tail call, and a program that uses only
                 tail calls (and no other memory-allocating construct)
                 may nevertheless exhaust the available memory. In this
                 article, we prove this widely held belief wrong. We
                 exhibit an abstract machine for a language with
                 security stack inspection whose space consumption
                 function is equivalent to that of the canonical tail
                 call optimizing abstract machine. Our machine is
                 surprisingly simple and suggests that tail calls are as
                 easy to implement in a security setting as they are in
                 a conventional one.",
  x-address =    "New York, NY, USA",
  x-doi =        "10.1145/1034774.1034778",
  x-issn =       "0164-0925",
  x-month =      nov,
  x-url =        "http://dx.doi.org/10.1145/1034774.1034778",
  xpages =       "1029--1052",
  year =         "2004",
}

@Article{Matthews2004Automatically,
  author =       "Jacob Matthews and Robert B. Findler and Paul Graunke
                 and Shriram Krishnamurthi and Matthias Felleisen",
  citeulike-article-id = "1390",
  citeulike-linkout-0 = "http://portal.acm.org/citation.cfm?id=1015991",
  citeulike-linkout-1 = "http://dx.doi.org/10.1023/b:ause.0000038936.09009.69",
  date-added =   "2004-12-02 00:01:28",
  journal =      "Automated Software Engg.",
  keywords =     "plt, scheme, web-programming",
  number =       "4",
  priority =     "2",
  publisher =    "Kluwer Academic Publishers",
  title =        "Automatically Restructuring Programs for the Web",
  volume =       "11",
  x-doi =        "10.1023/b:ause.0000038936.09009.69",
  x-issn =       "0928-8910",
  x-month =      oct,
  x-url =        "http://dx.doi.org/10.1023/b:ause.0000038936.09009.69",
  xpages =       "337--364",
  year =         "2004",
}

@PhdThesis{Findler2002Behavioral,
  author =       "Robert B. Findler and Matthias Felleisen",
  citeulike-article-id = "1389",
  citeulike-linkout-0 = "http://portal.acm.org/citation.cfm?id=935530",
  date-added =   "2004-12-02 00:00:58",
  keywords =     "contracts, plt, scheme",
  priority =     "1",
  title =        "Behavioral software contracts",
  x-url =        "http://portal.acm.org/citation.cfm?id=935530",
  year =         "2002",
}

@Proceedings{Findler1998Modular,
  author =       "Robert B. Findler and Matthew Flatt",
  booktitle =    "Proceedings of the third ACM SIGPLAN international
                 conference on Functional programming",
  citeulike-article-id = "1393",
  citeulike-linkout-0 = "http://portal.acm.org/citation.cfm?id=289432",
  citeulike-linkout-1 = "http://dx.doi.org/10.1145/289423.289432",
  date-added =   "2004-12-02 00:00:00",
  keywords =     "mixins, modules, object-oriented, plt, scheme",
  number =       "1",
  priority =     "3",
  publisher =    "ACM Press",
  title =        "Modular object-oriented programming with units and
                 mixins",
  volume =       "34",
  x-doi =        "10.1145/289423.289432",
  x-isbn =       "1581130244",
  x-month =      jan,
  x-url =        "http://dx.doi.org/10.1145/289423.289432",
  xpages =       "94--104",
  year =         "1998",
}

@Proceedings{Krishnamurthi1998Synthesizing,
  author =       "Shriram Krishnamurthi and Matthias Felleisen and
                 Daniel P. Friedman",
  booktitle =    "Proceedings of the 12th European Conference on
                 Object-Oriented Programming",
  citeulike-article-id = "1385",
  citeulike-linkout-0 = "http://portal.acm.org/citation.cfm?id=679709",
  date-added =   "2004-12-01 23:58:44",
  keywords =     "plt, program-design",
  priority =     "3",
  publisher =    "Springer-Verlag",
  title =        "Synthesizing {Object-Oriented} and Functional Design
                 to Promote {Re-Use}",
  x-isbn =       "3540647376",
  x-url =        "http://portal.acm.org/citation.cfm?id=679709",
  xpages =       "91--113",
  year =         "1998",
}

@Proceedings{Felleisen1987Reduction,
  author =       "Matthias Felleisen and Daniel P. Friedman",
  booktitle =    "Proceedings of the Parallel Architectures and
                 Languages Europe, Volume I",
  citeulike-article-id = "1386",
  citeulike-linkout-0 = "http://portal.acm.org/citation.cfm?id=692409",
  date-added =   "2004-12-01 23:58:30",
  keywords =     "scheme, semantics",
  priority =     "2",
  publisher =    "Springer-Verlag",
  title =        "A Reduction Semantics for Imperative {Higher-Order}
                 Languages",
  x-isbn =       "3540179453",
  x-url =        "http://portal.acm.org/citation.cfm?id=692409",
  xpages =       "206--223",
  year =         "1987",
}

@Article{Staram1990Control,
  author =       "Dorai Staram and Matthias Felleisen",
  citeulike-article-id = "1387",
  citeulike-linkout-0 = "http://portal.acm.org/citation.cfm?id=83684",
  date-added =   "2004-12-01 23:58:18",
  journal =      "Lisp Symb. Comput.",
  keywords =     "continuations, scheme",
  number =       "1",
  priority =     "0",
  publisher =    "Kluwer Academic Publishers",
  title =        "Control delimiters and their hierarchies",
  volume =       "3",
  x-issn =       "0892-4635",
  x-month =      jan,
  x-url =        "http://portal.acm.org/citation.cfm?id=83684",
  xpages =       "67--99",
  year =         "1990",
}

@PhdThesis{Flatt2000Programming,
  author =       "Matthew R. Flatt and Matthias Felleisen",
  citeulike-article-id = "1388",
  citeulike-linkout-0 = "http://portal.acm.org/citation.cfm?id=931258",
  date-added =   "2004-12-01 23:58:09",
  keywords =     "plt, scheme",
  priority =     "1",
  title =        "Programming languages for reusable software
                 components",
  x-url =        "http://portal.acm.org/citation.cfm?id=931258",
  year =         "2000",
}

@Proceedings{Blume2004Sound,
  author =       "Matthias Blume and David Mcallester",
  booktitle =    "Proceedings of the ninth ACM SIGPLAN international
                 conference on Functional programming",
  citeulike-article-id = "1384",
  citeulike-linkout-0 = "http://portal.acm.org/citation.cfm?id=1016876",
  citeulike-linkout-1 = "http://dx.doi.org/10.1145/1016850.1016876",
  date-added =   "2004-12-01 23:52:35",
  keywords =     "contracts, denotational-semantics",
  number =       "9",
  priority =     "2",
  publisher =    "ACM Press",
  title =        "A sound (and complete) model of contracts",
  volume =       "39",
  x-doi =        "10.1145/1016850.1016876",
  x-issn =       "0362-1340",
  x-month =      sep,
  x-url =        "http://dx.doi.org/10.1145/1016850.1016876",
  xpages =       "189--200",
  year =         "2004",
}

@Article{Findler2002DrScheme,
  author =       "Robert B. Findler and John Clements and Cormac
                 Flanagan and Matthew Flatt and Shriram Krishnamurthi
                 and Paul Steckler and Matthias Felleisen",
  citeulike-article-id = "1383",
  citeulike-linkout-0 = "http://portal.acm.org/citation.cfm?id=968413.968416",
  citeulike-linkout-1 = "http://journals.cambridge.org/action/displayAbstract?fromPage=online\&aid=100085",
  citeulike-linkout-2 = "http://dx.doi.org/10.1017/s0956796801004208",
  date-added =   "2004-12-01 23:51:46",
  journal =      "Journal of Functional Programming",
  keywords =     "plt, program-environment, scheme",
  number =       "02",
  priority =     "3",
  publisher =    "Cambridge University Press",
  title =        "{DrScheme}: a programming environment for Scheme",
  volume =       "12",
  x-abstract =   "{DrScheme} is a programming environment for Scheme. It
                 fully integrates a graphics-enriched editor, a parser
                 for multiple variants of Scheme, a functional
                 read-eval-print loop, and an algebraic printer. The
                 environment is especially useful for students, because
                 it has a tower of syntactically restricted variants of
                 Scheme that are designed to catch typical student
                 mistakes and explain them in terms the students
                 understand. The environment is also useful for
                 professional programmers, due to its sophisticated
                 programming tools, such as the static debugger, and its
                 advanced language features, such as units and mixins.
                 Beyond the ordinary programming environment tools,
                 {DrScheme} provides an algebraic stepper, a
                 context-sensitive syntax checker, and a static
                 debugger. The stepper reduces Scheme programs to
                 values, according to the reduction semantics of Scheme.
                 It is useful for explaining the semantics of linguistic
                 facilities and for studying the behavior of small
                 programs. The syntax checker annotates programs with
                 font and color changes based on the syntactic structure
                 of the program. On demand, it draws arrows that point
                 from bound to binding occurrences of identifiers. It
                 also supports \&alpha;-renaming. Finally, the static
                 debugger provides a type inference system that explains
                 specific inferences in terms of a value-flow graph,
                 selectively overlaid on the program text.",
  x-doi =        "10.1017/s0956796801004208",
  x-issn =       "0956-7968",
  x-month =      mar,
  x-url =        "http://dx.doi.org/10.1017/s0956796801004208",
  xpages =       "159--182",
  year =         "2002",
}

@Article{Flanagan1996Catching,
  author =       "Cormac Flanagan and Matthew Flatt and Shriram
                 Krishnamurthi and Stephanie Weirich and Matthias
                 Felleisen",
  citeulike-article-id = "1382",
  citeulike-linkout-0 = "http://portal.acm.org/citation.cfm?id=249069.231387",
  citeulike-linkout-1 = "http://dx.doi.org/10.1145/249069.231387",
  date-added =   "2004-12-01 23:51:26",
  journal =      "SIGPLAN Not.",
  keywords =     "plt, scheme, static-analysis",
  number =       "5",
  priority =     "0",
  publisher =    "ACM Press",
  title =        "Catching bugs in the web of program invariants",
  volume =       "31",
  x-doi =        "10.1145/249069.231387",
  x-issn =       "0362-1340",
  x-month =      may,
  x-url =        "http://dx.doi.org/10.1145/249069.231387",
  xpages =       "23--32",
  year =         "1996",
}

@Article{Felleisen1991Expressive,
  author =       "Matthias Felleisen",
  citeulike-article-id = "1381",
  citeulike-linkout-0 = "http://portal.acm.org/citation.cfm?id=138491.138493",
  citeulike-linkout-1 = "http://dx.doi.org/10.1016/0167-6423(91)90036-w",
  date-added =   "2004-12-01 23:50:55",
  journal =      "Science of Computer Programming",
  keywords =     "programming",
  number =       "1-3",
  priority =     "3",
  publisher =    "Elsevier North-Holland, Inc.",
  title =        "On the expressive power of programming languages",
  volume =       "17",
  x-doi =        "10.1016/0167-6423(91)90036-w",
  x-issn =       "01676423",
  x-month =      dec,
  x-url =        "http://dx.doi.org/10.1016/0167-6423(91)90036-w",
  xpages =       "35--75",
  year =         "1991",
}

@InProceedings{Ariola1995Callbyneed,
  author =       "Zena M. Ariola and John Maraist and Martin Odersky and
                 Matthias Felleisen and Philip Wadler",
  booktitle =    "POPL '95: Proceedings of the 22nd ACM SIGPLAN-SIGACT
                 symposium on Principles of programming languages",
  citeulike-article-id = "1380",
  citeulike-linkout-0 = "http://portal.acm.org/citation.cfm?id=199448.199507",
  citeulike-linkout-1 = "http://dx.doi.org/10.1145/199448.199507",
  date-added =   "2004-12-01 23:49:23",
  keywords =     "lazy-evaluation",
  location =     "San Francisco, California, United States",
  priority =     "1",
  publisher =    "ACM",
  title =        "A call-by-need lambda calculus",
  x-abstract =   "The mismatch between the operational semantics of the
                 lambda calculus and the actual behavior of
                 implementations is a major obstacle for compiler
                 writers. They cannot explain the behavior of their
                 evaluator in terms of source level syntax, and they
                 cannot easily compare distinct implementations of
                 different lazy strategies. In this paper we derive an
                 equational characterization of call-by-need and prove
                 it correct with respect to the original lambda
                 calculus. The theory is a strictly smaller theory than
                 the lambda calculus. Immediate applications of the
                 theory concern the correctness proofs of a number of
                 implementation strategies, e.g. , the call-by-need
                 continuation passing transformation and the realization
                 of sharing via assignments.",
  x-address =    "New York, NY, USA",
  x-doi =        "10.1145/199448.199507",
  x-isbn =       "0-89791-692-1",
  x-url =        "http://dx.doi.org/10.1145/199448.199507",
  xpages =       "233--246",
  year =         "1995",
}

@Article{Wright1994Syntactic,
  author =       "A. Wright",
  citeulike-article-id = "1374",
  citeulike-linkout-0 = "http://portal.acm.org/citation.cfm?id=191905.191909",
  citeulike-linkout-1 = "http://dx.doi.org/10.1006/inco.1994.1093",
  date-added =   "2004-12-01 23:48:53",
  day =          "15",
  journal =      "Information and Computation",
  keywords =     "types",
  number =       "1",
  priority =     "2",
  publisher =    "Academic Press, Inc.",
  title =        "A Syntactic Approach to Type Soundness",
  volume =       "115",
  x-abstract =   "We present a new approach to proving type soundness
                 for {Hindley/Milner}-style polymorphic type systems.
                 The keys to our approach are (1) an adaptation of
                 subject reduction theorems from combinatory logic to
                 programming languages, and (2) the use of rewriting
                 techniques for the specification of the language
                 semantics. The approach easily extends from polymorphic
                 functional languages to imperative languages that
                 provide references, exceptions, continuations, and
                 similar features. We illustrate the technique with a
                 type soundness theorem for the core of Standard {ML},
                 which includes the first type soundness proof for
                 polymorphic exceptions and continuations.",
  x-doi =        "10.1006/inco.1994.1093",
  x-issn =       "08905401",
  x-month =      nov,
  x-url =        "http://dx.doi.org/10.1006/inco.1994.1093",
  xpages =       "38--94",
  year =         "1994",
}

@InProceedings{Flatt1998Classes,
  author =       "Matthew Flatt and Shriram Krishnamurthi and Matthias
                 Felleisen",
  booktitle =    "Proceedings of the 25th ACM SIGPLAN-SIGACT symposium
                 on Principles of programming languages",
  citeulike-article-id = "1375",
  citeulike-linkout-0 = "http://portal.acm.org/citation.cfm?id=268946.268961",
  citeulike-linkout-1 = "http://dx.doi.org/10.1145/268946.268961",
  date-added =   "2004-12-01 23:48:43",
  keywords =     "java, mixins, plt",
  location =     "San Diego, California, United States",
  priority =     "0",
  publisher =    "ACM",
  title =        "Classes and mixins",
  x-abstract =   "An abstract is not available.",
  x-address =    "New York, NY, USA",
  x-doi =        "10.1145/268946.268961",
  x-isbn =       "0-89791-979-3",
  x-series =     "POPL '98",
  x-url =        "http://dx.doi.org/10.1145/268946.268961",
  xpages =       "171--183",
  year =         "1998",
}

@Article{Sabry1992Reasoning,
  author =       "Amr Sabry and Matthias Felleisen",
  booktitle =    "Proceedings of the 1992 ACM conference on LISP and
                 functional programming",
  citeulike-article-id = "1376",
  citeulike-linkout-0 = "http://portal.acm.org/citation.cfm?id=141563",
  citeulike-linkout-1 = "http://dx.doi.org/10.1145/141471.141563",
  date-added =   "2004-12-01 23:48:27",
  journal =      "SIGPLAN Lisp Pointers",
  keywords =     "continuations, cps, scheme",
  location =     "San Francisco, California, United States",
  number =       "1",
  priority =     "2",
  publisher =    "ACM",
  title =        "Reasoning About Programs in Continuation-passing
                 Style.",
  volume =       "V",
  x-abstract =   "Plotkin's \&lgr;-value calculus is sound but
                 incomplete for reasoning about
                 \&bgr;eegr;-transformations on programs in
                 continuation-passing style ({CPS}). To find a complete
                 extension, we define a new, compactifying {CPS}
                 transformation and an ” inverse”mapping, {un-CPS},
                 both of which are interesting in their own right. Using
                 the new {CPS} transformation, we can determine the
                 precise language of {CPS} terms closed under
                 \&bgr;7eegr;-transformations. Using the {un-CPS}
                 transformation, we can derive a set of axioms such that
                 every equation between source programs is provable if
                 and only if \&bgr;\&eegr; can prove the corresponding
                 equation between {CPS} programs. The extended calculus
                 is equivalent to an untyped variant of Moggi's
                 computational \&lgr;-calculus.",
  x-address =    "New York, NY, USA",
  x-doi =        "10.1145/141471.141563",
  x-isbn =       "0-89791-481-3",
  x-issn =       "1045-3563",
  x-month =      jan,
  x-series =     "LFP '92",
  x-url =        "http://dx.doi.org/10.1145/141471.141563",
  xpages =       "288--298",
  year =         "1992",
}

@Article{Felleisen1987Syntactic,
  author =       "M. Felleisen",
  citeulike-article-id = "1377",
  citeulike-linkout-0 = "http://portal.acm.org/citation.cfm?id=39440.39443",
  citeulike-linkout-1 = "http://dx.doi.org/10.1016/0304-3975(87)90109-5",
  date-added =   "2004-12-01 23:48:09",
  journal =      "Theoretical Computer Science",
  keywords =     "scheme",
  number =       "3",
  priority =     "2",
  publisher =    "Elsevier Science Publishers Ltd.",
  title =        "A syntactic theory of sequential control",
  volume =       "52",
  x-abstract =   "Sequential control operators like J and call/cc are
                 often found in implementations of the λ-calculus as a
                 programming language. Their semantics is always defined
                 by the evaluation function of an abstract machine. We
                 show that, given such a machine semantics, one can
                 derive an algebraic extension of the λ υ -calculus.
                 The extended calculus satisfies the diamond property
                 and contains a {Church-Rosser} subcalculus. This
                 underscores that the interpretation of control
                 operators is to a certain degree independent of a
                 specific evaluation strategy. We also prove a
                 standardization theorem and use it to investigate the
                 correspondence between the machine and the calculus.
                 Together, the calculus and the rewriting machine form a
                 syntactic theory of control, which provides a natural
                 basis for reasoning about programs with nonfunctional
                 control operators.",
  x-address =    "Essex, UK",
  x-doi =        "10.1016/0304-3975(87)90109-5",
  x-issn =       "03043975",
  x-month =      jun,
  x-url =        "http://dx.doi.org/10.1016/0304-3975(87)90109-5",
  xpages =       "205--237",
  year =         "1987",
}

@InProceedings{Felleisen1988Theory,
  author =       "Mattias Felleisen",
  booktitle =    "POPL '88: Proceedings of the 15th ACM SIGPLAN-SIGACT
                 symposium on Principles of programming languages",
  citeulike-article-id = "1378",
  citeulike-linkout-0 = "http://portal.acm.org/citation.cfm?id=73560.73576",
  citeulike-linkout-1 = "http://dx.doi.org/10.1145/73560.73576",
  date-added =   "2004-12-01 23:48:01",
  keywords =     "continuations, scheme",
  location =     "San Diego, California, United States",
  priority =     "0",
  publisher =    "ACM",
  title =        "The theory and practice of first-class prompts",
  x-abstract =   "An analysis of the \&lgr; ugr; -C-calculus and its
                 problematic relationship to operational equivalence
                 leads to a new control facility: the prompt-application
                 . With the introduction of prompt-applications, the
                 control calculus becomes a traditional calculus all of
                 whose equations imply operational equivalence. In
                 addition, prompt-applications enhance the
                 expressiveness and efficiency of the language. We
                 illustrate the latter claim with examples from such
                 distinct areas as systems programming and tree
                 processing.",
  x-address =    "New York, NY, USA",
  x-doi =        "10.1145/73560.73576",
  x-isbn =       "0-89791-252-7",
  x-url =        "http://dx.doi.org/10.1145/73560.73576",
  xpages =       "180--190",
  year =         "1988",
}

@InProceedings{flatt98units,
  author =       "Matthew Flatt and Matthias Felleisen",
  booktitle =    "Proceedings of the ACM SIGPLAN 1998 conference on
                 Programming language design and implementation",
  citeulike-article-id = "1379",
  citeulike-linkout-0 = "http://portal.acm.org/citation.cfm?id=277650.277730",
  citeulike-linkout-1 = "http://dx.doi.org/10.1145/277650.277730",
  date-added =   "2004-12-01 23:47:39",
  keywords =     "modules, oopsla-paper, plt, scheme",
  number =       "5",
  publisher =    "ACM Press",
  title =        "Units: cool modules for {HOT} languages",
  volume =       "33",
  x-doi =        "10.1145/277650.277730",
  x-issn =       "0362-1340",
  x-month =      may,
  x-url =        "http://dx.doi.org/10.1145/277650.277730",
  xpages =       "236--248",
  year =         "1998",
}

@Article{Felleisen1992Revised,
  author =       "M. Felleisen",
  citeulike-article-id = "1373",
  citeulike-linkout-0 = "http://portal.acm.org/citation.cfm?id=136293.136297",
  citeulike-linkout-1 = "http://dx.doi.org/10.1016/0304-3975(92)90014-7",
  date-added =   "2004-12-01 23:46:15",
  day =          "14",
  journal =      "Theoretical Computer Science",
  keywords =     "scheme",
  number =       "2",
  publisher =    "Elsevier Science Publishers Ltd.",
  title =        "The revised report on the syntactic theories of
                 sequential control and state",
  volume =       "103",
  x-abstract =   "The syntactic theories of control and state are
                 conservative extensions of the λ υ -calculus for
                 equational reasoning about imperative programming
                 facilities in higher-order languages. Unlike the simple
                 λ υ -calculus, the extended theories are mixtures of
                 equivalence relations and compatible congruence
                 relations on the term language, which significantly
                 complicates the reasoning process. In this paper we
                 develop fully compatible equational theories of the
                 same imperative higher-order programming languages. The
                 new theories subsume the original calculi of control
                 and state and satisfy the usual {Church–Rosser} and
                 Standardization Theorems. With the new calculi,
                 equational reasoning about imperative programs becomes
                 as simple as reasoning about functional programs.",
  x-doi =        "10.1016/0304-3975(92)90014-7",
  x-issn =       "03043975",
  x-month =      sep,
  x-url =        "http://dx.doi.org/10.1016/0304-3975(92)90014-7",
  xpages =       "235--271",
  year =         "1992",
}

@Proceedings{Bachrach2001Java,
  author =       "Jonthan Bachrach and Keith Playford",
  booktitle =    "Proceedings of the 16th ACM SIGPLAN conference on
                 Object oriented programming, systems, languages, and
                 applications",
  citeulike-article-id = "1154",
  citeulike-linkout-0 = "http://portal.acm.org/citation.cfm?id=504285",
  citeulike-linkout-1 = "http://dx.doi.org/10.1145/504282.504285",
  date-added =   "2004-12-01 23:11:22",
  keywords =     "java, macros",
  number =       "11",
  publisher =    "ACM Press",
  title =        "The Java syntactic extender ({JSE})",
  volume =       "36",
  x-doi =        "10.1145/504282.504285",
  x-issn =       "0362-1340",
  x-month =      nov,
  x-url =        "http://dx.doi.org/10.1145/504282.504285",
  xpages =       "31--42",
  year =         "2001",
}

@InProceedings{Danvy1990Abstracting,
  author =       "Olivier Danvy and Andrzej Filinski",
  booktitle =    "LFP '90: Proceedings of the 1990 ACM conference on
                 LISP and functional programming",
  citeulike-article-id = "1358",
  citeulike-linkout-0 = "http://portal.acm.org/citation.cfm?id=91622",
  citeulike-linkout-1 = "http://dx.doi.org/10.1145/91556.91622",
  date-added =   "2004-12-01 23:09:37",
  keywords =     "continuations",
  location =     "Nice, France",
  publisher =    "ACM",
  title =        "Abstracting control",
  x-abstract =   "The last few years have seen a renewed interest in
                 continuations for expressing advanced control
                 structures in programming languages, and new models
                 such as Abstract Continuations have been proposed to
                 capture these dimensions. This article investigates an
                 alternative formulation, exploiting the latent
                 expressive power of the standard continuation-passing
                 style ({CPS}) instead of introducing yet other new
                 concepts. We build on a single foundation: abstracting
                 control as a hierarchy of continuations, each one
                 modeling a specific language feature as acting on
                 nested evaluation contexts. We show how iterating the
                 continuation-passing conversion allows us to specify a
                 wide range of control behavior. For example, two
                 conversions yield an abstraction of Prolog-style
                 backtracking. A number of other constructs can likewise
                 be expressed in this framework; each is defined
                 independently of the others, but all are arranged in a
                 hierarchy making any interactions between them
                 explicit. This approach preserves all the traditional
                 results about {CPS}, e.g. , its evaluation order
                 independence. Accordingly, our semantics is directly
                 implementable in a call-by-value language such as
                 Scheme or {ML}. Furthermore, because the control
                 operators denote simple, typable lambda-terms in {CPS},
                 they themselves can be statically typed. Contrary to
                 intuition, the iterated {CPS} transformation does not
                 yield huge results: except where explicitly needed, all
                 continuations beyond the first one disappear due to the
                 extensionality principle ( \&eegr; -reduction). Besides
                 presenting a new motivation for control operators, this
                 paper also describes an improved conversion into
                 applicative-order {CPS}. The conversion operates in one
                 pass by performing all administrative reductions at
                 translation time; interestingly, it can be expressed
                 very concisely using the new control operators. The
                 paper also presents some examples of nondeterministic
                 programming in direct style.",
  x-address =    "New York, NY, USA",
  x-doi =        "10.1145/91556.91622",
  x-isbn =       "0-89791-368-X",
  x-url =        "http://dx.doi.org/10.1145/91556.91622",
  xpages =       "151--160",
  year =         "1990",
}

@Proceedings{Dybvig1986Expansionpassing,
  author =       "R. Kent Dybvig and Daniel P. Friedman and Christopher
                 T. Haynes",
  booktitle =    "Proceedings of the 1986 ACM conference on LISP and
                 functional programming",
  citeulike-article-id = "1356",
  citeulike-linkout-0 = "http://portal.acm.org/citation.cfm?id=319858",
  citeulike-linkout-1 = "http://dx.doi.org/10.1145/319838.319858",
  date-added =   "2004-12-01 23:09:28",
  keywords =     "macros, scheme",
  publisher =    "ACM Press",
  title =        "Expansion-passing style: beyond conventional macros",
  x-doi =        "10.1145/319838.319858",
  x-isbn =       "0897912004",
  x-url =        "http://dx.doi.org/10.1145/319838.319858",
  xpages =       "143--150",
  year =         "1986",
}

@Article{Clinger1999Implementation,
  author =       "William D. Clinger and Anne H. Hartheimer and Eric M.
                 Ost",
  citeulike-article-id = "1359",
  citeulike-linkout-0 = "http://portal.acm.org/citation.cfm?id=609188",
  citeulike-linkout-1 = "http://dx.doi.org/10.1023/a:1010016816429",
  citeulike-linkout-2 = "http://www.springerlink.com/content/h5808n962434j275",
  date-added =   "2004-12-01 23:09:20",
  day =          "20",
  journal =      "Higher-Order and Symbolic Computation",
  keywords =     "continuations, scheme",
  number =       "1",
  publisher =    "Springer Netherlands",
  title =        "Implementation Strategies for {First-Class}
                 Continuations",
  volume =       "12",
  x-doi =        "10.1023/a:1010016816429",
  x-issn =       "13883690",
  x-month =      apr,
  x-url =        "http://dx.doi.org/10.1023/a:1010016816429",
  xpages =       "7--45",
  year =         "1999",
}

@Article{Pitman1994Parenthetically,
  author =       "Kent M. Pitman",
  citeulike-article-id = "1371",
  citeulike-linkout-0 = "http://portal.acm.org/citation.cfm?id=382671",
  citeulike-linkout-1 = "http://dx.doi.org/10.1145/382109.382671",
  date-added =   "2004-12-01 23:09:10",
  journal =      "SIGPLAN Lisp Pointers",
  keywords =     "lambda-the-ultimate",
  number =       "4",
  publisher =    "ACM Press",
  title =        "Parenthetically speaking: more than just words:
                 lambda, the ultimate political party",
  volume =       "VII",
  x-doi =        "10.1145/382109.382671",
  x-issn =       "1045-3563",
  x-url =        "http://dx.doi.org/10.1145/382109.382671",
  xpages =       "24--29",
  year =         "1994",
}

@Proceedings{Shivers1996Universal,
  author =       "Olin Shivers",
  booktitle =    "Proceedings of the Second Asian Computing Science
                 Conference on Concurrency and Parallelism, Programming,
                 Networking, and Security",
  citeulike-article-id = "1357",
  citeulike-linkout-0 = "http://portal.acm.org/citation.cfm?id=676338",
  date-added =   "2004-12-01 23:09:02",
  keywords =     "lambda-the-ultimate, scheme",
  publisher =    "Springer-Verlag",
  title =        "A Universal Scripting Framework or Lambda: The
                 Ultimate {"}Little Language{"}",
  x-isbn =       "3540620311",
  x-url =        "http://portal.acm.org/citation.cfm?id=676338",
  xpages =       "254--265",
  year =         "1996",
}

@InProceedings{Wadler1992Essence,
  author =       "Philip Wadler",
  booktitle =    "Proceedings of the 19th ACM SIGPLAN-SIGACT Symposium
                 on Principles of Programming Languages",
  citeulike-article-id = "1360",
  citeulike-linkout-0 = "http://portal.acm.org/citation.cfm?id=143169",
  citeulike-linkout-1 = "http://dx.doi.org/10.1145/143165.143169",
  date-added =   "2004-12-01 23:08:36",
  keywords =     "programming",
  location =     "Albuquerque, New Mexico, USA",
  publisher =    "ACM",
  title =        "The Essence of Functional Programming",
  x-abstract =   "This paper explores the use monads to structure
                 functional programs. No prior knowledge of monads or
                 category theory is required. Monads increase the ease
                 with which programs may be modified. They can mimic the
                 effect of impure features such as exceptions, state,
                 and continuations; and also provide effects not easily
                 achieved with such features. The types of a program
                 reflect which effects occur. The first section is an
                 extended example of the use of monads. A simple
                 interpreter is modified to support various extra
                 features: error messages, state, output, and
                 non-deterministic choice. The second section describes
                 the relation between monads and the
                 continuation-passing style. The third section sketches
                 how monads are used in a compiler for Haskell that is
                 written in Haskell.",
  x-address =    "New York, NY, USA",
  x-doi =        "10.1145/143165.143169",
  x-isbn =       "0-89791-453-8",
  x-series =     "POPL '92",
  x-url =        "http://dx.doi.org/10.1145/143165.143169",
  xpages =       "1--14",
  year =         "1992",
}

@Proceedings{Herman2004Improving,
  author =       "David Herman and Philippe Meunier",
  booktitle =    "Proceedings of the ninth ACM SIGPLAN international
                 conference on Functional programming",
  citeulike-article-id = "1361",
  citeulike-linkout-0 = "http://portal.acm.org/citation.cfm?id=1016857",
  citeulike-linkout-1 = "http://dx.doi.org/10.1145/1016850.1016857",
  date-added =   "2004-12-01 23:08:20",
  keywords =     "cfa, macros, plt, scheme, static-analysis",
  number =       "9",
  publisher =    "ACM Press",
  title =        "Improving the static analysis of embedded languages
                 via partial evaluation",
  volume =       "39",
  x-doi =        "10.1145/1016850.1016857",
  x-issn =       "0362-1340",
  x-month =      sep,
  x-url =        "http://dx.doi.org/10.1145/1016850.1016857",
  xpages =       "16--27",
  year =         "2004",
}

@Proceedings{Burger1995Register,
  author =       "Robert G. Burger and Oscar Waddell and R. Kent
                 Dybvig",
  booktitle =    "Proceedings of the ACM SIGPLAN 1995 conference on
                 Programming language design and implementation",
  citeulike-article-id = "1363",
  citeulike-linkout-0 = "http://portal.acm.org/citation.cfm?id=207125",
  citeulike-linkout-1 = "http://dx.doi.org/10.1145/207110.207125",
  date-added =   "2004-12-01 23:08:00",
  keywords =     "compiler, scheme",
  number =       "6",
  publisher =    "ACM Press",
  title =        "Register allocation using lazy saves, eager restores,
                 and greedy shuffling",
  volume =       "30",
  x-doi =        "10.1145/207110.207125",
  x-issn =       "0362-1340",
  x-month =      jun,
  x-url =        "http://dx.doi.org/10.1145/207110.207125",
  xpages =       "130--138",
  year =         "1995",
}

@InProceedings{Findler2002Contracts,
  author =       "Robert B. Findler and Matthias Felleisen",
  booktitle =    "Proceedings of the seventh ACM SIGPLAN international
                 conference on Functional programming",
  citeulike-article-id = "1362",
  citeulike-linkout-0 = "http://portal.acm.org/citation.cfm?id=581484",
  citeulike-linkout-1 = "http://dx.doi.org/10.1145/581478.581484",
  date-added =   "2004-12-01 23:07:52",
  journal =      "SIGPLAN Not.",
  keywords =     "contracts, plt, scheme",
  location =     "Pittsburgh, PA, USA",
  number =       "9",
  publisher =    "ACM",
  title =        "Contracts for higher-order functions",
  volume =       "37",
  x-abstract =   "Assertions play an important role in the construction
                 of robust software. Their use in programming languages
                 dates back to the 1970s. Eiffel, an object-oriented
                 programming language, wholeheartedly adopted assertions
                 and developed the {"}Design by Contract{"} philosophy.
                 Indeed, the entire object-oriented community recognizes
                 the value of assertion-based contracts on {methods.In}
                 contrast, languages with higher-order functions do not
                 support assertion-based contracts. Because predicates
                 on functions are, in general, undecidable, specifying
                 such predicates appears to be meaningless. Instead, the
                 functional languages community developed type systems
                 that statically approximate interesting {predicates.In}
                 this paper, we show how to support higher-order
                 function contracts in a theoretically well-founded and
                 practically viable manner. Specifically, we introduce
                 λcon, a typed lambda calculus with assertions for
                 higher-order functions. The calculus models the
                 assertion monitoring system that we employ in
                 {DrScheme}. We establish basic properties of the model
                 (type soundness, etc.) and illustrate the usefulness of
                 contract checking with examples from {DrScheme}'s code
                 {base.We} believe that the development of an assertion
                 system for higher-order functions serves two purposes.
                 On one hand, the system has strong practical potential
                 because existing type systems simply cannot express
                 many assertions that programmers would like to state.
                 On the other hand, an inspection of a large base of
                 invariants may provide inspiration for the direction of
                 practical future type system research.",
  x-address =    "New York, NY, USA",
  x-doi =        "10.1145/581478.581484",
  x-isbn =       "1-58113-487-8",
  x-issn =       "0362-1340",
  x-month =      sep,
  x-series =     "ICFP '02",
  x-url =        "http://dx.doi.org/10.1145/581478.581484",
  xpages =       "48--59",
  year =         "2002",
}

@Proceedings{Hansen2002Experimental,
  author =       "Lars T. Hansen and William D. Clinger",
  booktitle =    "Proceedings of the seventh ACM SIGPLAN international
                 conference on Functional programming",
  citeulike-article-id = "1364",
  citeulike-linkout-0 = "http://portal.acm.org/citation.cfm?id=581502",
  citeulike-linkout-1 = "http://dx.doi.org/10.1145/581478.581502",
  date-added =   "2004-12-01 23:07:44",
  keywords =     "garbage-collection",
  number =       "9",
  publisher =    "ACM Press",
  title =        "An experimental study of renewal-older-first garbage
                 collection",
  volume =       "37",
  x-doi =        "10.1145/581478.581502",
  x-issn =       "0362-1340",
  x-month =      sep,
  x-url =        "http://dx.doi.org/10.1145/581478.581502",
  xpages =       "247--258",
  year =         "2002",
}

@InProceedings{Jouvelot1991Algebraic,
  author =       "Pierre Jouvelot and David Gifford",
  booktitle =    "Proceedings of the 18th ACM SIGPLAN-SIGACT Symposium
                 on Principles of Programming Languages",
  citeulike-article-id = "1365",
  citeulike-linkout-0 = "http://portal.acm.org/citation.cfm?id=99623",
  citeulike-linkout-1 = "http://dx.doi.org/10.1145/99583.99623",
  date-added =   "2004-12-01 23:07:36",
  keywords =     "effects, fx, types",
  location =     "Orlando, Florida, USA",
  priority =     "0",
  publisher =    "ACM",
  title =        "Algebraic Reconstruction of Types and Effects",
  x-abstract =   "An abstract is not available.",
  x-address =    "New York, NY, USA",
  x-doi =        "10.1145/99583.99623",
  x-isbn =       "0-89791-419-8",
  x-series =     "POPL '91",
  x-url =        "http://dx.doi.org/10.1145/99583.99623",
  xpages =       "303--310",
  year =         "1991",
}

@InProceedings{Clinger1997Generational,
  author =       "William D. Clinger and Lars T. Hansen",
  booktitle =    "Proceedings of the ACM SIGPLAN 1997 Conference on
                 Programming Language Design and Implementation",
  citeulike-article-id = "1370",
  citeulike-linkout-0 = "http://portal.acm.org/citation.cfm?id=258925",
  citeulike-linkout-1 = "http://dx.doi.org/10.1145/258915.258925",
  date-added =   "2004-12-01 23:07:19",
  keywords =     "garbage-collection",
  location =     "Las Vegas, Nevada, USA",
  number =       "5",
  publisher =    "ACM",
  title =        "Generational Garbage Collection and the Radioactive
                 Decay Model",
  volume =       "32",
  x-abstract =   "If a fixed exponentially decreasing probability
                 distribution function is used to model every object's
                 lifetime, then the age of an object gives no
                 information about its future life expectancy. This
                 radioactive decay model implies there can be no
                 rational basis for deciding which live objects should
                 be promoted to another generation. Yet there remains a
                 rational basis for deciding how many objects to
                 promote, when to collect garbage, and which generations
                 to {collect.Analysis} of the model leads to a new kind
                 of generational garbage collector whose effectiveness
                 does not depend upon heuristics that predict which
                 objects will live longer than {others.This} result
                 provides insight into the computational advantages of
                 generational garbage collection, with implications for
                 the management of objects whose life expectancies are
                 difficult to predict.",
  x-address =    "New York, NY, USA",
  x-doi =        "10.1145/258915.258925",
  x-isbn =       "0-89791-907-6",
  x-month =      may,
  x-series =     "PLDI '97",
  x-url =        "http://dx.doi.org/10.1145/258915.258925",
  xpages =       "97--108",
  year =         "1997",
}

@Article{Neubauer2001Down,
  author =       "Matthias Neubauer and Michael Sperber",
  booktitle =    "Proceedings of the sixth ACM SIGPLAN international
                 conference on Functional programming",
  citeulike-article-id = "1369",
  citeulike-linkout-0 = "http://portal.acm.org/citation.cfm?id=507642",
  citeulike-linkout-1 = "http://dx.doi.org/10.1145/507635.507642",
  date-added =   "2004-12-01 23:07:08",
  journal =      "SIGPLAN Not.",
  keywords =     "dynamic-scope, lisp",
  number =       "10",
  publisher =    "ACM",
  title =        "Down with Emacs Lisp: dynamic scope analysis",
  volume =       "36",
  x-abstract =   "It is possible to translate code written in Emacs Lisp
                 or another Lisp dialect which uses dynamic scoping to a
                 more modern programming language with lexical scoping
                 while largely preserving structure and readability of
                 the code. The biggest obstacle to such an idiomatic
                 translation from Emacs Lisp is the translation of
                 dynamic binding into suitable instances of lexical
                 binding: Many binding constructs in real programs in
                 fact exhibit identical behavior under both dynamic and
                 lexical binding. An idiomatic translation needs to
                 detect as many of these binding constructs as possible
                 and convert them into lexical binding constructs in the
                 target language to achieve readability and efficiency
                 of the target code. The basic prerequisite for such an
                 idiomatic translation is thus a dynamic scope analysis
                 which associates variable occurrences with binding
                 constructs. We present such an analysis. It is an
                 application of the {Nielson/Nielson} framework for flow
                 analysis to a semantics for dynamic binding akin to
                 Moreau's. Its implementation handles a substantial
                 portion of Emacs Lisp, has been applied to realistic
                 Emacs Lisp code, and is highly accurate and reasonably
                 efficient in practice.",
  x-address =    "New York, NY, USA",
  x-doi =        "10.1145/507635.507642",
  x-issn =       "0362-1340",
  x-month =      oct,
  x-url =        "http://dx.doi.org/10.1145/507635.507642",
  xpages =       "38--49",
  year =         "2001",
}

@Proceedings{Cointe1987Metaclasses,
  author =       "Pierre Cointe",
  booktitle =    "Conference proceedings on Object-oriented programming
                 systems, languages and applications",
  citeulike-article-id = "1366",
  citeulike-linkout-0 = "http://portal.acm.org/citation.cfm?id=38822",
  citeulike-linkout-1 = "http://dx.doi.org/10.1145/38765.38822",
  date-added =   "2004-12-01 23:06:55",
  keywords =     "lisp, metaclasses",
  number =       "12",
  publisher =    "ACM Press",
  title =        "Metaclasses are first class: The {ObjVlisp} Model",
  volume =       "22",
  x-doi =        "10.1145/38765.38822",
  x-issn =       "0362-1340",
  x-month =      dec,
  x-url =        "http://dx.doi.org/10.1145/38765.38822",
  xpages =       "156--162",
  year =         "1987",
}

@Proceedings{Queinnec1994Locality,
  author =       "Christian Queinnec",
  booktitle =    "Proceedings of the 1994 ACM conference on LISP and
                 functional programming",
  citeulike-article-id = "1367",
  citeulike-linkout-0 = "http://portal.acm.org/citation.cfm?id=182445",
  citeulike-linkout-1 = "http://dx.doi.org/10.1145/182409.182445",
  date-added =   "2004-12-01 23:06:45",
  keywords =     "continuations",
  publisher =    "ACM Press",
  title =        "Locality, causality and continuations",
  x-doi =        "10.1145/182409.182445",
  x-isbn =       "0897916433",
  x-url =        "http://dx.doi.org/10.1145/182409.182445",
  xpages =       "91--102",
  year =         "1994",
}

@InProceedings{Filinski1999Representing,
  author =       "Andrzej Filinski",
  booktitle =    "Proceedings of the 26th ACM SIGPLAN-SIGACT symposium
                 on Principles of programming languages",
  citeulike-article-id = "1368",
  citeulike-linkout-0 = "http://portal.acm.org/citation.cfm?id=292557",
  citeulike-linkout-1 = "http://dx.doi.org/10.1145/292540.292557",
  date-added =   "2004-12-01 23:06:37",
  keywords =     "monads",
  location =     "San Antonio, Texas, USA",
  publisher =    "ACM",
  title =        "Representing layered monads",
  x-abstract =   "An abstract is not available.",
  x-address =    "New York, NY, USA",
  x-doi =        "10.1145/292540.292557",
  x-isbn =       "1-58113-095-3",
  x-series =     "POPL '99",
  x-url =        "http://dx.doi.org/10.1145/292540.292557",
  xpages =       "175--188",
  year =         "1999",
}

@Article{Adams1998Revisedsupscrpt5supscrpt,
  author =       "N. I. Adams and D. H. Bartley and G. Brooks and R. K.
                 Dybvig and D. P. Friedman and R. Halstead and C. Hanson
                 and C. T. Haynes and E. Kohlbecker and D. Oxley and K.
                 M. Pitman and G. J. Rozas and G. L. Steele and G. J.
                 Sussman and M. Wand and H. Abelson",
  citeulike-article-id = "1355",
  citeulike-linkout-0 = "http://portal.acm.org/citation.cfm?id=290234",
  citeulike-linkout-1 = "http://dx.doi.org/10.1145/290229.290234",
  date-added =   "2004-12-01 22:48:21",
  journal =      "SIGPLAN Not.",
  keywords =     "scheme",
  number =       "9",
  publisher =    "ACM",
  title =        "Revised<supscrpt>5</supscrpt> report on the
                 algorithmic language scheme",
  volume =       "33",
  x-abstract =   "An abstract is not available.",
  x-address =    "New York, NY, USA",
  x-doi =        "10.1145/290229.290234",
  x-issn =       "0362-1340",
  x-month =      sep,
  x-url =        "http://dx.doi.org/10.1145/290229.290234",
  xpages =       "26--76",
  year =         "1998",
}

@Article{Shivers1988Control,
  author =       "O. Shivers",
  booktitle =    "PLDI '88: Proceedings of the ACM SIGPLAN 1988
                 conference on Programming Language design and
                 Implementation",
  citeulike-article-id = "1354",
  citeulike-linkout-0 = "http://portal.acm.org/citation.cfm?id=54007",
  citeulike-linkout-1 = "http://dx.doi.org/10.1145/53990.54007",
  date-added =   "2004-12-01 22:48:09",
  journal =      "SIGPLAN Not.",
  keywords =     "cfa, scheme",
  location =     "Atlanta, Georgia, United States",
  number =       "7",
  priority =     "0",
  publisher =    "ACM",
  title =        "Control flow analysis in scheme",
  volume =       "23",
  x-abstract =   "Traditional flow analysis techniques, such as the ones
                 typically employed by optimizing Fortran compilers, do
                 not work for Scheme-like languages. This paper presents
                 a flow analysis technique — control flow analysis —
                 which is applicable to Scheme-like languages. As a
                 demonstration application, the information gathered by
                 control flow analysis is used to perform a traditional
                 flow analysis problem, induction variable elimination.
                 Extensions and limitations are {discussed.The}
                 techniques presented in this paper are backed up by
                 working code. They are applicable not only to Scheme,
                 but also to related languages, such as Common Lisp and
                 {ML}.",
  x-address =    "New York, NY, USA",
  x-doi =        "10.1145/53990.54007",
  x-isbn =       "0-89791-269-1",
  x-issn =       "0362-1340",
  x-month =      jun,
  x-url =        "http://dx.doi.org/10.1145/53990.54007",
  xpages =       "164--174",
  year =         "1988",
}

@Proceedings{Rees1982T,
  author =       "Jonathan A. Rees and Norman V. Adams",
  booktitle =    "Proceedings of the 1982 ACM symposium on LISP and
                 functional programming",
  citeulike-article-id = "1352",
  citeulike-linkout-0 = "http://portal.acm.org/citation.cfm?id=802142",
  date-added =   "2004-12-01 22:45:09",
  keywords =     "lambda-the-ultimate, scheme",
  publisher =    "ACM Press",
  title =        "{T}: a dialect of Lisp or {LAMBDA}: The ultimate
                 software tool",
  x-isbn =       "0897910826",
  x-url =        "http://portal.acm.org/citation.cfm?id=802142",
  xpages =       "114--122",
  year =         "1982",
}

@Article{Clinger1998Proper,
  author =       "William D. Clinger",
  booktitle =    "Proceedings of the ACM SIGPLAN 1998 conference on
                 Programming language design and implementation",
  citeulike-article-id = "1350",
  citeulike-linkout-0 = "http://portal.acm.org/citation.cfm?id=277719",
  citeulike-linkout-1 = "http://dx.doi.org/10.1145/277650.277719",
  date-added =   "2004-12-01 22:45:01",
  journal =      "SIGPLAN Not.",
  keywords =     "scheme",
  number =       "5",
  publisher =    "ACM",
  title =        "Proper tail recursion and space efficiency",
  volume =       "33",
  x-abstract =   "The {IEEE}/{ANSI} standard for Scheme requires
                 implementations to be properly tail recursive. This
                 ensures that portable code can rely upon the space
                 efficiency of continuation-passing style and other
                 idioms. On its face, proper tail recursion concerns the
                 efficiency of procedure calls that occur within a tail
                 context. When examined closely, proper tail recursion
                 also depends upon the fact that garbage collection can
                 be asymptotically more space-efficient than Algol-like
                 stack {allocation.Proper} tail recursion is not the
                 same as ad hoc tail call optimization in stack-based
                 languages. Proper tail recursion often precludes stack
                 allocation of variables, but yields a well-defined
                 asymptotic space complexity that can be relied upon by
                 portable {programs.This} paper offers a formal and
                 implementation-independent definition of proper tail
                 recursion for Scheme. It also shows how an entire
                 family of reference implementations can be used to
                 characterize related safe-for-space properties, and
                 proves the asymptotic inequalities that hold between
                 them.",
  x-address =    "New York, NY, USA",
  x-doi =        "10.1145/277650.277719",
  x-issn =       "0362-1340",
  x-month =      may,
  x-url =        "http://dx.doi.org/10.1145/277650.277719",
  xpages =       "174--185",
  year =         "1998",
}

@Article{Cartwright1991Lambda,
  author =       "Robert Cartwright",
  citeulike-article-id = "1351",
  citeulike-linkout-0 = "http://portal.acm.org/citation.cfm?id=132221",
  date-added =   "2004-12-01 22:44:53",
  keywords =     "lambda-the-ultimate, scheme",
  publisher =    "Academic Press Professional, Inc.",
  title =        "Lambda: the ultimate combinator",
  x-isbn =       "0124500102",
  x-url =        "http://portal.acm.org/citation.cfm?id=132221",
  xpages =       "27--46",
  year =         "1991",
}

@Article{Kranz2004Orbit,
  author =       "David Kranz and Richard Kelsey and Jonathan Rees and
                 Paul Hudak and James Philbin and Norman Adams",
  citeulike-article-id = "1353",
  citeulike-linkout-0 = "http://portal.acm.org/citation.cfm?id=989414",
  citeulike-linkout-1 = "http://dx.doi.org/10.1145/989393.989414",
  date-added =   "2004-12-01 22:44:47",
  journal =      "SIGPLAN Not.",
  keywords =     "scheme",
  number =       "4",
  publisher =    "ACM Press",
  title =        "Orbit: an optimizing compiler for scheme",
  volume =       "39",
  x-doi =        "10.1145/989393.989414",
  x-issn =       "0362-1340",
  x-month =      apr,
  x-url =        "http://dx.doi.org/10.1145/989393.989414",
  xpages =       "175--191",
  year =         "2004",
}

@InProceedings{Bawden1988Syntactic,
  author =       "Alan Bawden and Jonathan Rees",
  booktitle =    "Proceedings of the 1988 ACM conference on LISP and
                 functional programming",
  citeulike-article-id = "1349",
  citeulike-linkout-0 = "http://portal.acm.org/citation.cfm?id=62687",
  citeulike-linkout-1 = "http://dx.doi.org/10.1145/62678.62687",
  date-added =   "2004-12-01 22:39:30",
  keywords =     "macros, scheme",
  location =     "Snowbird, Utah, United States",
  publisher =    "ACM",
  title =        "Syntactic closures",
  x-abstract =   "In this paper we describe syntactic closures.
                 Syntactic closures address the scoping problems that
                 arise when writing macros. We discuss some issues
                 raised by introducing syntactic closures into the macro
                 expansion interface, and we compare syntactic closures
                 with other approaches. Included is a complete
                 implementation.",
  x-address =    "New York, NY, USA",
  x-doi =        "10.1145/62678.62687",
  x-isbn =       "0-89791-273-X",
  x-series =     "LFP '88",
  x-url =        "http://dx.doi.org/10.1145/62678.62687",
  xpages =       "86--95",
  year =         "1988",
}

@Proceedings{Curtis1990Module,
  author =       "Pavel Curtis and James Rauen",
  booktitle =    "Proceedings of the 1990 ACM conference on LISP and
                 functional programming",
  citeulike-article-id = "1348",
  citeulike-linkout-0 = "http://portal.acm.org/citation.cfm?id=91573",
  citeulike-linkout-1 = "http://dx.doi.org/10.1145/91556.91573",
  date-added =   "2004-12-01 22:39:24",
  keywords =     "modules, scheme",
  publisher =    "ACM Press",
  title =        "A module system for scheme",
  x-doi =        "10.1145/91556.91573",
  x-isbn =       "089791368X",
  x-url =        "http://dx.doi.org/10.1145/91556.91573",
  xpages =       "13--19",
  year =         "1990",
}

@Book{Dybvig1987SCHEME,
  author =       "R. Kent Dybvig",
  citeulike-article-id = "1347",
  citeulike-linkout-0 = "http://portal.acm.org/citation.cfm?id=40687",
  date-added =   "2004-12-01 22:39:19",
  keywords =     "scheme",
  publisher =    "Prentice-Hall, Inc.",
  title =        "The {SCHEME} programming language",
  x-isbn =       "013791864X",
  x-url =        "http://portal.acm.org/citation.cfm?id=40687",
  year =         "1987",
}

@InProceedings{Kohlbecker1986Hygienic,
  author =       "Eugene Kohlbecker and Daniel P. Friedman and Matthias
                 Felleisen and Bruce Duba",
  booktitle =    "Proceedings of the 1986 ACM conference on LISP and
                 functional programming",
  citeulike-article-id = "1345",
  citeulike-linkout-0 = "http://portal.acm.org/citation.cfm?id=319859",
  citeulike-linkout-1 = "http://dx.doi.org/10.1145/319838.319859",
  date-added =   "2004-12-01 22:39:14",
  keywords =     "macros, scheme",
  location =     "Cambridge, Massachusetts, USA",
  publisher =    "ACM",
  title =        "Hygienic macro expansion",
  x-abstract =   "An abstract is not available.",
  x-address =    "New York, NY, USA",
  x-doi =        "10.1145/319838.319859",
  x-isbn =       "0-89791-200-4",
  x-series =     "LFP '86",
  x-url =        "http://dx.doi.org/10.1145/319838.319859",
  xpages =       "151--161",
  year =         "1986",
}

@Article{Rees1986Revised,
  author =       "J. Rees and W. Clinger",
  citeulike-article-id = "1346",
  citeulike-linkout-0 = "http://portal.acm.org/citation.cfm?id=15043",
  citeulike-linkout-1 = "http://dx.doi.org/10.1145/15042.15043",
  date-added =   "2004-12-01 22:39:05",
  journal =      "SIGPLAN Not.",
  keywords =     "scheme",
  number =       "12",
  publisher =    "ACM Press",
  title =        "Revised report on the algorithmic language scheme",
  volume =       "21",
  x-doi =        "10.1145/15042.15043",
  x-issn =       "0362-1340",
  x-month =      dec,
  x-url =        "http://dx.doi.org/10.1145/15042.15043",
  xpages =       "37--79",
  year =         "1986",
}

@Book{Steele1990Common,
  author =       "Guy Steele",
  citeulike-article-id = "1344",
  citeulike-linkout-0 = "http://portal.acm.org/citation.cfm?id=95411",
  date-added =   "2004-12-01 22:38:58",
  keywords =     "lisp",
  publisher =    "Digital Press",
  title =        "Common {LISP}: the language (2nd ed.)",
  x-isbn =       "1555580416",
  x-url =        "http://portal.acm.org/citation.cfm?id=95411",
  year =         "1990",
}

@Proceedings{Waddell1999Extending,
  author =       "Oscar Waddell and R. Kent Dybvig",
  booktitle =    "Proceedings of the 26th ACM SIGPLAN-SIGACT symposium
                 on Principles of programming languages",
  citeulike-article-id = "1343",
  citeulike-linkout-0 = "http://portal.acm.org/citation.cfm?id=292559",
  citeulike-linkout-1 = "http://dx.doi.org/10.1145/292540.292559",
  date-added =   "2004-12-01 22:38:53",
  keywords =     "macros, scheme",
  publisher =    "ACM Press",
  title =        "Extending the scope of syntactic abstraction",
  x-doi =        "10.1145/292540.292559",
  x-isbn =       "1581130953",
  x-url =        "http://dx.doi.org/10.1145/292540.292559",
  xpages =       "203--215",
  year =         "1999",
}

@Proceedings{Bawden2000Firstclass,
  author =       "Alan Bawden",
  booktitle =    "Proceedings of the 27th ACM SIGPLAN-SIGACT symposium
                 on Principles of programming languages",
  citeulike-article-id = "1341",
  citeulike-linkout-0 = "http://portal.acm.org/citation.cfm?id=325710",
  citeulike-linkout-1 = "http://dx.doi.org/10.1145/325694.325710",
  date-added =   "2004-12-01 22:38:43",
  keywords =     "macros, scheme",
  publisher =    "ACM Press",
  title =        "First-class macros have types",
  x-doi =        "10.1145/325694.325710",
  x-isbn =       "1581131259",
  x-url =        "http://dx.doi.org/10.1145/325694.325710",
  xpages =       "133--141",
  year =         "2000",
}

@Article{Sheard2002Template,
  author =       "Tim Sheard and Simon P. Jones",
  citeulike-article-id = "1342",
  citeulike-linkout-0 = "http://portal.acm.org/citation.cfm?id=636528",
  citeulike-linkout-1 = "http://dx.doi.org/10.1145/636517.636528",
  date-added =   "2004-12-01 22:38:37",
  day =          "01",
  journal =      "ACM SIGPLAN Notices",
  keywords =     "haskell, macros",
  number =       "12",
  publisher =    "ACM Press",
  title =        "Template meta-programming for Haskell",
  volume =       "37",
  x-doi =        "10.1145/636517.636528",
  x-issn =       "03621340",
  x-month =      dec,
  x-url =        "http://dx.doi.org/10.1145/636517.636528",
  xpages =       "60--75",
  year =         "2002",
}

@Proceedings{Brabrand2002Growing,
  author =       "Claus Brabrand and Michael I. Schwartzbach",
  booktitle =    "Proceedings of the 2002 ACM SIGPLAN workshop on
                 Partial evaluation and semantics-based program
                 manipulation",
  citeulike-article-id = "1340",
  citeulike-linkout-0 = "http://portal.acm.org/citation.cfm?id=503035",
  citeulike-linkout-1 = "http://dx.doi.org/10.1145/503032.503035",
  date-added =   "2004-12-01 22:38:28",
  keywords =     "macros",
  number =       "3",
  publisher =    "ACM Press",
  title =        "Growing languages with metamorphic syntax macros",
  volume =       "37",
  x-doi =        "10.1145/503032.503035",
  x-isbn =       "158113455X",
  x-month =      mar,
  x-url =        "http://dx.doi.org/10.1145/503032.503035",
  xpages =       "31--40",
  year =         "2002",
}

@Proceedings{Baker2002Maya,
  author =       "Jason Baker and Wilson C. Hsieh",
  booktitle =    "Proceedings of the ACM SIGPLAN 2002 Conference on
                 Programming language design and implementation",
  citeulike-article-id = "1339",
  citeulike-linkout-0 = "http://portal.acm.org/citation.cfm?id=512562",
  citeulike-linkout-1 = "http://dx.doi.org/10.1145/512529.512562",
  date-added =   "2004-12-01 22:38:18",
  keywords =     "java, macros",
  number =       "5",
  publisher =    "ACM Press",
  title =        "Maya: multiple-dispatch syntax extension in Java",
  volume =       "37",
  x-doi =        "10.1145/512529.512562",
  x-isbn =       "1581134630",
  x-month =      may,
  x-url =        "http://dx.doi.org/10.1145/512529.512562",
  xpages =       "270--281",
  year =         "2002",
}

@Proceedings{Bruggeman1996Representing,
  author =       "Carl Bruggeman and Oscar Waddell and R. Kent Dybvig",
  booktitle =    "Proceedings of the ACM SIGPLAN 1996 conference on
                 Programming language design and implementation",
  citeulike-article-id = "1336",
  citeulike-linkout-0 = "http://portal.acm.org/citation.cfm?id=231395",
  citeulike-linkout-1 = "http://dx.doi.org/10.1145/231379.231395",
  date-added =   "2004-12-01 22:34:13",
  keywords =     "continuations",
  number =       "5",
  publisher =    "ACM Press",
  title =        "Representing control in the presence of one-shot
                 continuations",
  volume =       "31",
  x-doi =        "10.1145/231379.231395",
  x-isbn =       "0897917952",
  x-month =      may,
  x-url =        "http://dx.doi.org/10.1145/231379.231395",
  xpages =       "99--107",
  year =         "1996",
}

@Article{Wand1980ContinuationBased,
  author =       "Mitchell Wand",
  citeulike-article-id = "1337",
  citeulike-linkout-0 = "http://portal.acm.org/citation.cfm?id=322183",
  citeulike-linkout-1 = "http://dx.doi.org/10.1145/322169.322183",
  date-added =   "2004-12-01 22:34:04",
  journal =      "J. ACM",
  keywords =     "continuations",
  number =       "1",
  publisher =    "ACM Press",
  title =        "{Continuation-Based} Program Transformation
                 Strategies",
  volume =       "27",
  x-doi =        "10.1145/322169.322183",
  x-issn =       "0004-5411",
  x-month =      jan,
  x-url =        "http://dx.doi.org/10.1145/322169.322183",
  xpages =       "164--180",
  year =         "1980",
}

@Proceedings{Sitaram1991Models,
  author =       "Dorai Sitaram and Matthias Felleisen",
  booktitle =    "Proceedings of the 18th ACM SIGPLAN-SIGACT symposium
                 on Principles of programming languages",
  citeulike-article-id = "1335",
  citeulike-linkout-0 = "http://portal.acm.org/citation.cfm?id=99611",
  citeulike-linkout-1 = "http://dx.doi.org/10.1145/99583.99611",
  date-added =   "2004-12-01 22:33:59",
  keywords =     "continuations",
  publisher =    "ACM Press",
  title =        "Models of continuations without continuations",
  x-doi =        "10.1145/99583.99611",
  x-isbn =       "0897914198",
  x-url =        "http://dx.doi.org/10.1145/99583.99611",
  xpages =       "185--196",
  year =         "1991",
}

@Proceedings{Sitaram1993Handling,
  author =       "Dorai Sitaram",
  booktitle =    "Proceedings of the ACM SIGPLAN 1993 conference on
                 Programming language design and implementation",
  citeulike-article-id = "1334",
  citeulike-linkout-0 = "http://portal.acm.org/citation.cfm?id=155104",
  citeulike-linkout-1 = "http://dx.doi.org/10.1145/155090.155104",
  date-added =   "2004-12-01 22:33:47",
  keywords =     "continuations",
  number =       "6",
  publisher =    "ACM Press",
  title =        "Handling control",
  volume =       "28",
  x-doi =        "10.1145/155090.155104",
  x-isbn =       "0897915984",
  x-month =      jun,
  x-url =        "http://dx.doi.org/10.1145/155090.155104",
  xpages =       "147--155",
  year =         "1993",
}

@Proceedings{Sitaram1990Reasoning,
  author =       "Dorai Sitaram and Matthias Felleisen",
  booktitle =    "Proceedings of the 1990 ACM conference on LISP and
                 functional programming",
  citeulike-article-id = "1333",
  citeulike-linkout-0 = "http://portal.acm.org/citation.cfm?id=91626",
  citeulike-linkout-1 = "http://dx.doi.org/10.1145/91556.91626",
  date-added =   "2004-12-01 22:33:40",
  keywords =     "continuations, denotational-semantics",
  publisher =    "ACM Press",
  title =        "Reasoning with continuations {II}: full abstraction
                 for models of control",
  x-doi =        "10.1145/91556.91626",
  x-isbn =       "089791368X",
  x-url =        "http://dx.doi.org/10.1145/91556.91626",
  xpages =       "161--175",
  year =         "1990",
}

@InProceedings{Steele1993Evolution,
  author =       "Guy L. Steele and Richard P. Gabriel",
  booktitle =    "The second ACM SIGPLAN conference on History of
                 programming languages",
  citeulike-article-id = "1338",
  citeulike-linkout-0 = "http://portal.acm.org/citation.cfm?id=155373",
  citeulike-linkout-1 = "http://dx.doi.org/10.1145/154766.155373",
  date-added =   "2004-12-01 22:33:17",
  keywords =     "lisp",
  location =     "Cambridge, Massachusetts, United States",
  number =       "3",
  publisher =    "ACM",
  title =        "The evolution of Lisp",
  volume =       "28",
  x-abstract =   "Lisp is the world's greatest programming language—or
                 so its proponents think. The structure of Lisp makes it
                 easy to extend the language or even to implement
                 entirely new dialects without starting from scratch.
                 Overall, the evolution of Lisp has been guided more by
                 institutional rivalry, one-upsmanship, and the glee
                 born of technical cleverness that is characteristic of
                 the ” hacker culture” than by sober assessments of
                 technical requirements. Nevertheless this process has
                 eventually produced both an industrial-strength
                 programming language, messy but powerful, and a
                 technically pure dialect, small but powerful, that is
                 suitable for use by programming-language
                 {theoreticians.We} pick up where {McCarthy}'s paper in
                 the first {HOPL} conference left off. We trace the
                 development chronologically from the era of the
                 {PDP}-6, through the heyday of Interlisp and {MacLisp},
                 past the ascension and decline of special purpose Lisp
                 machines, to the present era of standardization
                 activities. We then examine the technical evolution of
                 a few representative language features, including both
                 some notable successes and some notable failures, that
                 illuminate design issues that distinguish Lisp from
                 other programming languages. We also discuss the use of
                 Lisp as a laboratory for designing other programming
                 languages. We conclude with some reflections on the
                 forces that have driven the evolution of Lisp.",
  x-address =    "New York, NY, USA",
  x-doi =        "10.1145/154766.155373",
  x-isbn =       "0-89791-570-4",
  x-issn =       "0362-1340",
  x-month =      mar,
  x-series =     "HOPL-II",
  x-url =        "http://dx.doi.org/10.1145/154766.155373",
  xpages =       "231--270",
  year =         "1993",
}

@Proceedings{Duba1991Typing,
  author =       "Bruce Duba and Robert Harper and David Macqueen",
  booktitle =    "Proceedings of the 18th ACM SIGPLAN-SIGACT symposium
                 on Principles of programming languages",
  citeulike-article-id = "1332",
  citeulike-linkout-0 = "http://portal.acm.org/citation.cfm?id=99608",
  citeulike-linkout-1 = "http://dx.doi.org/10.1145/99583.99608",
  date-added =   "2004-12-01 22:33:10",
  keywords =     "continuations, ml, types",
  publisher =    "ACM Press",
  title =        "Typing first-class continuations in {ML}",
  x-doi =        "10.1145/99583.99608",
  x-isbn =       "0897914198",
  x-url =        "http://dx.doi.org/10.1145/99583.99608",
  xpages =       "163--173",
  year =         "1991",
}

@TechReport{Steele1979Design,
  author =       "Guy L. Steele and Gerald J. Sussman",
  citeulike-article-id = "1329",
  citeulike-linkout-0 = "http://portal.acm.org/citation.cfm?id=888849",
  date-added =   "2004-12-01 22:30:06",
  keywords =     "lambda-the-ultimate, programming, scheme",
  priority =     "0",
  publisher =    "Massachusetts Institute of Technology",
  title =        "Design of {LISP}-based Processors, or {SCHEME}: {A}
                 Dielectric {LISP}, or Finite Memories Considered
                 Harmful, or {LAMBDA}: The Ultimate Opcode",
  x-url =        "http://portal.acm.org/citation.cfm?id=888849",
  year =         "1979",
}

@TechReport{Sussman1975Interpreter,
  author =       "Gerald J. Sussman and Guy Steele",
  citeulike-article-id = "1330",
  citeulike-linkout-0 = "http://portal.acm.org/citation.cfm?id=889230",
  date-added =   "2004-12-01 22:29:59",
  keywords =     "programming, scheme",
  publisher =    "Massachusetts Institute of Technology",
  title =        "An Interpreter for Extended Lambda Calculus",
  x-url =        "http://portal.acm.org/citation.cfm?id=889230",
  year =         "1975",
}

@Proceedings{Steele1977Macaroni,
  author =       "Gl Steele",
  booktitle =    "Proceedings of the 1977 symposium on Artificial
                 intelligence and programming languages",
  citeulike-article-id = "1328",
  citeulike-linkout-0 = "http://portal.acm.org/citation.cfm?id=806933",
  citeulike-linkout-1 = "http://dx.doi.org/10.1145/872734.806933",
  date-added =   "2004-12-01 22:28:38",
  keywords =     "programming",
  number =       "8",
  publisher =    "ACM Press",
  title =        "Macaroni is better than spaghetti",
  volume =       "12",
  x-doi =        "10.1145/872734.806933",
  x-issn =       "0362-1340",
  x-month =      aug,
  x-url =        "http://dx.doi.org/10.1145/872734.806933",
  xpages =       "60--66",
  year =         "1977",
}

@TechReport{Steele1976Lambda,
  author =       "Guy L. Steele and Gerald J. Sussman",
  citeulike-article-id = "1179",
  citeulike-linkout-0 = "http://portal.acm.org/citation.cfm?id=889232",
  date-added =   "2004-12-01 22:27:52",
  keywords =     "lambda-the-ultimate, programming, scheme",
  priority =     "0",
  publisher =    "Massachusetts Institute of Technology",
  title =        "Lambda: The Ultimate Imperative",
  x-abstract =   "We demonstrate how to model the following common
                 programming constructs in terms of an applicative order
                 language similar to {LISP}: Simple Recursion,
                 Iteration, Compound Statements and Expressions, {GO}
                 {TO} and Assignment, {Continuation-Passing}, Escape
                 Expressions, Fluid Variables, Call by Name, Call by
                 Need, and Call by Reference. The models require only
                 (possibly self-referent) lambda application,
                 conditionals, and (rarely) assignment. No complex data
                 structures such as stacks are used. The models are
                 transparent, involving only local syntactic
                 transformations. This paper is partly tutorial in
                 intent, gathering all the models together for purposes
                 of context.",
  x-address =    "Cambridge, MA, USA",
  x-url =        "http://portal.acm.org/citation.cfm?id=889232",
  year =         "1976",
}

@TechReport{Steele1977Debunking,
  author =       "Guy L. Steele",
  citeulike-article-id = "1327",
  citeulike-linkout-0 = "http://portal.acm.org/citation.cfm?id=889250",
  date-added =   "2004-12-01 22:27:35",
  keywords =     "lambda-the-ultimate, programming, scheme",
  priority =     "0",
  publisher =    "Massachusetts Institute of Technology",
  title =        "Debunking the ``Expensive Procedure Call'''' Myth or,
                 Procedure Call Implementations Considered Harmful or,
                 {LAMDBA}: The Ultimate {GOTO}",
  x-url =        "http://portal.acm.org/citation.cfm?id=889250",
  year =         "1977",
}

@TechReport{Steele1978Art,
  author =       "Guy L. Steele and Gerald J. Sussman",
  citeulike-article-id = "1326",
  citeulike-linkout-0 = "http://portal.acm.org/citation.cfm?id=889253",
  comment =      "Maybe eventually he'll write the other parts. :)",
  date-added =   "2004-12-01 22:27:16",
  keywords =     "programming, scheme",
  priority =     "0",
  publisher =    "Massachusetts Institute of Technology",
  title =        "The Art of the Interpreter or, The Modularity Complex
                 (Parts Zero, One, and Two)",
  x-url =        "http://portal.acm.org/citation.cfm?id=889253",
  year =         "1978",
}

@TechReport{Steele1976LAMBDA,
  author =       "Guy L. Steele",
  citeulike-article-id = "1325",
  citeulike-linkout-0 = "http://portal.acm.org/citation.cfm?id=889239",
  date-added =   "2004-12-01 22:25:59",
  keywords =     "lambda-the-ultimate, programming, scheme",
  priority =     "0",
  publisher =    "Massachusetts Institute of Technology",
  title =        "{LAMBDA}: The Ultimate Declarative",
  x-abstract =   "In this paper, a sequel to ``Lambda: The Ultimate
                 Imperative,'''' a new view of LAMBDA as a {\it
                 renaming} operator is presented and contrasted with the
                 usual functional view taken by LISP. This view,
                 combined with the view of function invocation as a kind
                 of generalized GO TO, leads to several new insights
                 into the nature of the LISP evaluation mechanism and
                 the symmetry between form and function, evaluation and
                 application, and control and environment.",
  x-address =    "Cambridge, MA, USA",
  x-url =        "http://portal.acm.org/citation.cfm?id=889239",
  year =         "1976",
}

@InProceedings{Bruce1998Statically,
  author =       "Kim B. Bruce and Martin Odersky and Philip Wadler",
  booktitle =    "Proceedings of the 12th European Conference on
                 Object-Oriented Programming",
  citeulike-article-id = "1324",
  citeulike-linkout-0 = "http://portal.acm.org/citation.cfm?id=679691",
  date-added =   "2004-12-01 22:25:19",
  keywords =     "programming, types",
  publisher =    "Springer-Verlag",
  title =        "A Statically Safe Alternative to Virtual Types",
  x-abstract =   "An abstract is not available.",
  x-address =    "London, UK, UK",
  x-isbn =       "3-540-64737-6",
  x-series =     "ECCOP '98",
  x-url =        "http://portal.acm.org/citation.cfm?id=679691",
  xpages =       "523--549",
  year =         "1998",
}

@Proceedings{Simon1993Imperative,
  author =       "S. L. P. Simon and Philip Wadler",
  booktitle =    "Conference record of the Twentieth Annual ACM
                 SIGPLAN-SIGACT Symposium on Principles of Programming
                 Languages, Charleston, South Carolina",
  citeulike-article-id = "1214",
  citeulike-linkout-0 = "http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.53.2504",
  date-added =   "2004-11-30 19:36:15",
  keywords =     "haskell, monads, programming",
  title =        "Imperative Functional Programming",
  x-abstract =   "We present a new model, based on monads, for
                 performing input/output in a non-strict, purely
                 functional language. It is composable, extensible,
                 efficient, requires no extensions to the type system,
                 and extends smoothly to incorporate mixed-language
                 working and in-place array updates. 1 Introduction
                 Input/output has always appeared to be one of the less
                 satisfactory features of purely functional languages:
                 fitting action into the functional paradigm feels like
                 fitting a square block into a round ...",
  x-url =        "http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.53.2504",
  xpages =       "71--84",
  year =         "1993",
}

@Proceedings{Clinger1994Lambda,
  author =       "William D. Clinger and Lars T. Hansen",
  booktitle =    "Proceedings of the 1994 ACM conference on LISP and
                 functional programming",
  citeulike-article-id = "1165",
  citeulike-linkout-0 = "http://portal.acm.org/citation.cfm?id=182409.156786",
  citeulike-linkout-1 = "http://dx.doi.org/10.1145/182409.156786",
  date-added =   "2004-11-30 02:58:17",
  keywords =     "compiler, lambda-the-ultimate, scheme",
  priority =     "0",
  publisher =    "ACM Press",
  title =        "Lambda, the ultimate label or a simple optimizing
                 compiler for Scheme",
  x-doi =        "10.1145/182409.156786",
  x-isbn =       "0897916433",
  x-url =        "http://dx.doi.org/10.1145/182409.156786",
  xpages =       "128--139",
  year =         "1994",
}

@InProceedings{Flatt2002Composable,
  author =       "Matthew Flatt",
  booktitle =    "ICFP '02: Proceedings of the seventh ACM SIGPLAN
                 international conference on Functional programming",
  citeulike-article-id = "1164",
  citeulike-linkout-0 = "http://portal.acm.org/citation.cfm?id=581478.581486",
  citeulike-linkout-1 = "http://dx.doi.org/10.1145/581478.581486",
  date-added =   "2004-11-30 02:55:27",
  keywords =     "macros, modules, oopsla-paper, plt, scheme",
  location =     "Pittsburgh, PA, USA",
  number =       "9",
  publisher =    "ACM",
  title =        "Composable and compilable macros: you want it when?",
  volume =       "37",
  x-abstract =   "Many macro systems, especially for Lisp and Scheme,
                 allow macro transformers to perform general
                 computation. Moreover, the language for implementing
                 compile-time macro transformers is usually the same as
                 the language for implementing run-time functions. As a
                 side effect of this sharing, implementations tend to
                 allow the mingling of compile-time values and run-time
                 values, as well as values from separate compilations.
                 Such mingling breaks programming tools that must parse
                 code without executing it. Macro implementors avoid
                 harmful mingling by obeying certain macro-definition
                 protocols and by inserting phase-distinguishing
                 annotations into the code. However, the annotations are
                 fragile, the protocols are not enforced, and
                 programmers can only reason about the result in terms
                 of the compiler's implementation. {MzScheme}---the
                 language of the {PLT} Scheme tool suite---addresses the
                 problem through a macro system that separates
                 compilation without sacrificing the expressiveness of
                 macros.",
  x-address =    "New York, NY, USA",
  x-doi =        "10.1145/581478.581486",
  x-isbn =       "1-58113-487-8",
  x-issn =       "0362-1340",
  x-month =      sep,
  x-url =        "http://dx.doi.org/10.1145/581478.581486",
  xpages =       "72--83",
  year =         "2002",
}

@InProceedings{Clinger1991Macros,
  author =       "William Clinger and Jonathan Rees",
  booktitle =    "Proceedings of the 18th ACM SIGPLAN-SIGACT symposium
                 on Principles of programming languages",
  citeulike-article-id = "1163",
  citeulike-linkout-0 = "http://portal.acm.org/citation.cfm?id=99607",
  citeulike-linkout-1 = "http://dx.doi.org/10.1145/99583.99607",
  date-added =   "2004-11-30 02:49:33",
  keywords =     "macros, programming, scheme",
  location =     "Orlando, Florida, United States",
  publisher =    "ACM",
  title =        "Macros that work",
  x-abstract =   "An abstract is not available.",
  x-address =    "New York, NY, USA",
  x-doi =        "10.1145/99583.99607",
  x-isbn =       "0-89791-419-8",
  x-series =     "POPL '91",
  x-url =        "http://dx.doi.org/10.1145/99583.99607",
  xpages =       "155--162",
  year =         "1991",
}

@Proceedings{Allen2004Objectoriented,
  author =       "Eric Allen and David Chase and Victor Luchangco and
                 Jan-Willem Maessen and Guy Steele",
  booktitle =    "Proceedings of the 19th annual ACM SIGPLAN Conference
                 on Object-oriented programming, systems, languages, and
                 applications",
  citeulike-article-id = "1162",
  citeulike-linkout-0 = "http://portal.acm.org/citation.cfm?id=1029008",
  citeulike-linkout-1 = "http://dx.doi.org/10.1145/1028976.1029008",
  date-added =   "2004-11-30 02:46:09",
  keywords =     "programming, unit-checking",
  publisher =    "ACM Press",
  title =        "Object-oriented units of measurement",
  x-doi =        "10.1145/1028976.1029008",
  x-isbn =       "1581138319",
  x-url =        "http://dx.doi.org/10.1145/1028976.1029008",
  xpages =       "384--403",
  year =         "2004",
}
