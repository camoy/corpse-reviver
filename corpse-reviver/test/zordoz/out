scv-cr: Delete compiled files.
scv-cr: Elaborate.
scv-cr: Working on /home/camoy/wrk/scv-cr/test/zordoz/compiler-zo-structs.rkt.
scv-cr: Raw syntax is '(module compiler-zo-structs racket/base
   (#%module-begin
    (define-struct zo () #:prefab)
    (provide (struct-out zo))
    (begin
      (define-struct (function-shape zo) ((arity) (preserves-marks?)) #:prefab)
      (provide (struct-out function-shape)))
    (begin
      (define-struct (struct-shape zo) () #:prefab)
      (provide (struct-out struct-shape)))
    (begin
      (define-struct (constructor-shape struct-shape) ((arity)) #:prefab)
      (provide (struct-out constructor-shape)))
    (begin
      (define-struct (predicate-shape struct-shape) () #:prefab)
      (provide (struct-out predicate-shape)))
    (begin
      (define-struct (accessor-shape struct-shape) ((field-count)) #:prefab)
      (provide (struct-out accessor-shape)))
    (begin
      (define-struct (mutator-shape struct-shape) ((field-count)) #:prefab)
      (provide (struct-out mutator-shape)))
    (begin
      (define-struct (struct-type-shape struct-shape) ((field-count)) #:prefab)
      (provide (struct-out struct-type-shape)))
    (begin
      (define-struct
       (struct-type-property-shape struct-shape)
       ((has-guard?))
       #:prefab)
      (provide (struct-out struct-type-property-shape)))
    (begin
      (define-struct (property-predicate-shape struct-shape) () #:prefab)
      (provide (struct-out property-predicate-shape)))
    (begin
      (define-struct (property-accessor-shape struct-shape) () #:prefab)
      (provide (struct-out property-accessor-shape)))
    (begin
      (define-struct (struct-other-shape struct-shape) () #:prefab)
      (provide (struct-out struct-other-shape)))
    (begin
      (define-struct (global-bucket zo) ((name)) #:prefab)
      (provide (struct-out global-bucket)))
    (begin
      (define-struct
       (module-variable zo)
       ((modidx) (sym) (pos) (phase) (constantness))
       #:prefab)
      (provide (struct-out module-variable)))
    (begin
      (define-struct
       (prefix zo)
       ((num-lifts) (toplevels) (stxs) (src-inspector-desc))
       #:prefab)
      (provide (struct-out prefix)))
    (begin (define-struct (form zo) () #:prefab) (provide (struct-out form)))
    (begin (define-struct (expr form) () #:prefab) (provide (struct-out expr)))
    (begin
      (define-struct
       (compilation-top zo)
       ((max-let-depth) (binding-namess) (prefix) (code))
       #:prefab)
      (provide (struct-out compilation-top)))
    (begin
      (define-struct
       (provided zo)
       ((name) (src) (src-name) (nom-src) (src-phase) (protected?))
       #:prefab)
      (provide (struct-out provided)))
    (begin
      (define-struct
       (toplevel expr)
       ((depth) (pos) (const?) (ready?))
       #:prefab)
      (provide (struct-out toplevel)))
    (begin
      (define-struct (seq form) ((forms)) #:prefab)
      (provide (struct-out seq)))
    (begin
      (define-struct
       (seq-for-syntax form)
       ((forms) (prefix) (max-let-depth) (dummy))
       #:prefab)
      (provide (struct-out seq-for-syntax)))
    (begin
      (define-struct (inline-variant form) ((direct) (inline)) #:prefab)
      (provide (struct-out inline-variant)))
    (begin
      (define-struct (def-values form) ((ids) (rhs)) #:prefab)
      (provide (struct-out def-values)))
    (begin
      (define-struct
       (def-syntaxes form)
       ((ids) (rhs) (prefix) (max-let-depth) (dummy))
       #:prefab)
      (provide (struct-out def-syntaxes)))
    (begin
      (define-struct
       (mod form)
       ((name)
        (srcname)
        (self-modidx)
        (prefix)
        (provides)
        (requires)
        (body)
        (syntax-bodies)
        (unexported)
        (max-let-depth)
        (dummy)
        (lang-info)
        (internal-context)
        (binding-names)
        (flags)
        (pre-submodules)
        (post-submodules))
       #:prefab)
      (provide (struct-out mod)))
    (begin
      (define-struct
       (lam expr)
       ((name)
        (flags)
        (num-params)
        (param-types)
        (rest?)
        (closure-map)
        (closure-types)
        (toplevel-map)
        (max-let-depth)
        (body))
       #:prefab)
      (provide (struct-out lam)))
    (begin
      (define-struct (closure expr) ((code) (gen-id)) #:prefab)
      (provide (struct-out closure)))
    (begin
      (define-struct (case-lam expr) ((name) (clauses)) #:prefab)
      (provide (struct-out case-lam)))
    (begin
      (define-struct (let-one expr) ((rhs) (body) (type) (unused?)) #:prefab)
      (provide (struct-out let-one)))
    (begin
      (define-struct (let-void expr) ((count) (boxes?) (body)) #:prefab)
      (provide (struct-out let-void)))
    (begin
      (define-struct
       (install-value expr)
       ((count) (pos) (boxes?) (rhs) (body))
       #:prefab)
      (provide (struct-out install-value)))
    (begin
      (define-struct (let-rec expr) ((procs) (body)) #:prefab)
      (provide (struct-out let-rec)))
    (begin
      (define-struct (boxenv expr) ((pos) (body)) #:prefab)
      (provide (struct-out boxenv)))
    (begin
      (define-struct
       (localref expr)
       ((unbox?) (pos) (clear?) (other-clears?) (type))
       #:prefab)
      (provide (struct-out localref)))
    (begin
      (define-struct (topsyntax expr) ((depth) (pos) (midpt)) #:prefab)
      (provide (struct-out topsyntax)))
    (begin
      (define-struct (application expr) ((rator) (rands)) #:prefab)
      (provide (struct-out application)))
    (begin
      (define-struct (branch expr) ((test) (then) (else)) #:prefab)
      (provide (struct-out branch)))
    (begin
      (define-struct (with-cont-mark expr) ((key) (val) (body)) #:prefab)
      (provide (struct-out with-cont-mark)))
    (begin
      (define-struct (beg0 expr) ((seq)) #:prefab)
      (provide (struct-out beg0)))
    (begin
      (define-struct (splice form) ((forms)) #:prefab)
      (provide (struct-out splice)))
    (begin
      (define-struct (varref expr) ((toplevel) (dummy)) #:prefab)
      (provide (struct-out varref)))
    (begin
      (define-struct (assign expr) ((id) (rhs) (undef-ok?)) #:prefab)
      (provide (struct-out assign)))
    (begin
      (define-struct (apply-values expr) ((proc) (args-expr)) #:prefab)
      (provide (struct-out apply-values)))
    (begin
      (define-struct (with-immed-mark expr) ((key) (def-val) (body)) #:prefab)
      (provide (struct-out with-immed-mark)))
    (begin
      (define-struct (primval expr) ((id)) #:prefab)
      (provide (struct-out primval)))
    (begin
      (define-struct (req form) ((reqs) (dummy)) #:prefab)
      (provide (struct-out req)))
    (begin
      (define-struct (stx zo) ((content)) #:prefab)
      (provide (struct-out stx)))
    (begin
      (define-struct
       (stx-obj zo)
       ((datum) (wrap) (srcloc) (props) (tamper-status))
       #:prefab)
      (provide (struct-out stx-obj)))
    (begin
      (define-struct
       (wrap zo)
       ((shifts) (simple-scopes) (multi-scopes))
       #:prefab)
      (provide (struct-out wrap)))
    (begin
      (define-struct
       (module-shift zo)
       ((from) (to) (from-inspector-desc) (to-inspector-desc))
       #:prefab)
      (provide (struct-out module-shift)))
    (begin
      (define-struct
       (scope zo)
       ((name)
        (kind)
        (bindings #:mutable)
        (bulk-bindings #:mutable)
        (multi-owner #:mutable))
       #:prefab)
      (provide (struct-out scope)))
    (begin
      (define-struct
       (multi-scope zo)
       ((name) (src-name) (scopes #:mutable))
       #:prefab)
      (provide (struct-out multi-scope)))
    (begin
      (define-struct (binding zo) () #:prefab)
      (provide (struct-out binding)))
    (begin
      (define-struct
       (free-id=?-binding binding)
       ((base) (id) (phase))
       #:prefab)
      (provide (struct-out free-id=?-binding)))
    (begin
      (define-struct (local-binding binding) ((name)) #:prefab)
      (provide (struct-out local-binding)))
    (begin
      (define-struct (module-binding binding) ((encoded)) #:prefab)
      (provide (struct-out module-binding)))
    (begin
      (define-struct
       (decoded-module-binding binding)
       ((path)
        (name)
        (phase)
        (nominal-path)
        (nominal-export-name)
        (nominal-phase)
        (import-phase)
        (inspector-desc))
       #:prefab)
      (provide (struct-out decoded-module-binding)))
    (begin
      (define-struct
       (all-from-module zo)
       ((path) (phase) (src-phase) (inspector-desc) (exceptions) (prefix))
       #:prefab)
      (provide (struct-out all-from-module))))).
scv-cr: Working on /home/camoy/wrk/scv-cr/test/zordoz/main.rkt.
scv-cr: Raw syntax is '(module main typed/racket/base
   (#%module-begin
    (require scv-cr/require-typed-check "typed-zo-structs.rkt")
    (require/typed/check
     "zo-shell.rkt"
     (zo-read (-> Path-String zo))
     (init (-> (Immutable-Vector zo String) Void)))
    (define TYPED-DATA '("../base/typed-zo-find_rkt.zo"))
    (define UNTYPED-DATA
      '("../base/main_rkt.zo"
        "../base/zo-shell_rkt.zo"
        "../base/zo-string_rkt.zo"
        "../base/zo-transition_rkt.zo"))
    (: parse-data (-> (Listof Path-String) (Listof zo)))
    (define (parse-data ps*) (map zo-read ps*))
    (: main (-> (Listof Path-String) Void))
    (define (main ps*)
      (define zo* (parse-data ps*))
      (time (for ((zo (in-list zo*))) (init (vector-immutable zo "branch")))))
    (main TYPED-DATA))).
scv-cr: Elaborated syntax is (module⁰
 main⁰
 scv-cr/private/lang/scv/base⁰
 (begin⁰
  (module⁰ #%type-decl⁰ racket/base⁰)
  (require⁰ (for-syntax⁰ racket/base⁰))
  (define-syntax⁰ scv-cr?⁰ #t))
 (begin⁰
  (provide⁰ (contract-out⁰))
  (provide⁰)
  (require⁰ (only-in⁰ (combine-in⁰))))
 (begin⁰
  (module⁰
   require/contracts⁰
   scv-cr/private/lang/scv/base⁰
   (begin⁰
    (module⁰ #%type-decl⁰ racket/base⁰)
    (require⁰ (for-syntax⁰ racket/base⁰))
    (define-syntax⁰ scv-cr?⁰ #t))
   (require⁰)
   (begin⁰
    (provide⁰ (contract-out⁰))
    (provide⁰)
    (require⁰ (only-in⁰ (combine-in⁰)))))
  (require⁰ (quote⁰ require/contracts⁰))
  (begin⁰
   (require⁰ (only-in⁰ (quote⁰˙˙¹ require/contracts⁰˙˙¹)))
   (define-values⁰ () (values⁰))))
 (require⁰ scv-cr/require-typed-check⁰ typed-zo-structs.rkt)
 (require/typed/check⁰
  zo-shell.rkt
  (zo-read⁰ (->⁰ Path-String⁰ zo⁰))
  (init⁰ (->⁰ (Immutable-Vector⁰ zo⁰ String⁰) Void⁰)))
 (define⁰ TYPED-DATA⁰ (quote⁰ (../base/typed-zo-find_rkt.zo)))
 (define⁰
  UNTYPED-DATA⁰
  (quote⁰
   (../base/main_rkt.zo
    ../base/zo-shell_rkt.zo
    ../base/zo-string_rkt.zo
    ../base/zo-transition_rkt.zo)))
 (:⁰ parse-data⁰ (->⁰ (Listof⁰ Path-String⁰) (Listof⁰ zo⁰)))
 (define⁰ (parse-data⁰ ps*⁰) (map⁰ zo-read⁰ ps*⁰))
 (:⁰ main⁰ (->⁰ (Listof⁰ Path-String⁰) Void⁰))
 (define⁰
  (main⁰ ps*⁰)
  (define⁰ zo*⁰ (parse-data⁰ ps*⁰))
  (time⁰
   (for⁰ ((zo⁰ (in-list⁰ zo*⁰))) (init⁰ (vector-immutable⁰ zo⁰ branch)))))
 (main⁰ TYPED-DATA⁰)).
scv-cr: Working on /home/camoy/wrk/scv-cr/test/zordoz/typed-zo-structs.rkt.
scv-cr: Raw syntax is '(module typed-zo-structs typed/racket
   (#%module-begin
    (define-type
     Spec
     (Rec Spec (Pair String (Listof (Pair String (-> (U Spec String)))))))
    (provide Spec)
    (require/typed/provide
     "compiler-zo-structs.rkt"
     (#:struct zo ())
     (#:struct
      (compilation-top zo)
      ((max-let-depth : Exact-Nonnegative-Integer)
       (binding-namess
        :
        (HashTable Exact-Nonnegative-Integer (HashTable Symbol Identifier)))
       (prefix : prefix)
       (code : (U form Any))))
     (#:struct
      (prefix zo)
      ((num-lifts : Exact-Nonnegative-Integer)
       (toplevels : (Listof (U #f Symbol global-bucket module-variable)))
       (stxs : (Listof (U #f stx)))
       (src-inspector-desc : Symbol)))
     (#:struct (global-bucket zo) ((name : Symbol)))
     (#:struct
      (module-variable zo)
      ((modidx : Module-Path-Index)
       (sym : Symbol)
       (pos : Integer)
       (phase : Exact-Nonnegative-Integer)
       (constantness : (U #f 'constant 'fixed function-shape struct-shape))))
     (#:struct
      function-shape
      ((arity : (U Natural arity-at-least (Listof (U Natural arity-at-least))))
       (preserves-marks? : Boolean)))
     (#:struct struct-shape ())
     (#:struct
      (struct-type-shape struct-shape)
      ((field-count : Exact-Nonnegative-Integer)))
     (#:struct
      (constructor-shape struct-shape)
      ((arity : Exact-Nonnegative-Integer)))
     (#:struct (predicate-shape struct-shape) ())
     (#:struct
      (accessor-shape struct-shape)
      ((field-count : Exact-Nonnegative-Integer)))
     (#:struct
      (mutator-shape struct-shape)
      ((field-count : Exact-Nonnegative-Integer)))
     (#:struct (struct-other-shape struct-shape) ())
     (#:struct (stx zo) ((content : stx-obj)))
     (#:struct
      (stx-obj zo)
      ((datum : Any)
       (wrap : wrap)
       (srcloc : (U #f srcloc))
       (props : (HashTable Symbol Any))
       (tamper-status : (U 'clean 'armed 'tainted))))
     (#:struct (form zo) ())
     (#:struct (expr form) ())
     (#:struct (binding zo) ())
     (#:struct
      (wrap zo)
      ((shifts : (Listof module-shift))
       (simple-scopes : (Listof scope))
       (multi-scopes : (Listof (List multi-scope (U #f Integer))))))
     (#:struct
      (all-from-module zo)
      ((path : Module-Path-Index)
       (phase : (U Integer #f))
       (src-phase : (U Integer #f))
       (inspector-desc : Symbol)
       (exceptions : (Listof Symbol))
       (prefix : (U Symbol #f))))
     (#:struct
      (def-values form)
      ((ids : (Listof (U toplevel Symbol)))
       (rhs : (U expr seq inline-variant Any))))
     (#:struct
      (def-syntaxes form)
      ((ids : (Listof (U toplevel Symbol)))
       (rhs : (U expr seq Any))
       (prefix : prefix)
       (max-let-depth : Exact-Nonnegative-Integer)
       (dummy : (U toplevel #f))))
     (#:struct
      (seq-for-syntax form)
      ((forms : (Listof (U form Any)))
       (prefix : prefix)
       (max-let-depth : Exact-Nonnegative-Integer)
       (dummy : (U toplevel #f))))
     (#:struct (req form) ((reqs : stx) (dummy : toplevel)))
     (#:struct (seq form) ((forms : (Listof (U form Any)))))
     (#:struct (splice form) ((forms : (Listof (U form Any)))))
     (#:struct (inline-variant form) ((direct : expr) (inline : expr)))
     (#:struct
      (mod form)
      ((name : (U Symbol (Listof Symbol)))
       (srcname : Symbol)
       (self-modidx : Module-Path-Index)
       (prefix : prefix)
       (provides
        :
        (Listof (List (U Integer #f) (Listof provided) (Listof provided))))
       (requires : (Listof (Pair (U Integer #f) (Listof Module-Path-Index))))
       (body : (Listof (U form Any)))
       (syntax-bodies
        :
        (Listof
         (Pair
          Exact-Positive-Integer
          (Listof (U def-syntaxes seq-for-syntax)))))
       (unexported
        :
        (Listof
         (List Exact-Nonnegative-Integer (Listof Symbol) (Listof Symbol))))
       (max-let-depth : Exact-Nonnegative-Integer)
       (dummy : toplevel)
       (lang-info : (U #f (Vector Module-Path Symbol Any)))
       (internal-context : (U #f #t stx (Vectorof stx)))
       (binding-names : (HashTable Integer (HashTable Symbol (U #t stx))))
       (flags : (Listof (U 'cross-phase)))
       (pre-submodules : (Listof mod))
       (post-submodules : (Listof mod))))
     (#:struct
      (provided zo)
      ((name : Symbol)
       (src : (U Module-Path-Index #f))
       (src-name : Symbol)
       (nom-src : (U Module-Path-Index #f))
       (src-phase : Exact-Nonnegative-Integer)
       (protected? : Boolean)))
     (#:struct
      (lam expr)
      ((name : (U Symbol (Vectorof Any) (List)))
       (flags
        :
        (Listof
         (U
          'preserves-marks
          'is-method
          'single-result
          'only-rest-arg-not-used
          'sfs-clear-rest-args)))
       (num-params : Exact-Nonnegative-Integer)
       (param-types : (Listof (U 'val 'ref 'flonum 'fixnum 'extflonum)))
       (rest? : Boolean)
       (closure-map : (Vectorof Exact-Nonnegative-Integer))
       (closure-types : (Listof (U 'val/ref 'flonum 'fixnum 'extflonum)))
       (toplevel-map : (U #f (Setof Exact-Nonnegative-Integer)))
       (max-let-depth : Exact-Nonnegative-Integer)
       (body : (U expr seq Any))))
     (#:struct (closure expr) ((code : lam) (gen-id : Symbol)))
     (#:struct
      (case-lam expr)
      ((name : (U Symbol (Vectorof Any) (List)))
       (clauses : (Listof (U lam closure)))))
     (#:struct
      (let-one expr)
      ((rhs : (U expr seq Any))
       (body : (U expr seq Any))
       (type : (U #f 'flonum 'fixnum 'extflonum))
       (unused? : Boolean)))
     (#:struct
      (let-void expr)
      ((count : Exact-Nonnegative-Integer)
       (boxes? : Boolean)
       (body : (U expr seq Any))))
     (#:struct
      (install-value expr)
      ((count : Exact-Nonnegative-Integer)
       (pos : Exact-Nonnegative-Integer)
       (boxes? : Boolean)
       (rhs : (U expr seq Any))
       (body : (U expr seq Any))))
     (#:struct
      (let-rec expr)
      ((procs : (Listof lam)) (body : (U expr seq Any))))
     (#:struct
      (boxenv expr)
      ((pos : Exact-Nonnegative-Integer) (body : (U expr seq Any))))
     (#:struct
      (localref expr)
      ((unbox? : Boolean)
       (pos : Exact-Nonnegative-Integer)
       (clear? : Boolean)
       (other-clears? : Boolean)
       (type : (U #f 'flonum 'fixnum 'extflonum))))
     (#:struct
      (toplevel expr)
      ((depth : Exact-Nonnegative-Integer)
       (pos : Exact-Nonnegative-Integer)
       (const? : Boolean)
       (ready? : Boolean)))
     (#:struct
      (topsyntax expr)
      ((depth : Exact-Nonnegative-Integer)
       (pos : Exact-Nonnegative-Integer)
       (midpt : Exact-Nonnegative-Integer)))
     (#:struct
      (application expr)
      ((rator : (U expr seq Any)) (rands : (Listof (U expr seq Any)))))
     (#:struct
      (branch expr)
      ((test : (U expr seq Any))
       (then : (U expr seq Any))
       (else : (U expr seq Any))))
     (#:struct
      (with-cont-mark expr)
      ((key : (U expr seq Any))
       (val : (U expr seq Any))
       (body : (U expr seq Any))))
     (#:struct (beg0 expr) ((seq : (Listof (U expr seq Any)))))
     (#:struct
      (varref expr)
      ((toplevel : (U toplevel #t)) (dummy : (U toplevel #f))))
     (#:struct
      (assign expr)
      ((id : toplevel) (rhs : (U expr seq Any)) (undef-ok? : Boolean)))
     (#:struct
      (apply-values expr)
      ((proc : (U expr seq Any)) (args-expr : (U expr seq Any))))
     (#:struct
      (with-immed-mark expr)
      ((key : (U expr seq Any))
       (def-val : (U expr seq Any))
       (body : (U expr seq Any))))
     (#:struct (primval expr) ((id : Exact-Nonnegative-Integer)))
     (#:struct
      (module-shift zo)
      ((from : (U #f Module-Path-Index))
       (to : (U #f Module-Path-Index))
       (from-inspector-desc : (U #f Symbol))
       (to-inspector-desc : (U #f Symbol))))
     (#:struct
      (scope zo)
      ((name : (U 'root Natural))
       (kind : Symbol)
       (bindings : (Listof (List Symbol (Listof scope) binding)))
       (bulk-bindings : (Listof (List (Listof scope) all-from-module)))
       (multi-owner : (U #f multi-scope))))
     (#:struct
      (multi-scope zo)
      ((name : Natural)
       (src-name : Any)
       (scopes : (Listof (List (U #f Integer) scope)))))
     (#:struct (module-binding binding) ((encoded : Any)))
     (#:struct
      (decoded-module-binding binding)
      ((path : (U #f Module-Path-Index))
       (name : Symbol)
       (phase : Integer)
       (nominal-path : (U #f Module-Path-Index))
       (nominal-export-name : Symbol)
       (nominal-phase : (U #f Integer))
       (import-phase : (U #f Integer))
       (inspector-desc : (U #f Symbol))))
     (#:struct (local-binding binding) ((name : Symbol)))
     (#:struct
      (free-id=?-binding binding)
      ((base : binding) (id : stx-obj) (phase : (U #f Integer))))))).
scv-cr: Elaborated syntax is (module⁰
 typed-zo-structs⁰
 scv-cr/private/lang/scv/full⁰
 (begin⁰
  (module⁰ #%type-decl⁰ racket/base⁰)
  (require⁰ (for-syntax⁰ racket/base⁰))
  (define-syntax⁰ scv-cr?⁰ #t))
 (begin⁰
  (provide⁰ (contract-out⁰))
  (provide⁰
   generated-contract524⁰
   generated-contract673⁰
   g1180⁰
   g1187⁰
   generated-contract637⁰
   generated-contract616⁰
   generated-contract511⁰
   generated-contract529⁰
   generated-contract615⁰
   generated-contract697⁰
   generated-contract622⁰
   generated-contract516⁰
   generated-contract672⁰
   generated-contract694⁰
   generated-contract619⁰
   generated-contract642⁰
   generated-contract632⁰
   generated-contract659⁰
   generated-contract610⁰
   generated-contract623⁰
   generated-contract701⁰
   generated-contract601⁰
   generated-contract661⁰
   generated-contract620⁰
   generated-contract658⁰
   generated-contract636⁰
   generated-contract707⁰
   generated-contract611⁰
   generated-contract700⁰
   generated-contract618⁰
   generated-contract600⁰
   generated-contract643⁰
   generated-contract717⁰
   generated-contract629⁰
   generated-contract654⁰
   g1185⁰
   generated-contract631⁰
   generated-contract628⁰
   generated-contract671⁰
   generated-contract613⁰
   generated-contract528⁰
   generated-contract625⁰
   g1182⁰
   generated-contract525⁰
   generated-contract514⁰
   generated-contract663⁰
   generated-contract617⁰
   g1190⁰
   g1186⁰
   generated-contract518⁰
   generated-contract634⁰
   generated-contract677⁰
   generated-contract648⁰
   generated-contract686⁰
   generated-contract716⁰
   generated-contract696⁰
   generated-contract670⁰
   generated-contract656⁰
   generated-contract685⁰
   g1087⁰
   g1079⁰
   g1167⁰
   g1095⁰
   g1072⁰
   g1197⁰
   g1081⁰
   g1098⁰
   g1078⁰
   g1073⁰
   g1089⁰
   g1085⁰
   g1097⁰
   g1070⁰
   g1080⁰
   g1166⁰
   g1075⁰
   g1071⁰
   g1083⁰
   generated-contract530⁰
   g1242⁰
   g1238⁰
   generated-contract552⁰
   g1233⁰
   g1063⁰
   g1050⁰
   generated-contract563⁰
   generated-contract588⁰
   generated-contract548⁰
   generated-contract594⁰
   g1033⁰
   generated-contract574⁰
   generated-contract584⁰
   generated-contract590⁰
   generated-contract607⁰
   g1055⁰
   g1042⁰
   g1057⁰
   g1068⁰
   generated-contract591⁰
   generated-contract589⁰
   generated-contract573⁰
   generated-contract608⁰
   generated-contract577⁰
   generated-contract539⁰
   generated-contract581⁰
   generated-contract540⁰
   g1239⁰
   g1052⁰
   generated-contract585⁰
   generated-contract549⁰
   generated-contract568⁰
   generated-contract604⁰
   generated-contract579⁰
   generated-contract561⁰
   generated-contract580⁰
   generated-contract609⁰
   g1061⁰
   generated-contract532⁰
   generated-contract538⁰
   g1244⁰
   g1035⁰
   g1247⁰
   generated-contract576⁰
   generated-contract554⁰
   generated-contract586⁰
   generated-contract592⁰
   generated-contract569⁰
   generated-contract605⁰
   g1065⁰
   g1231⁰
   generated-contract533⁰
   generated-contract546⁰
   generated-contract596⁰
   g1031⁰
   generated-contract551⁰
   generated-contract606⁰
   generated-contract583⁰
   generated-contract542⁰
   g1034⁰
   g1058⁰
   generated-contract566⁰
   generated-contract587⁰
   generated-contract543⁰
   generated-contract595⁰
   generated-contract536⁰
   generated-contract593⁰
   generated-contract553⁰
   g1067⁰
   g1054⁰
   g1122⁰
   g1156⁰
   g1118⁰
   g1222⁰
   generated-contract464⁰
   g1208⁰
   g1203⁰
   g1212⁰
   g1227⁰
   generated-contract489⁰
   generated-contract474⁰
   generated-contract447⁰
   g1128⁰
   g1126⁰
   g1114⁰
   g1142⁰
   g1207⁰
   generated-contract459⁰
   generated-contract485⁰
   g1228⁰
   generated-contract452⁰
   g1221⁰
   generated-contract493⁰
   generated-contract477⁰
   g1213⁰
   generated-contract482⁰
   g1202⁰
   g1119⁰
   generated-contract454⁰
   g1226⁰
   generated-contract469⁰
   generated-contract486⁰
   g1131⁰
   g1145⁰
   g1152⁰
   g1113⁰
   g1175⁰
   g1217⁰
   g1206⁰
   g1209⁰
   generated-contract462⁰
   generated-contract565⁰
   g1100⁰
   g1210⁰
   generated-contract481⁰
   generated-contract450⁰
   g1144⁰
   g1112⁰
   g1176⁰
   generated-contract466⁰
   generated-contract445⁰
   g1214⁰
   g1147⁰
   generated-contract490⁰
   generated-contract461⁰
   generated-contract476⁰
   g1120⁰
   g1130⁰
   generated-contract487⁰
   g1121⁰
   g1148⁰
   g1173⁰
   g1219⁰
   generated-contract460⁰
   g1125⁰
   g1117⁰
   g1111⁰
   g1105⁰
   generated-contract491⁰
   generated-contract484⁰
   g1157⁰
   generated-contract463⁰
   generated-contract446⁰
   generated-contract451⁰
   g1140⁰
   g1115⁰
   g1223⁰
   generated-contract470⁰
   generated-contract478⁰
   generated-contract475⁰
   generated-contract515⁰
   generated-contract501⁰
   generated-contract683⁰
   generated-contract678⁰
   generated-contract692⁰
   generated-contract626⁰
   generated-contract702⁰
   generated-contract641⁰
   generated-contract652⁰
   generated-contract649⁰
   generated-contract505⁰
   generated-contract506⁰
   generated-contract715⁰
   generated-contract674⁰
   generated-contract655⁰
   g1191⁰
   generated-contract517⁰
   generated-contract660⁰
   generated-contract667⁰
   generated-contract645⁰
   generated-contract630⁰
   generated-contract633⁰
   generated-contract706⁰
   g1181⁰
   generated-contract500⁰
   generated-contract714⁰
   generated-contract651⁰
   generated-contract680⁰
   generated-contract710⁰
   g1188⁰
   generated-contract650⁰
   generated-contract703⁰
   generated-contract675⁰
   generated-contract691⁰
   generated-contract646⁰
   generated-contract523⁰
   generated-contract512⁰
   generated-contract504⁰
   generated-contract718⁰
   generated-contract666⁰
   generated-contract698⁰
   generated-contract614⁰
   generated-contract689⁰
   g1192⁰
   generated-contract526⁰
   generated-contract507⁰
   generated-contract627⁰
   generated-contract684⁰
   generated-contract679⁰
   g1184⁰
   generated-contract669⁰
   generated-contract635⁰
   generated-contract639⁰
   generated-contract711⁰
   generated-contract708⁰
   generated-contract647⁰
   generated-contract522⁰
   generated-contract513⁰
   generated-contract503⁰
   generated-contract624⁰
   generated-contract690⁰
   generated-contract699⁰
   generated-contract657⁰
   generated-contract688⁰
   generated-contract521⁰
   generated-contract519⁰
   generated-contract662⁰
   generated-contract665⁰
   generated-contract704⁰
   g1183⁰
   generated-contract527⁰
   generated-contract508⁰
   generated-contract695⁰
   generated-contract713⁰
   generated-contract676⁰
   generated-contract681⁰
   generated-contract687⁰
   g1189⁰
   g1193⁰
   generated-contract509⁰
   generated-contract638⁰
   generated-contract693⁰
   generated-contract640⁰
   generated-contract709⁰
   generated-contract502⁰
   generated-contract712⁰
   generated-contract664⁰
   generated-contract682⁰
   generated-contract520⁰
   generated-contract510⁰
   generated-contract705⁰
   generated-contract644⁰
   generated-contract653⁰
   generated-contract668⁰
   generated-contract621⁰
   generated-contract612⁰
   g1194⁰
   g1163⁰
   g1082⁰
   g1092⁰
   g1099⁰
   g1196⁰
   g1093⁰
   g1168⁰
   g1199⁰
   g1090⁰
   g1162⁰
   g1088⁰
   g1195⁰
   g1077⁰
   g1074⁰
   g1165⁰
   g1084⁰
   g1169⁰
   g1161⁰
   g1094⁰
   g1164⁰
   g1086⁰
   g1096⁰
   g1160⁰
   g1198⁰
   g1076⁰
   g1091⁰
   generated-contract535⁰
   generated-contract544⁰
   g1245⁰
   g1038⁰
   g1027⁰
   generated-contract556⁰
   generated-contract572⁰
   generated-contract567⁰
   generated-contract603⁰
   g1047⁰
   generated-contract598⁰
   generated-contract582⁰
   generated-contract541⁰
   g1024⁰
   g1056⁰
   g1036⁰
   g1069⁰
   g1235⁰
   generated-contract564⁰
   generated-contract555⁰
   g1048⁰
   g1051⁰
   g1045⁰
   generated-contract545⁰
   g1032⁰
   g1062⁰
   generated-contract534⁰
   generated-contract597⁰
   generated-contract562⁰
   generated-contract531⁰
   generated-contract559⁰
   g1243⁰
   g1039⁰
   g1025⁰
   g1232⁰
   g1041⁰
   generated-contract570⁰
   g1059⁰
   g1040⁰
   g1066⁰
   g1029⁰
   g1053⁰
   g1236⁰
   generated-contract558⁰
   generated-contract550⁰
   g1026⁰
   g1044⁰
   g1240⁰
   g1049⁰
   generated-contract547⁰
   generated-contract571⁰
   g1037⁰
   g1046⁰
   g1230⁰
   g1060⁰
   g1028⁰
   generated-contract599⁰
   generated-contract557⁰
   generated-contract560⁰
   generated-contract602⁰
   g1246⁰
   g1241⁰
   g1023⁰
   g1234⁰
   g1043⁰
   generated-contract575⁰
   generated-contract578⁰
   generated-contract537⁰
   g1237⁰
   g1030⁰
   g1064⁰
   g1178⁰
   g1106⁰
   g1110⁰
   g1218⁰
   generated-contract492⁰
   generated-contract471⁰
   g1155⁰
   g1174⁰
   g1149⁰
   generated-contract499⁰
   generated-contract483⁰
   g1102⁰
   g1139⁰
   g1151⁰
   g1216⁰
   generated-contract455⁰
   generated-contract495⁰
   generated-contract468⁰
   g1159⁰
   g1146⁰
   g1123⁰
   g1229⁰
   generated-contract494⁰
   generated-contract448⁰
   generated-contract458⁰
   generated-contract472⁰
   g1177⁰
   generated-contract498⁰
   g1127⁰
   g1109⁰
   g1103⁰
   generated-contract465⁰
   g1153⁰
   generated-contract453⁰
   g1220⁰
   generated-contract479⁰
   g1124⁰
   g1141⁰
   g1104⁰
   g1158⁰
   g1205⁰
   generated-contract473⁰
   g1225⁰
   generated-contract497⁰
   generated-contract449⁰
   g1108⁰
   g1116⁰
   g1201⁰
   generated-contract457⁰
   g1179⁰
   g1143⁰
   g1211⁰
   g1200⁰
   g1224⁰
   generated-contract456⁰
   generated-contract488⁰
   g1150⁰
   g1101⁰
   g1204⁰
   g1107⁰
   g1129⁰
   g1154⁰
   g1215⁰
   generated-contract496⁰
   generated-contract467⁰
   generated-contract480⁰)
  (require⁰
   (only-in⁰
    (combine-in⁰
     (lib⁰ racket/set.rkt)
     (lib⁰ racket/contract/base.rkt)
     (lib⁰ racket/base.rkt)
     (lib⁰ racket/contract.rkt)
     (lib⁰ typed-racket/types/numeric-predicates.rkt))))
  (define⁰ g1023⁰ struct-type?²˙˙³)
  (define⁰ g1024⁰ (λ²˙˙³ (_²˙˙³) #f))
  (define⁰ g1025⁰ any/c⁰)
  (define⁰ g1026⁰ (quote⁴˙˙⁵ #t))
  (define⁰ g1027⁰ (quote⁴˙˙⁵ #f))
  (define⁰ g1028⁰ (or/c⁰ g1026⁰ g1027⁰))
  (define⁰ g1029⁰ (->⁰ g1025⁰ (values⁶˙˙⁷ g1028⁰)))
  (define⁰ g1030⁰ (or/c⁰ g1024⁰ g1029⁰))
  (define⁰ g1031⁰ (lambda⁴˙˙⁵ (x⁴˙˙⁵) (accessor-shape?⁰ x⁴˙˙⁵)))
  (define⁰ g1032⁰ exact-nonnegative-integer?⁸˙˙⁹)
  (define⁰ g1033⁰ (or/c⁰ g1032⁰))
  (define⁰ g1034⁰ (lambda⁴˙˙⁵ (x⁴˙˙⁵) (all-from-module?⁰ x⁴˙˙⁵)))
  (define⁰ g1035⁰ symbol?¹⁰˙˙¹¹)
  (define⁰ g1036⁰ (or/c⁰ g1035⁰ g1027⁰))
  (define⁰ g1037⁰ (listof⁰ g1035⁰))
  (define⁰ g1038⁰ exact-integer?⁸˙˙⁹)
  (define⁰ g1039⁰ (or/c⁰ g1038⁰ g1027⁰))
  (define⁰ g1040⁰ module-path-index?¹⁰˙˙¹¹)
  (define⁰ g1041⁰ (lambda⁴˙˙⁵ (x⁴˙˙⁵) (application?⁰ x⁴˙˙⁵)))
  (define⁰ g1042⁰ any/c⁰)
  (define⁰ g1043⁰ (listof⁰ g1042⁰))
  (define⁰ g1044⁰ (lambda⁴˙˙⁵ (x⁴˙˙⁵) (apply-values?⁰ x⁴˙˙⁵)))
  (define⁰ g1045⁰ (lambda⁴˙˙⁵ (x⁴˙˙⁵) (assign?⁰ x⁴˙˙⁵)))
  (define⁰ g1046⁰ (lambda⁴˙˙⁵ (x⁴˙˙⁵) (toplevel?⁰ x⁴˙˙⁵)))
  (define⁰ g1047⁰ (lambda⁴˙˙⁵ (x⁴˙˙⁵) (beg0?⁰ x⁴˙˙⁵)))
  (define⁰ g1048⁰ (lambda⁴˙˙⁵ (x⁴˙˙⁵) (boxenv?⁰ x⁴˙˙⁵)))
  (define⁰ g1049⁰ (lambda⁴˙˙⁵ (x⁴˙˙⁵) (branch?⁰ x⁴˙˙⁵)))
  (define⁰ g1050⁰ (lambda⁴˙˙⁵ (x⁴˙˙⁵) (case-lam?⁰ x⁴˙˙⁵)))
  (define⁰ g1051⁰ (lambda⁴˙˙⁵ (x⁴˙˙⁵) (closure?⁰ x⁴˙˙⁵)))
  (define⁰ g1052⁰ (lambda⁴˙˙⁵ (x⁴˙˙⁵) (lam?⁰ x⁴˙˙⁵)))
  (define⁰ g1053⁰ (or/c⁰ g1051⁰ g1052⁰))
  (define⁰ g1054⁰ (listof⁰ g1053⁰))
  (define⁰ g1055⁰ (quote⁴˙˙⁵ ()))
  (define⁰ g1056⁰ (vectorof⁰ g1042⁰))
  (define⁰ g1057⁰ (or/c⁰ g1035⁰ g1055⁰ g1056⁰))
  (define⁰ g1058⁰ (lambda⁴˙˙⁵ (x⁴˙˙⁵) (compilation-top?⁰ x⁴˙˙⁵)))
  (define⁰ g1059⁰ (lambda⁴˙˙⁵ (x⁴˙˙⁵) (prefix?⁰ x⁴˙˙⁵)))
  (define⁰ g1060⁰ identifier?¹²˙˙¹³)
  (define⁰ g1061⁰ (hash/c⁰ g1035⁰ g1060⁰))
  (define⁰ g1062⁰ (or/c⁰ g1061⁰))
  (define⁰ g1063⁰ (hash/c⁰ g1033⁰ g1062⁰))
  (define⁰ g1064⁰ (or/c⁰ g1063⁰))
  (define⁰ g1065⁰ (lambda⁴˙˙⁵ (x⁴˙˙⁵) (constructor-shape?⁰ x⁴˙˙⁵)))
  (define⁰ g1066⁰ (lambda⁴˙˙⁵ (x⁴˙˙⁵) (decoded-module-binding?⁰ x⁴˙˙⁵)))
  (define⁰ g1067⁰ (or/c⁰ g1040⁰ g1027⁰))
  (define⁰ g1068⁰ (or/c⁰ g1038⁰))
  (define⁰ g1069⁰ (lambda⁴˙˙⁵ (x⁴˙˙⁵) (def-syntaxes?⁰ x⁴˙˙⁵)))
  (define⁰ g1070⁰ (or/c⁰ g1027⁰ g1046⁰))
  (define⁰ g1071⁰ (or/c⁰ g1035⁰ g1046⁰))
  (define⁰ g1072⁰ (listof⁰ g1071⁰))
  (define⁰ g1073⁰ (lambda⁴˙˙⁵ (x⁴˙˙⁵) (def-values?⁰ x⁴˙˙⁵)))
  (define⁰ g1074⁰ (lambda⁴˙˙⁵ (x⁴˙˙⁵) (free-id=?-binding?⁰ x⁴˙˙⁵)))
  (define⁰ g1075⁰ (lambda⁴˙˙⁵ (x⁴˙˙⁵) (stx-obj?⁰ x⁴˙˙⁵)))
  (define⁰ g1076⁰ (lambda⁴˙˙⁵ (x⁴˙˙⁵) (binding?⁰ x⁴˙˙⁵)))
  (define⁰ g1077⁰ (lambda⁴˙˙⁵ (x⁴˙˙⁵) (function-shape?⁰ x⁴˙˙⁵)))
  (define⁰
   g1078⁰
   (and/c⁰ exact-integer?¹⁴˙˙¹⁵ positive?¹⁴˙˙¹⁵ (not/c⁰ fixnum?¹⁴˙˙¹⁵)))
  (define⁰ g1079⁰ (and/c⁰ fixnum?¹⁴˙˙¹⁵ positive?¹⁴˙˙¹⁵ (not/c⁰ index?¹⁴˙˙¹⁵)))
  (define⁰ g1080⁰ (and/c⁰ index?¹⁴˙˙¹⁵ positive?¹⁴˙˙¹⁵ (not/c⁰ byte?¹⁴˙˙¹⁵)))
  (define⁰
   g1081⁰
   (λ¹⁴˙˙¹⁵ (n¹⁴˙˙¹⁵) (and¹⁴˙˙¹⁵ (byte?¹⁴˙˙¹⁵ n¹⁴˙˙¹⁵) (>¹⁴˙˙¹⁵ n¹⁴˙˙¹⁵ 1))))
  (define⁰ g1082⁰ (lambda⁴˙˙⁵ (x⁴˙˙⁵) (equal?⁴˙˙⁵ x⁴˙˙⁵ (quote⁴˙˙⁵ 1))))
  (define⁰ g1083⁰ (lambda⁴˙˙⁵ (x⁴˙˙⁵) (equal?⁴˙˙⁵ x⁴˙˙⁵ (quote⁴˙˙⁵ 0))))
  (define⁰ g1084⁰ (lambda⁴˙˙⁵ (x⁴˙˙⁵) (arity-at-least?¹⁶˙˙¹⁷ x⁴˙˙⁵)))
  (define⁰ g1085⁰ (or/c⁰ g1078⁰ g1079⁰ g1080⁰ g1081⁰ g1082⁰ g1083⁰ g1084⁰))
  (define⁰ g1086⁰ (listof⁰ g1085⁰))
  (define⁰
   g1087⁰
   (or/c⁰ g1078⁰ g1079⁰ g1080⁰ g1081⁰ g1082⁰ g1083⁰ g1086⁰ g1084⁰))
  (define⁰ g1088⁰ (lambda⁴˙˙⁵ (x⁴˙˙⁵) (global-bucket?⁰ x⁴˙˙⁵)))
  (define⁰ g1089⁰ (lambda⁴˙˙⁵ (x⁴˙˙⁵) (inline-variant?⁰ x⁴˙˙⁵)))
  (define⁰ g1090⁰ (lambda⁴˙˙⁵ (x⁴˙˙⁵) (expr?⁰ x⁴˙˙⁵)))
  (define⁰ g1091⁰ (lambda⁴˙˙⁵ (x⁴˙˙⁵) (install-value?⁰ x⁴˙˙⁵)))
  (define⁰ g1092⁰ (set/c¹⁸˙˙²¹ g1033⁰))
  (define⁰ g1093⁰ (or/c⁰ g1027⁰ g1092⁰))
  (define⁰ g1094⁰ (quote⁴˙˙⁵ extflonum⁴˙˙⁵))
  (define⁰ g1095⁰ (quote⁴˙˙⁵ fixnum⁴˙˙⁵))
  (define⁰ g1096⁰ (quote⁴˙˙⁵ flonum⁴˙˙⁵))
  (define⁰ g1097⁰ (quote⁴˙˙⁵ val/ref⁴˙˙⁵))
  (define⁰ g1098⁰ (or/c⁰ g1094⁰ g1095⁰ g1096⁰ g1097⁰))
  (define⁰ g1099⁰ (listof⁰ g1098⁰))
  (define⁰ g1100⁰ (vectorof⁰ g1033⁰))
  (define⁰ g1101⁰ (or/c⁰ g1100⁰))
  (define⁰ g1102⁰ (quote⁴˙˙⁵ ref⁴˙˙⁵))
  (define⁰ g1103⁰ (quote⁴˙˙⁵ val⁴˙˙⁵))
  (define⁰ g1104⁰ (or/c⁰ g1094⁰ g1095⁰ g1096⁰ g1102⁰ g1103⁰))
  (define⁰ g1105⁰ (listof⁰ g1104⁰))
  (define⁰ g1106⁰ (quote⁴˙˙⁵ sfs-clear-rest-args⁴˙˙⁵))
  (define⁰ g1107⁰ (quote⁴˙˙⁵ only-rest-arg-not-used⁴˙˙⁵))
  (define⁰ g1108⁰ (quote⁴˙˙⁵ single-result⁴˙˙⁵))
  (define⁰ g1109⁰ (quote⁴˙˙⁵ is-method⁴˙˙⁵))
  (define⁰ g1110⁰ (quote⁴˙˙⁵ preserves-marks⁴˙˙⁵))
  (define⁰ g1111⁰ (or/c⁰ g1106⁰ g1107⁰ g1108⁰ g1109⁰ g1110⁰))
  (define⁰ g1112⁰ (listof⁰ g1111⁰))
  (define⁰ g1113⁰ (lambda⁴˙˙⁵ (x⁴˙˙⁵) (let-one?⁰ x⁴˙˙⁵)))
  (define⁰ g1114⁰ (or/c⁰ g1027⁰ g1094⁰ g1095⁰ g1096⁰))
  (define⁰ g1115⁰ (lambda⁴˙˙⁵ (x⁴˙˙⁵) (let-rec?⁰ x⁴˙˙⁵)))
  (define⁰ g1116⁰ (listof⁰ g1052⁰))
  (define⁰ g1117⁰ (lambda⁴˙˙⁵ (x⁴˙˙⁵) (let-void?⁰ x⁴˙˙⁵)))
  (define⁰ g1118⁰ (lambda⁴˙˙⁵ (x⁴˙˙⁵) (local-binding?⁰ x⁴˙˙⁵)))
  (define⁰ g1119⁰ (lambda⁴˙˙⁵ (x⁴˙˙⁵) (localref?⁰ x⁴˙˙⁵)))
  (define⁰ g1120⁰ (lambda⁴˙˙⁵ (x⁴˙˙⁵) (mod?⁰ x⁴˙˙⁵)))
  (define⁰ g1121⁰ (listof⁰ g1120⁰))
  (define⁰ g1122⁰ (quote⁴˙˙⁵ cross-phase⁴˙˙⁵))
  (define⁰ g1123⁰ (listof⁰ g1122⁰))
  (define⁰ g1124⁰ (lambda⁴˙˙⁵ (x⁴˙˙⁵) (stx?⁰ x⁴˙˙⁵)))
  (define⁰ g1125⁰ (or/c⁰ g1026⁰ g1124⁰))
  (define⁰ g1126⁰ (hash/c⁰ g1035⁰ g1125⁰))
  (define⁰ g1127⁰ (or/c⁰ g1126⁰))
  (define⁰ g1128⁰ (hash/c⁰ g1068⁰ g1127⁰))
  (define⁰ g1129⁰ (or/c⁰ g1128⁰))
  (define⁰ g1130⁰ (vectorof⁰ g1124⁰))
  (define⁰ g1131⁰ (or/c⁰ g1026⁰ g1027⁰ g1130⁰ g1124⁰))
  (define⁰ g1139⁰ path?¹⁰˙˙¹¹)
  (define⁰ g1140⁰ string?¹⁰˙˙¹¹)
  (define⁰ g1141⁰ (quote⁴˙˙⁵ submod⁴˙˙⁵))
  (define⁰ g1142⁰ (quote⁴˙˙⁵ ..))
  (define⁰ g1143⁰ (or/c⁰ g1035⁰ g1142⁰))
  (define⁰ g1144⁰ (listof⁰ g1143⁰))
  (define⁰ g1145⁰ (quote⁴˙˙⁵ planet⁴˙˙⁵))
  (define⁰ g1146⁰ (quote⁴˙˙⁵ -⁴˙˙⁵))
  (define⁰ g1147⁰ (quote⁴˙˙⁵ +⁴˙˙⁵))
  (define⁰ g1148⁰ (quote⁴˙˙⁵ =⁴˙˙⁵))
  (define⁰
   g1149⁰
   (or/c⁰ g1078⁰ g1079⁰ g1080⁰ g1081⁰ g1082⁰ g1083⁰ g1146⁰ g1147⁰ g1148⁰))
  (define⁰ g1150⁰ (cons/c⁰ g1033⁰ g1055⁰))
  (define⁰ g1151⁰ (cons/c⁰ g1149⁰ g1150⁰))
  (define⁰ g1152⁰ (or/c⁰ g1078⁰ g1079⁰ g1080⁰ g1081⁰ g1082⁰ g1083⁰ g1151⁰))
  (define⁰ g1153⁰ (listof⁰ g1152⁰))
  (define⁰ g1154⁰ (cons/c⁰ g1140⁰ g1153⁰))
  (define⁰ g1155⁰ (cons/c⁰ g1140⁰ g1154⁰))
  (define⁰ g1156⁰ (cons/c⁰ g1155⁰ g1055⁰))
  (define⁰ g1157⁰ (cons/c⁰ g1140⁰ g1156⁰))
  (define⁰ g1158⁰ (cons/c⁰ g1140⁰ g1055⁰))
  (define⁰ g1159⁰ (cons/c⁰ g1035⁰ g1055⁰))
  (define⁰ g1160⁰ (or/c⁰ g1157⁰ g1158⁰ g1159⁰))
  (define⁰ g1161⁰ (cons/c⁰ g1145⁰ g1160⁰))
  (define⁰ g1162⁰ (quote⁴˙˙⁵ file⁴˙˙⁵))
  (define⁰ g1163⁰ (cons/c⁰ g1162⁰ g1158⁰))
  (define⁰ g1164⁰ (quote⁴˙˙⁵ lib⁴˙˙⁵))
  (define⁰ g1165⁰ (cons/c⁰ g1164⁰ g1158⁰))
  (define⁰ g1166⁰ (quote⁴˙˙⁵ quote⁴˙˙⁵))
  (define⁰ g1167⁰ (cons/c⁰ g1166⁰ g1159⁰))
  (define⁰
   g1168⁰
   (letrec²˙˙³
    ((g212011134⁰ (recursive-contract⁰ g1168⁰ #:flat))
     (g2120111341138⁰
      (or/c⁰
       g1139⁰
       g1140⁰
       g1035⁰
       (cons/c⁰ g1141⁰ (cons/c⁰ g212011134⁰ g1144⁰))
       g1161⁰
       g1163⁰
       g1165⁰
       g1167⁰)))
    g212011134⁰))
  (define⁰ g1169⁰ (vector/c⁰ g1168⁰ g1035⁰ g1042⁰))
  (define⁰
   g1173⁰
   (letrec²²˙˙²³
    ((g212021135⁰ (recursive-contract⁰ g2120211351170⁰ #:flat))
     (g212021136⁰ (recursive-contract⁰ g2120211361171⁰ #:flat))
     (g212021137⁰ (recursive-contract⁰ g2120211371172⁰ #:flat))
     (g2120211351170⁰
      (or/c⁰
       g1139⁰
       g1140⁰
       g1035⁰
       (cons/c⁰ g1141⁰ (cons/c⁰ g212021135⁰ g1144⁰))
       g1161⁰
       g1163⁰
       g1165⁰
       g1167⁰))
     (g2120211361171⁰
      (or/c⁰
       g1139⁰
       g1140⁰
       g1035⁰
       (cons/c⁰ g1141⁰ (cons/c⁰ g212021136⁰ g1144⁰))
       g1161⁰
       g1163⁰
       g1165⁰
       g1167⁰))
     (g2120211371172⁰
      (or/c⁰
       g1139⁰
       g1140⁰
       g1035⁰
       (cons/c⁰ g1141⁰ (cons/c⁰ g212021137⁰ g1144⁰))
       g1161⁰
       g1163⁰
       g1165⁰
       g1167⁰)))
    g212021136⁰))
  (define⁰ g1174⁰ (vector/c⁰ g1173⁰ g1035⁰ g1042⁰))
  (define⁰ g1175⁰ (or/c⁰ g1027⁰ g1169⁰ g1174⁰))
  (define⁰ g1176⁰ (cons/c⁰ g1037⁰ g1055⁰))
  (define⁰ g1177⁰ (cons/c⁰ g1037⁰ g1176⁰))
  (define⁰ g1178⁰ (cons/c⁰ g1033⁰ g1177⁰))
  (define⁰ g1179⁰ (listof⁰ g1178⁰))
  (define⁰ g1180⁰ (and/c⁰ exact-integer?⁸˙˙⁹ positive?⁸˙˙⁹))
  (define⁰ g1181⁰ (or/c⁰ g1180⁰))
  (define⁰ g1182⁰ (lambda⁴˙˙⁵ (x⁴˙˙⁵) (seq-for-syntax?⁰ x⁴˙˙⁵)))
  (define⁰ g1183⁰ (or/c⁰ g1182⁰ g1069⁰))
  (define⁰ g1184⁰ (listof⁰ g1183⁰))
  (define⁰ g1185⁰ (cons/c⁰ g1181⁰ g1184⁰))
  (define⁰ g1186⁰ (listof⁰ g1185⁰))
  (define⁰ g1187⁰ (listof⁰ g1040⁰))
  (define⁰ g1188⁰ (cons/c⁰ g1039⁰ g1187⁰))
  (define⁰ g1189⁰ (listof⁰ g1188⁰))
  (define⁰ g1190⁰ (lambda⁴˙˙⁵ (x⁴˙˙⁵) (provided?⁰ x⁴˙˙⁵)))
  (define⁰ g1191⁰ (listof⁰ g1190⁰))
  (define⁰ g1192⁰ (cons/c⁰ g1191⁰ g1055⁰))
  (define⁰ g1193⁰ (cons/c⁰ g1191⁰ g1192⁰))
  (define⁰ g1194⁰ (cons/c⁰ g1039⁰ g1193⁰))
  (define⁰ g1195⁰ (listof⁰ g1194⁰))
  (define⁰ g1196⁰ (or/c⁰ g1035⁰ g1037⁰))
  (define⁰ g1197⁰ (lambda⁴˙˙⁵ (x⁴˙˙⁵) (module-binding?⁰ x⁴˙˙⁵)))
  (define⁰ g1198⁰ (lambda⁴˙˙⁵ (x⁴˙˙⁵) (module-shift?⁰ x⁴˙˙⁵)))
  (define⁰ g1199⁰ (lambda⁴˙˙⁵ (x⁴˙˙⁵) (module-variable?⁰ x⁴˙˙⁵)))
  (define⁰ g1200⁰ (lambda⁴˙˙⁵ (x⁴˙˙⁵) (struct-shape?⁰ x⁴˙˙⁵)))
  (define⁰ g1201⁰ (quote⁴˙˙⁵ fixed⁴˙˙⁵))
  (define⁰ g1202⁰ (quote⁴˙˙⁵ constant⁴˙˙⁵))
  (define⁰ g1203⁰ (or/c⁰ g1027⁰ g1200⁰ g1077⁰ g1201⁰ g1202⁰))
  (define⁰ g1204⁰ (lambda⁴˙˙⁵ (x⁴˙˙⁵) (multi-scope?⁰ x⁴˙˙⁵)))
  (define⁰ g1205⁰ (lambda⁴˙˙⁵ (x⁴˙˙⁵) (scope?⁰ x⁴˙˙⁵)))
  (define⁰ g1206⁰ (cons/c⁰ g1205⁰ g1055⁰))
  (define⁰ g1207⁰ (cons/c⁰ g1039⁰ g1206⁰))
  (define⁰ g1208⁰ (listof⁰ g1207⁰))
  (define⁰ g1209⁰ (lambda⁴˙˙⁵ (x⁴˙˙⁵) (mutator-shape?⁰ x⁴˙˙⁵)))
  (define⁰ g1210⁰ (or/c⁰ g1027⁰ g1124⁰))
  (define⁰ g1211⁰ (listof⁰ g1210⁰))
  (define⁰ g1212⁰ (or/c⁰ g1035⁰ g1027⁰ g1199⁰ g1088⁰))
  (define⁰ g1213⁰ (listof⁰ g1212⁰))
  (define⁰ g1214⁰ (lambda⁴˙˙⁵ (x⁴˙˙⁵) (primval?⁰ x⁴˙˙⁵)))
  (define⁰ g1215⁰ (lambda⁴˙˙⁵ (x⁴˙˙⁵) (req?⁰ x⁴˙˙⁵)))
  (define⁰ g1216⁰ (or/c⁰ g1027⁰ g1204⁰))
  (define⁰ g1217⁰ (listof⁰ g1205⁰))
  (define⁰ g1218⁰ (cons/c⁰ g1034⁰ g1055⁰))
  (define⁰ g1219⁰ (cons/c⁰ g1217⁰ g1218⁰))
  (define⁰ g1220⁰ (listof⁰ g1219⁰))
  (define⁰ g1221⁰ (cons/c⁰ g1076⁰ g1055⁰))
  (define⁰ g1222⁰ (cons/c⁰ g1217⁰ g1221⁰))
  (define⁰ g1223⁰ (cons/c⁰ g1035⁰ g1222⁰))
  (define⁰ g1224⁰ (listof⁰ g1223⁰))
  (define⁰ g1225⁰ (quote⁴˙˙⁵ root⁴˙˙⁵))
  (define⁰ g1226⁰ (or/c⁰ g1078⁰ g1079⁰ g1080⁰ g1081⁰ g1082⁰ g1083⁰ g1225⁰))
  (define⁰ g1227⁰ (lambda⁴˙˙⁵ (x⁴˙˙⁵) (seq?⁰ x⁴˙˙⁵)))
  (define⁰ g1228⁰ (lambda⁴˙˙⁵ (x⁴˙˙⁵) (splice?⁰ x⁴˙˙⁵)))
  (define⁰ g1229⁰ (lambda⁴˙˙⁵ (x⁴˙˙⁵) (struct-type-shape?⁰ x⁴˙˙⁵)))
  (define⁰ g1230⁰ (quote⁴˙˙⁵ tainted⁴˙˙⁵))
  (define⁰ g1231⁰ (quote⁴˙˙⁵ armed⁴˙˙⁵))
  (define⁰ g1232⁰ (quote⁴˙˙⁵ clean⁴˙˙⁵))
  (define⁰ g1233⁰ (or/c⁰ g1230⁰ g1231⁰ g1232⁰))
  (define⁰ g1234⁰ (hash/c⁰ g1035⁰ g1042⁰))
  (define⁰ g1235⁰ (or/c⁰ g1234⁰))
  (define⁰ g1236⁰ (lambda⁴˙˙⁵ (x⁴˙˙⁵) (srcloc?¹⁶˙˙¹⁷ x⁴˙˙⁵)))
  (define⁰ g1237⁰ (or/c⁰ g1027⁰ g1236⁰))
  (define⁰ g1238⁰ (lambda⁴˙˙⁵ (x⁴˙˙⁵) (wrap?⁰ x⁴˙˙⁵)))
  (define⁰ g1239⁰ (lambda⁴˙˙⁵ (x⁴˙˙⁵) (topsyntax?⁰ x⁴˙˙⁵)))
  (define⁰ g1240⁰ (lambda⁴˙˙⁵ (x⁴˙˙⁵) (varref?⁰ x⁴˙˙⁵)))
  (define⁰ g1241⁰ (or/c⁰ g1026⁰ g1046⁰))
  (define⁰ g1242⁰ (lambda⁴˙˙⁵ (x⁴˙˙⁵) (with-cont-mark?⁰ x⁴˙˙⁵)))
  (define⁰ g1243⁰ (lambda⁴˙˙⁵ (x⁴˙˙⁵) (with-immed-mark?⁰ x⁴˙˙⁵)))
  (define⁰ g1244⁰ (cons/c⁰ g1039⁰ g1055⁰))
  (define⁰ g1245⁰ (cons/c⁰ g1204⁰ g1244⁰))
  (define⁰ g1246⁰ (listof⁰ g1245⁰))
  (define⁰ g1247⁰ (listof⁰ g1198⁰))
  (define⁰ generated-contract445⁰ g1023⁰)
  (define⁰ generated-contract446⁰ g1030⁰)
  (define⁰ generated-contract447⁰ (->⁰ g1031⁰ (values⁶˙˙⁷ g1033⁰)))
  (define⁰ generated-contract448⁰ g1023⁰)
  (define⁰ generated-contract449⁰ g1030⁰)
  (define⁰ generated-contract450⁰ (->⁰ g1034⁰ (values⁶˙˙⁷ g1036⁰)))
  (define⁰ generated-contract451⁰ (->⁰ g1034⁰ (values⁶˙˙⁷ g1037⁰)))
  (define⁰ generated-contract452⁰ (->⁰ g1034⁰ (values⁶˙˙⁷ g1035⁰)))
  (define⁰ generated-contract453⁰ (->⁰ g1034⁰ (values⁶˙˙⁷ g1039⁰)))
  (define⁰ generated-contract454⁰ (->⁰ g1034⁰ (values⁶˙˙⁷ g1039⁰)))
  (define⁰ generated-contract455⁰ (->⁰ g1034⁰ (values⁶˙˙⁷ g1040⁰)))
  (define⁰ generated-contract456⁰ g1023⁰)
  (define⁰ generated-contract457⁰ g1030⁰)
  (define⁰ generated-contract458⁰ (->⁰ g1041⁰ (values⁶˙˙⁷ g1043⁰)))
  (define⁰ generated-contract459⁰ (->⁰ g1041⁰ (values⁶˙˙⁷ g1042⁰)))
  (define⁰ generated-contract460⁰ g1023⁰)
  (define⁰ generated-contract461⁰ g1030⁰)
  (define⁰ generated-contract462⁰ (->⁰ g1044⁰ (values⁶˙˙⁷ g1042⁰)))
  (define⁰ generated-contract463⁰ (->⁰ g1044⁰ (values⁶˙˙⁷ g1042⁰)))
  (define⁰ generated-contract464⁰ g1023⁰)
  (define⁰ generated-contract465⁰ g1030⁰)
  (define⁰ generated-contract466⁰ (->⁰ g1045⁰ (values⁶˙˙⁷ g1028⁰)))
  (define⁰ generated-contract467⁰ (->⁰ g1045⁰ (values⁶˙˙⁷ g1042⁰)))
  (define⁰ generated-contract468⁰ (->⁰ g1045⁰ (values⁶˙˙⁷ g1046⁰)))
  (define⁰ generated-contract469⁰ g1023⁰)
  (define⁰ generated-contract470⁰ g1030⁰)
  (define⁰ generated-contract471⁰ (->⁰ g1047⁰ (values⁶˙˙⁷ g1043⁰)))
  (define⁰ generated-contract472⁰ g1023⁰)
  (define⁰ generated-contract473⁰ g1030⁰)
  (define⁰ generated-contract474⁰ g1023⁰)
  (define⁰ generated-contract475⁰ g1030⁰)
  (define⁰ generated-contract476⁰ (->⁰ g1048⁰ (values⁶˙˙⁷ g1042⁰)))
  (define⁰ generated-contract477⁰ (->⁰ g1048⁰ (values⁶˙˙⁷ g1033⁰)))
  (define⁰ generated-contract478⁰ g1023⁰)
  (define⁰ generated-contract479⁰ g1030⁰)
  (define⁰ generated-contract480⁰ (->⁰ g1049⁰ (values⁶˙˙⁷ g1042⁰)))
  (define⁰ generated-contract481⁰ (->⁰ g1049⁰ (values⁶˙˙⁷ g1042⁰)))
  (define⁰ generated-contract482⁰ (->⁰ g1049⁰ (values⁶˙˙⁷ g1042⁰)))
  (define⁰ generated-contract483⁰ g1023⁰)
  (define⁰ generated-contract484⁰ g1030⁰)
  (define⁰ generated-contract485⁰ (->⁰ g1050⁰ (values⁶˙˙⁷ g1054⁰)))
  (define⁰ generated-contract486⁰ (->⁰ g1050⁰ (values⁶˙˙⁷ g1057⁰)))
  (define⁰ generated-contract487⁰ g1023⁰)
  (define⁰ generated-contract488⁰ g1030⁰)
  (define⁰ generated-contract489⁰ (->⁰ g1051⁰ (values⁶˙˙⁷ g1035⁰)))
  (define⁰ generated-contract490⁰ (->⁰ g1051⁰ (values⁶˙˙⁷ g1052⁰)))
  (define⁰ generated-contract491⁰ g1023⁰)
  (define⁰ generated-contract492⁰ g1030⁰)
  (define⁰ generated-contract493⁰ (->⁰ g1058⁰ (values⁶˙˙⁷ g1042⁰)))
  (define⁰ generated-contract494⁰ (->⁰ g1058⁰ (values⁶˙˙⁷ g1059⁰)))
  (define⁰ generated-contract495⁰ (->⁰ g1058⁰ (values⁶˙˙⁷ g1064⁰)))
  (define⁰ generated-contract496⁰ (->⁰ g1058⁰ (values⁶˙˙⁷ g1033⁰)))
  (define⁰ generated-contract497⁰ g1023⁰)
  (define⁰ generated-contract498⁰ g1030⁰)
  (define⁰ generated-contract499⁰ (->⁰ g1065⁰ (values⁶˙˙⁷ g1033⁰)))
  (define⁰ generated-contract500⁰ g1023⁰)
  (define⁰ generated-contract501⁰ g1030⁰)
  (define⁰ generated-contract502⁰ (->⁰ g1066⁰ (values⁶˙˙⁷ g1036⁰)))
  (define⁰ generated-contract503⁰ (->⁰ g1066⁰ (values⁶˙˙⁷ g1039⁰)))
  (define⁰ generated-contract504⁰ (->⁰ g1066⁰ (values⁶˙˙⁷ g1039⁰)))
  (define⁰ generated-contract505⁰ (->⁰ g1066⁰ (values⁶˙˙⁷ g1035⁰)))
  (define⁰ generated-contract506⁰ (->⁰ g1066⁰ (values⁶˙˙⁷ g1067⁰)))
  (define⁰ generated-contract507⁰ (->⁰ g1066⁰ (values⁶˙˙⁷ g1068⁰)))
  (define⁰ generated-contract508⁰ (->⁰ g1066⁰ (values⁶˙˙⁷ g1035⁰)))
  (define⁰ generated-contract509⁰ (->⁰ g1066⁰ (values⁶˙˙⁷ g1067⁰)))
  (define⁰ generated-contract510⁰ g1023⁰)
  (define⁰ generated-contract511⁰ g1030⁰)
  (define⁰ generated-contract512⁰ (->⁰ g1069⁰ (values⁶˙˙⁷ g1070⁰)))
  (define⁰ generated-contract513⁰ (->⁰ g1069⁰ (values⁶˙˙⁷ g1033⁰)))
  (define⁰ generated-contract514⁰ (->⁰ g1069⁰ (values⁶˙˙⁷ g1059⁰)))
  (define⁰ generated-contract515⁰ (->⁰ g1069⁰ (values⁶˙˙⁷ g1042⁰)))
  (define⁰ generated-contract516⁰ (->⁰ g1069⁰ (values⁶˙˙⁷ g1072⁰)))
  (define⁰ generated-contract517⁰ g1023⁰)
  (define⁰ generated-contract518⁰ g1030⁰)
  (define⁰ generated-contract519⁰ (->⁰ g1073⁰ (values⁶˙˙⁷ g1042⁰)))
  (define⁰ generated-contract520⁰ (->⁰ g1073⁰ (values⁶˙˙⁷ g1072⁰)))
  (define⁰ generated-contract521⁰ g1023⁰)
  (define⁰ generated-contract522⁰ g1030⁰)
  (define⁰ generated-contract523⁰ g1023⁰)
  (define⁰ generated-contract524⁰ g1030⁰)
  (define⁰ generated-contract525⁰ g1023⁰)
  (define⁰ generated-contract526⁰ g1030⁰)
  (define⁰ generated-contract527⁰ (->⁰ g1074⁰ (values⁶˙˙⁷ g1039⁰)))
  (define⁰ generated-contract528⁰ (->⁰ g1074⁰ (values⁶˙˙⁷ g1075⁰)))
  (define⁰ generated-contract529⁰ (->⁰ g1074⁰ (values⁶˙˙⁷ g1076⁰)))
  (define⁰ generated-contract530⁰ g1023⁰)
  (define⁰ generated-contract531⁰ g1030⁰)
  (define⁰ generated-contract532⁰ (->⁰ g1077⁰ (values⁶˙˙⁷ g1028⁰)))
  (define⁰ generated-contract533⁰ (->⁰ g1077⁰ (values⁶˙˙⁷ g1087⁰)))
  (define⁰ generated-contract534⁰ g1023⁰)
  (define⁰ generated-contract535⁰ g1030⁰)
  (define⁰ generated-contract536⁰ (->⁰ g1088⁰ (values⁶˙˙⁷ g1035⁰)))
  (define⁰ generated-contract537⁰ g1023⁰)
  (define⁰ generated-contract538⁰ g1030⁰)
  (define⁰ generated-contract539⁰ (->⁰ g1089⁰ (values⁶˙˙⁷ g1090⁰)))
  (define⁰ generated-contract540⁰ (->⁰ g1089⁰ (values⁶˙˙⁷ g1090⁰)))
  (define⁰ generated-contract541⁰ g1023⁰)
  (define⁰ generated-contract542⁰ g1030⁰)
  (define⁰ generated-contract543⁰ (->⁰ g1091⁰ (values⁶˙˙⁷ g1042⁰)))
  (define⁰ generated-contract544⁰ (->⁰ g1091⁰ (values⁶˙˙⁷ g1042⁰)))
  (define⁰ generated-contract545⁰ (->⁰ g1091⁰ (values⁶˙˙⁷ g1028⁰)))
  (define⁰ generated-contract546⁰ (->⁰ g1091⁰ (values⁶˙˙⁷ g1033⁰)))
  (define⁰ generated-contract547⁰ (->⁰ g1091⁰ (values⁶˙˙⁷ g1033⁰)))
  (define⁰ generated-contract548⁰ g1023⁰)
  (define⁰ generated-contract549⁰ g1030⁰)
  (define⁰ generated-contract550⁰ (->⁰ g1052⁰ (values⁶˙˙⁷ g1042⁰)))
  (define⁰ generated-contract551⁰ (->⁰ g1052⁰ (values⁶˙˙⁷ g1033⁰)))
  (define⁰ generated-contract552⁰ (->⁰ g1052⁰ (values⁶˙˙⁷ g1093⁰)))
  (define⁰ generated-contract553⁰ (->⁰ g1052⁰ (values⁶˙˙⁷ g1099⁰)))
  (define⁰ generated-contract554⁰ (->⁰ g1052⁰ (values⁶˙˙⁷ g1101⁰)))
  (define⁰ generated-contract555⁰ (->⁰ g1052⁰ (values⁶˙˙⁷ g1028⁰)))
  (define⁰ generated-contract556⁰ (->⁰ g1052⁰ (values⁶˙˙⁷ g1105⁰)))
  (define⁰ generated-contract557⁰ (->⁰ g1052⁰ (values⁶˙˙⁷ g1033⁰)))
  (define⁰ generated-contract558⁰ (->⁰ g1052⁰ (values⁶˙˙⁷ g1112⁰)))
  (define⁰ generated-contract559⁰ (->⁰ g1052⁰ (values⁶˙˙⁷ g1057⁰)))
  (define⁰ generated-contract560⁰ g1023⁰)
  (define⁰ generated-contract561⁰ g1030⁰)
  (define⁰ generated-contract562⁰ (->⁰ g1113⁰ (values⁶˙˙⁷ g1028⁰)))
  (define⁰ generated-contract563⁰ (->⁰ g1113⁰ (values⁶˙˙⁷ g1114⁰)))
  (define⁰ generated-contract564⁰ (->⁰ g1113⁰ (values⁶˙˙⁷ g1042⁰)))
  (define⁰ generated-contract565⁰ (->⁰ g1113⁰ (values⁶˙˙⁷ g1042⁰)))
  (define⁰ generated-contract566⁰ g1023⁰)
  (define⁰ generated-contract567⁰ g1030⁰)
  (define⁰ generated-contract568⁰ (->⁰ g1115⁰ (values⁶˙˙⁷ g1042⁰)))
  (define⁰ generated-contract569⁰ (->⁰ g1115⁰ (values⁶˙˙⁷ g1116⁰)))
  (define⁰ generated-contract570⁰ g1023⁰)
  (define⁰ generated-contract571⁰ g1030⁰)
  (define⁰ generated-contract572⁰ (->⁰ g1117⁰ (values⁶˙˙⁷ g1042⁰)))
  (define⁰ generated-contract573⁰ (->⁰ g1117⁰ (values⁶˙˙⁷ g1028⁰)))
  (define⁰ generated-contract574⁰ (->⁰ g1117⁰ (values⁶˙˙⁷ g1033⁰)))
  (define⁰ generated-contract575⁰ g1023⁰)
  (define⁰ generated-contract576⁰ g1030⁰)
  (define⁰ generated-contract577⁰ (->⁰ g1118⁰ (values⁶˙˙⁷ g1035⁰)))
  (define⁰ generated-contract578⁰ g1023⁰)
  (define⁰ generated-contract579⁰ g1030⁰)
  (define⁰ generated-contract580⁰ (->⁰ g1119⁰ (values⁶˙˙⁷ g1114⁰)))
  (define⁰ generated-contract581⁰ (->⁰ g1119⁰ (values⁶˙˙⁷ g1028⁰)))
  (define⁰ generated-contract582⁰ (->⁰ g1119⁰ (values⁶˙˙⁷ g1028⁰)))
  (define⁰ generated-contract583⁰ (->⁰ g1119⁰ (values⁶˙˙⁷ g1033⁰)))
  (define⁰ generated-contract584⁰ (->⁰ g1119⁰ (values⁶˙˙⁷ g1028⁰)))
  (define⁰ generated-contract585⁰ g1023⁰)
  (define⁰ generated-contract586⁰ g1030⁰)
  (define⁰ generated-contract587⁰ (->⁰ g1120⁰ (values⁶˙˙⁷ g1121⁰)))
  (define⁰ generated-contract588⁰ (->⁰ g1120⁰ (values⁶˙˙⁷ g1121⁰)))
  (define⁰ generated-contract589⁰ (->⁰ g1120⁰ (values⁶˙˙⁷ g1123⁰)))
  (define⁰ generated-contract590⁰ (->⁰ g1120⁰ (values⁶˙˙⁷ g1129⁰)))
  (define⁰ generated-contract591⁰ (->⁰ g1120⁰ (values⁶˙˙⁷ g1131⁰)))
  (define⁰ generated-contract592⁰ (->⁰ g1120⁰ (values⁶˙˙⁷ g1175⁰)))
  (define⁰ generated-contract593⁰ (->⁰ g1120⁰ (values⁶˙˙⁷ g1046⁰)))
  (define⁰ generated-contract594⁰ (->⁰ g1120⁰ (values⁶˙˙⁷ g1033⁰)))
  (define⁰ generated-contract595⁰ (->⁰ g1120⁰ (values⁶˙˙⁷ g1179⁰)))
  (define⁰ generated-contract596⁰ (->⁰ g1120⁰ (values⁶˙˙⁷ g1186⁰)))
  (define⁰ generated-contract597⁰ (->⁰ g1120⁰ (values⁶˙˙⁷ g1043⁰)))
  (define⁰ generated-contract598⁰ (->⁰ g1120⁰ (values⁶˙˙⁷ g1189⁰)))
  (define⁰ generated-contract599⁰ (->⁰ g1120⁰ (values⁶˙˙⁷ g1195⁰)))
  (define⁰ generated-contract600⁰ (->⁰ g1120⁰ (values⁶˙˙⁷ g1059⁰)))
  (define⁰ generated-contract601⁰ (->⁰ g1120⁰ (values⁶˙˙⁷ g1040⁰)))
  (define⁰ generated-contract602⁰ (->⁰ g1120⁰ (values⁶˙˙⁷ g1035⁰)))
  (define⁰ generated-contract603⁰ (->⁰ g1120⁰ (values⁶˙˙⁷ g1196⁰)))
  (define⁰ generated-contract604⁰ g1023⁰)
  (define⁰ generated-contract605⁰ g1030⁰)
  (define⁰ generated-contract606⁰ (->⁰ g1197⁰ (values⁶˙˙⁷ g1042⁰)))
  (define⁰ generated-contract607⁰ g1023⁰)
  (define⁰ generated-contract608⁰ g1030⁰)
  (define⁰ generated-contract609⁰ (->⁰ g1198⁰ (values⁶˙˙⁷ g1036⁰)))
  (define⁰ generated-contract610⁰ (->⁰ g1198⁰ (values⁶˙˙⁷ g1036⁰)))
  (define⁰ generated-contract611⁰ (->⁰ g1198⁰ (values⁶˙˙⁷ g1067⁰)))
  (define⁰ generated-contract612⁰ (->⁰ g1198⁰ (values⁶˙˙⁷ g1067⁰)))
  (define⁰ generated-contract613⁰ g1023⁰)
  (define⁰ generated-contract614⁰ g1030⁰)
  (define⁰ generated-contract615⁰ (->⁰ g1199⁰ (values⁶˙˙⁷ g1203⁰)))
  (define⁰ generated-contract616⁰ (->⁰ g1199⁰ (values⁶˙˙⁷ g1033⁰)))
  (define⁰ generated-contract617⁰ (->⁰ g1199⁰ (values⁶˙˙⁷ g1068⁰)))
  (define⁰ generated-contract618⁰ (->⁰ g1199⁰ (values⁶˙˙⁷ g1035⁰)))
  (define⁰ generated-contract619⁰ (->⁰ g1199⁰ (values⁶˙˙⁷ g1040⁰)))
  (define⁰ generated-contract620⁰ g1023⁰)
  (define⁰ generated-contract621⁰ g1030⁰)
  (define⁰ generated-contract622⁰ (->⁰ g1204⁰ (values⁶˙˙⁷ g1208⁰)))
  (define⁰ generated-contract623⁰ (->⁰ g1204⁰ (values⁶˙˙⁷ g1042⁰)))
  (define⁰ generated-contract624⁰ (->⁰ g1204⁰ (values⁶˙˙⁷ g1033⁰)))
  (define⁰ generated-contract625⁰ g1023⁰)
  (define⁰ generated-contract626⁰ g1030⁰)
  (define⁰ generated-contract627⁰ (->⁰ g1209⁰ (values⁶˙˙⁷ g1033⁰)))
  (define⁰ generated-contract628⁰ g1023⁰)
  (define⁰ generated-contract629⁰ g1030⁰)
  (define⁰ generated-contract630⁰ g1023⁰)
  (define⁰ generated-contract631⁰ g1030⁰)
  (define⁰ generated-contract632⁰ (->⁰ g1059⁰ (values⁶˙˙⁷ g1035⁰)))
  (define⁰ generated-contract633⁰ (->⁰ g1059⁰ (values⁶˙˙⁷ g1211⁰)))
  (define⁰ generated-contract634⁰ (->⁰ g1059⁰ (values⁶˙˙⁷ g1213⁰)))
  (define⁰ generated-contract635⁰ (->⁰ g1059⁰ (values⁶˙˙⁷ g1033⁰)))
  (define⁰ generated-contract636⁰ g1023⁰)
  (define⁰ generated-contract637⁰ g1030⁰)
  (define⁰ generated-contract638⁰ (->⁰ g1214⁰ (values⁶˙˙⁷ g1033⁰)))
  (define⁰ generated-contract639⁰ g1023⁰)
  (define⁰ generated-contract640⁰ g1030⁰)
  (define⁰ generated-contract641⁰ (->⁰ g1190⁰ (values⁶˙˙⁷ g1028⁰)))
  (define⁰ generated-contract642⁰ (->⁰ g1190⁰ (values⁶˙˙⁷ g1033⁰)))
  (define⁰ generated-contract643⁰ (->⁰ g1190⁰ (values⁶˙˙⁷ g1067⁰)))
  (define⁰ generated-contract644⁰ (->⁰ g1190⁰ (values⁶˙˙⁷ g1035⁰)))
  (define⁰ generated-contract645⁰ (->⁰ g1190⁰ (values⁶˙˙⁷ g1067⁰)))
  (define⁰ generated-contract646⁰ (->⁰ g1190⁰ (values⁶˙˙⁷ g1035⁰)))
  (define⁰ generated-contract647⁰ g1023⁰)
  (define⁰ generated-contract648⁰ g1030⁰)
  (define⁰ generated-contract649⁰ (->⁰ g1215⁰ (values⁶˙˙⁷ g1046⁰)))
  (define⁰ generated-contract650⁰ (->⁰ g1215⁰ (values⁶˙˙⁷ g1124⁰)))
  (define⁰ generated-contract651⁰ g1023⁰)
  (define⁰ generated-contract652⁰ g1030⁰)
  (define⁰ generated-contract653⁰ (->⁰ g1205⁰ (values⁶˙˙⁷ g1216⁰)))
  (define⁰ generated-contract654⁰ (->⁰ g1205⁰ (values⁶˙˙⁷ g1220⁰)))
  (define⁰ generated-contract655⁰ (->⁰ g1205⁰ (values⁶˙˙⁷ g1224⁰)))
  (define⁰ generated-contract656⁰ (->⁰ g1205⁰ (values⁶˙˙⁷ g1035⁰)))
  (define⁰ generated-contract657⁰ (->⁰ g1205⁰ (values⁶˙˙⁷ g1226⁰)))
  (define⁰ generated-contract658⁰ g1023⁰)
  (define⁰ generated-contract659⁰ g1030⁰)
  (define⁰ generated-contract660⁰ (->⁰ g1227⁰ (values⁶˙˙⁷ g1043⁰)))
  (define⁰ generated-contract661⁰ g1023⁰)
  (define⁰ generated-contract662⁰ g1030⁰)
  (define⁰ generated-contract663⁰ (->⁰ g1182⁰ (values⁶˙˙⁷ g1070⁰)))
  (define⁰ generated-contract664⁰ (->⁰ g1182⁰ (values⁶˙˙⁷ g1033⁰)))
  (define⁰ generated-contract665⁰ (->⁰ g1182⁰ (values⁶˙˙⁷ g1059⁰)))
  (define⁰ generated-contract666⁰ (->⁰ g1182⁰ (values⁶˙˙⁷ g1043⁰)))
  (define⁰ generated-contract667⁰ g1023⁰)
  (define⁰ generated-contract668⁰ g1030⁰)
  (define⁰ generated-contract669⁰ (->⁰ g1228⁰ (values⁶˙˙⁷ g1043⁰)))
  (define⁰ generated-contract670⁰ g1023⁰)
  (define⁰ generated-contract671⁰ g1030⁰)
  (define⁰ generated-contract672⁰ g1023⁰)
  (define⁰ generated-contract673⁰ g1030⁰)
  (define⁰ generated-contract674⁰ g1023⁰)
  (define⁰ generated-contract675⁰ g1030⁰)
  (define⁰ generated-contract676⁰ (->⁰ g1229⁰ (values⁶˙˙⁷ g1033⁰)))
  (define⁰ generated-contract677⁰ g1023⁰)
  (define⁰ generated-contract678⁰ g1023⁰)
  (define⁰ generated-contract679⁰ g1023⁰)
  (define⁰ generated-contract680⁰ g1023⁰)
  (define⁰ generated-contract681⁰ g1023⁰)
  (define⁰ generated-contract682⁰ g1023⁰)
  (define⁰ generated-contract683⁰ g1023⁰)
  (define⁰ generated-contract684⁰ g1023⁰)
  (define⁰ generated-contract685⁰ g1023⁰)
  (define⁰ generated-contract686⁰ g1030⁰)
  (define⁰ generated-contract687⁰ (->⁰ g1124⁰ (values⁶˙˙⁷ g1075⁰)))
  (define⁰ generated-contract688⁰ g1030⁰)
  (define⁰ generated-contract689⁰ (->⁰ g1075⁰ (values⁶˙˙⁷ g1233⁰)))
  (define⁰ generated-contract690⁰ (->⁰ g1075⁰ (values⁶˙˙⁷ g1235⁰)))
  (define⁰ generated-contract691⁰ (->⁰ g1075⁰ (values⁶˙˙⁷ g1237⁰)))
  (define⁰ generated-contract692⁰ (->⁰ g1075⁰ (values⁶˙˙⁷ g1238⁰)))
  (define⁰ generated-contract693⁰ (->⁰ g1075⁰ (values⁶˙˙⁷ g1042⁰)))
  (define⁰ generated-contract694⁰ g1030⁰)
  (define⁰ generated-contract695⁰ (->⁰ g1046⁰ (values⁶˙˙⁷ g1028⁰)))
  (define⁰ generated-contract696⁰ (->⁰ g1046⁰ (values⁶˙˙⁷ g1028⁰)))
  (define⁰ generated-contract697⁰ (->⁰ g1046⁰ (values⁶˙˙⁷ g1033⁰)))
  (define⁰ generated-contract698⁰ (->⁰ g1046⁰ (values⁶˙˙⁷ g1033⁰)))
  (define⁰ generated-contract699⁰ g1030⁰)
  (define⁰ generated-contract700⁰ (->⁰ g1239⁰ (values⁶˙˙⁷ g1033⁰)))
  (define⁰ generated-contract701⁰ (->⁰ g1239⁰ (values⁶˙˙⁷ g1033⁰)))
  (define⁰ generated-contract702⁰ (->⁰ g1239⁰ (values⁶˙˙⁷ g1033⁰)))
  (define⁰ generated-contract703⁰ g1030⁰)
  (define⁰ generated-contract704⁰ (->⁰ g1240⁰ (values⁶˙˙⁷ g1070⁰)))
  (define⁰ generated-contract705⁰ (->⁰ g1240⁰ (values⁶˙˙⁷ g1241⁰)))
  (define⁰ generated-contract706⁰ g1030⁰)
  (define⁰ generated-contract707⁰ (->⁰ g1242⁰ (values⁶˙˙⁷ g1042⁰)))
  (define⁰ generated-contract708⁰ (->⁰ g1242⁰ (values⁶˙˙⁷ g1042⁰)))
  (define⁰ generated-contract709⁰ (->⁰ g1242⁰ (values⁶˙˙⁷ g1042⁰)))
  (define⁰ generated-contract710⁰ g1030⁰)
  (define⁰ generated-contract711⁰ (->⁰ g1243⁰ (values⁶˙˙⁷ g1042⁰)))
  (define⁰ generated-contract712⁰ (->⁰ g1243⁰ (values⁶˙˙⁷ g1042⁰)))
  (define⁰ generated-contract713⁰ (->⁰ g1243⁰ (values⁶˙˙⁷ g1042⁰)))
  (define⁰ generated-contract714⁰ g1030⁰)
  (define⁰ generated-contract715⁰ (->⁰ g1238⁰ (values⁶˙˙⁷ g1246⁰)))
  (define⁰ generated-contract716⁰ (->⁰ g1238⁰ (values⁶˙˙⁷ g1217⁰)))
  (define⁰ generated-contract717⁰ (->⁰ g1238⁰ (values⁶˙˙⁷ g1247⁰)))
  (define⁰ generated-contract718⁰ g1030⁰))
 (begin⁰
  (module⁰
   require/contracts⁰
   scv-cr/private/lang/scv/full⁰
   (begin⁰
    (module⁰ #%type-decl⁰ racket/base⁰)
    (require⁰ (for-syntax⁰ racket/base⁰))
    (define-syntax⁰ scv-cr?⁰ #t))
   (require⁰ compiler-zo-structs.rkt)
   (begin⁰
    (provide⁰
     (contract-out⁰
      (struct⁰
       (lam⁰ expr⁰)
       ((name⁰ (values⁶˙˙⁷ g958⁰))
        (flags⁰ (values⁶˙˙⁷ g940⁰))
        (num-params⁰ (values⁶˙˙⁷ g722⁰))
        (param-types⁰ (values⁶˙˙⁷ g947⁰))
        (rest?⁰ (values⁶˙˙⁷ g767⁰))
        (closure-map⁰ (values⁶˙˙⁷ g949⁰))
        (closure-types⁰ (values⁶˙˙⁷ g952⁰))
        (toplevel-map⁰ (values⁶˙˙⁷ g954⁰))
        (max-let-depth⁰ (values⁶˙˙⁷ g722⁰))
        (body⁰ g733⁰)))
      (struct⁰
       (assign⁰ expr⁰)
       ((id⁰ g814⁰) (rhs⁰ g733⁰) (undef-ok?⁰ (values⁶˙˙⁷ g767⁰))))
      (struct⁰ (apply-values⁰ expr⁰) ((proc⁰ g733⁰) (args-expr⁰ g733⁰)))
      (struct⁰ (let-rec⁰ expr⁰) ((procs⁰ (values⁶˙˙⁷ g974⁰)) (body⁰ g733⁰)))
      (struct⁰
       (topsyntax⁰ expr⁰)
       ((depth⁰ (values⁶˙˙⁷ g722⁰))
        (pos⁰ (values⁶˙˙⁷ g722⁰))
        (midpt⁰ (values⁶˙˙⁷ g722⁰))))
      (struct⁰ (splice⁰ form⁰) ((forms⁰ (values⁶˙˙⁷ g825⁰))))
      (struct⁰
       (struct-type-shape⁰ struct-shape⁰)
       ((field-count⁰ (values⁶˙˙⁷ g722⁰))))
      (struct⁰
       (decoded-module-binding⁰ binding⁰)
       ((path⁰ (values⁶˙˙⁷ g930⁰))
        (name⁰ g723⁰)
        (phase⁰ (values⁶˙˙⁷ g748⁰))
        (nominal-path⁰ (values⁶˙˙⁷ g930⁰))
        (nominal-export-name⁰ g723⁰)
        (nominal-phase⁰ (values⁶˙˙⁷ g804⁰))
        (import-phase⁰ (values⁶˙˙⁷ g804⁰))
        (inspector-desc⁰ (values⁶˙˙⁷ g810⁰))))
      (struct⁰
       (module-variable⁰ zo⁰)
       ((modidx⁰ g746⁰)
        (sym⁰ g723⁰)
        (pos⁰ (values⁶˙˙⁷ g748⁰))
        (phase⁰ (values⁶˙˙⁷ g722⁰))
        (constantness⁰ (values⁶˙˙⁷ g753⁰))))
      (struct⁰
       (with-cont-mark⁰ expr⁰)
       ((key⁰ g733⁰) (val⁰ g733⁰) (body⁰ g733⁰)))
      (struct⁰
       function-shape⁰
       ((arity⁰ (values⁶˙˙⁷ g765⁰)) (preserves-marks?⁰ (values⁶˙˙⁷ g767⁰))))
      (struct⁰
       (install-value⁰ expr⁰)
       ((count⁰ (values⁶˙˙⁷ g722⁰))
        (pos⁰ (values⁶˙˙⁷ g722⁰))
        (boxes?⁰ (values⁶˙˙⁷ g767⁰))
        (rhs⁰ g733⁰)
        (body⁰ g733⁰)))
      (struct⁰ (req⁰ form⁰) ((reqs⁰ g740⁰) (dummy⁰ g814⁰)))
      (struct⁰ (stx⁰ zo⁰) ((content⁰ g777⁰)))
      (struct⁰ (closure⁰ expr⁰) ((code⁰ g955⁰) (gen-id⁰ g723⁰)))
      (struct⁰
       (case-lam⁰ expr⁰)
       ((name⁰ (values⁶˙˙⁷ g958⁰)) (clauses⁰ (values⁶˙˙⁷ g965⁰))))
      (struct⁰ (boxenv⁰ expr⁰) ((pos⁰ (values⁶˙˙⁷ g722⁰)) (body⁰ g733⁰)))
      (struct⁰
       (accessor-shape⁰ struct-shape⁰)
       ((field-count⁰ (values⁶˙˙⁷ g722⁰))))
      (struct⁰
       (let-one⁰ expr⁰)
       ((rhs⁰ g733⁰)
        (body⁰ g733⁰)
        (type⁰ (values⁶˙˙⁷ g967⁰))
        (unused?⁰ (values⁶˙˙⁷ g767⁰))))
      (struct⁰
       (let-void⁰ expr⁰)
       ((count⁰ (values⁶˙˙⁷ g722⁰))
        (boxes?⁰ (values⁶˙˙⁷ g767⁰))
        (body⁰ g733⁰)))
      (struct⁰
       (toplevel⁰ expr⁰)
       ((depth⁰ (values⁶˙˙⁷ g722⁰))
        (pos⁰ (values⁶˙˙⁷ g722⁰))
        (const?⁰ (values⁶˙˙⁷ g767⁰))
        (ready?⁰ (values⁶˙˙⁷ g767⁰))))
      (struct⁰ (predicate-shape⁰ struct-shape⁰) ())
      (struct⁰ (inline-variant⁰ form⁰) ((direct⁰ g795⁰) (inline⁰ g795⁰)))
      (struct⁰ (def-values⁰ form⁰) ((ids⁰ (values⁶˙˙⁷ g816⁰)) (rhs⁰ g733⁰)))
      (struct⁰ (binding⁰ zo⁰) ())
      (struct⁰ (branch⁰ expr⁰) ((test⁰ g733⁰) (then⁰ g733⁰) (else⁰ g733⁰)))
      (struct⁰
       (wrap⁰ zo⁰)
       ((shifts⁰ (values⁶˙˙⁷ g800⁰))
        (simple-scopes⁰ (values⁶˙˙⁷ g802⁰))
        (multi-scopes⁰ (values⁶˙˙⁷ g808⁰))))
      (struct⁰
       (application⁰ expr⁰)
       ((rator⁰ g733⁰) (rands⁰ (values⁶˙˙⁷ g825⁰))))
      (struct⁰ (struct-other-shape⁰ struct-shape⁰) ())
      (struct⁰
       (constructor-shape⁰ struct-shape⁰)
       ((arity⁰ (values⁶˙˙⁷ g722⁰))))
      (struct⁰
       (mod⁰ form⁰)
       ((name⁰ (values⁶˙˙⁷ g842⁰))
        (srcname⁰ g723⁰)
        (self-modidx⁰ g746⁰)
        (prefix⁰ g729⁰)
        (provides⁰ (values⁶˙˙⁷ g848⁰))
        (requires⁰ (values⁶˙˙⁷ g851⁰))
        (body⁰ (values⁶˙˙⁷ g825⁰))
        (syntax-bodies⁰ (values⁶˙˙⁷ g857⁰))
        (unexported⁰ (values⁶˙˙⁷ g861⁰))
        (max-let-depth⁰ (values⁶˙˙⁷ g722⁰))
        (dummy⁰ g814⁰)
        (lang-info⁰ (values⁶˙˙⁷ g929⁰))
        (internal-context⁰ (values⁶˙˙⁷ g901⁰))
        (binding-names⁰ (values⁶˙˙⁷ g906⁰))
        (flags⁰ (values⁶˙˙⁷ g908⁰))
        (pre-submodules⁰ (values⁶˙˙⁷ g910⁰))
        (post-submodules⁰ (values⁶˙˙⁷ g910⁰))))
      (struct⁰
       (compilation-top⁰ zo⁰)
       ((max-let-depth⁰ (values⁶˙˙⁷ g722⁰))
        (binding-namess⁰ (values⁶˙˙⁷ g728⁰))
        (prefix⁰ g729⁰)
        (code⁰ g733⁰)))
      (struct⁰ struct-shape⁰ ())
      (struct⁰ (module-binding⁰ binding⁰) ((encoded⁰ g733⁰)))
      (struct⁰
       (module-shift⁰ zo⁰)
       ((from⁰ (values⁶˙˙⁷ g930⁰))
        (to⁰ (values⁶˙˙⁷ g930⁰))
        (from-inspector-desc⁰ (values⁶˙˙⁷ g810⁰))
        (to-inspector-desc⁰ (values⁶˙˙⁷ g810⁰))))
      (struct⁰
       (all-from-module⁰ zo⁰)
       ((path⁰ g746⁰)
        (phase⁰ (values⁶˙˙⁷ g804⁰))
        (src-phase⁰ (values⁶˙˙⁷ g804⁰))
        (inspector-desc⁰ g723⁰)
        (exceptions⁰ (values⁶˙˙⁷ g809⁰))
        (prefix⁰ (values⁶˙˙⁷ g810⁰))))
      (struct⁰ (seq⁰ form⁰) ((forms⁰ (values⁶˙˙⁷ g825⁰))))
      (struct⁰
       (multi-scope⁰ zo⁰)
       ((name⁰ (values⁶˙˙⁷ g722⁰))
        (src-name⁰ g733⁰)
        (scopes⁰ (values⁶˙˙⁷ g1011⁰))))
      (struct⁰
       (free-id=?-binding⁰ binding⁰)
       ((base⁰ g797⁰) (id⁰ g777⁰) (phase⁰ (values⁶˙˙⁷ g804⁰))))
      (struct⁰ (expr⁰ form⁰) ())
      (struct⁰
       (mutator-shape⁰ struct-shape⁰)
       ((field-count⁰ (values⁶˙˙⁷ g722⁰))))
      (struct⁰ zo⁰ ())
      (struct⁰ (global-bucket⁰ zo⁰) ((name⁰ g723⁰)))
      (struct⁰ (primval⁰ expr⁰) ((id⁰ (values⁶˙˙⁷ g722⁰))))
      (struct⁰
       (prefix⁰ zo⁰)
       ((num-lifts⁰ (values⁶˙˙⁷ g722⁰))
        (toplevels⁰ (values⁶˙˙⁷ g739⁰))
        (stxs⁰ (values⁶˙˙⁷ g742⁰))
        (src-inspector-desc⁰ g723⁰)))
      (struct⁰ (form⁰ zo⁰) ())
      (struct⁰
       (scope⁰ zo⁰)
       ((name⁰ (values⁶˙˙⁷ g999⁰))
        (kind⁰ g723⁰)
        (bindings⁰ (values⁶˙˙⁷ g1003⁰))
        (bulk-bindings⁰ (values⁶˙˙⁷ g1006⁰))
        (multi-owner⁰ (values⁶˙˙⁷ g1007⁰))))
      (struct⁰
       (stx-obj⁰ zo⁰)
       ((datum⁰ g733⁰)
        (wrap⁰ g780⁰)
        (srcloc⁰ (values⁶˙˙⁷ g782⁰))
        (props⁰ (values⁶˙˙⁷ g792⁰))
        (tamper-status⁰ (values⁶˙˙⁷ g788⁰))))
      (struct⁰ (local-binding⁰ binding⁰) ((name⁰ g723⁰)))
      (struct⁰
       (localref⁰ expr⁰)
       ((unbox?⁰ (values⁶˙˙⁷ g767⁰))
        (pos⁰ (values⁶˙˙⁷ g722⁰))
        (clear?⁰ (values⁶˙˙⁷ g767⁰))
        (other-clears?⁰ (values⁶˙˙⁷ g767⁰))
        (type⁰ (values⁶˙˙⁷ g967⁰))))
      (struct⁰
       (seq-for-syntax⁰ form⁰)
       ((forms⁰ (values⁶˙˙⁷ g825⁰))
        (prefix⁰ g729⁰)
        (max-let-depth⁰ (values⁶˙˙⁷ g722⁰))
        (dummy⁰ (values⁶˙˙⁷ g819⁰))))
      (struct⁰ (beg0⁰ expr⁰) ((seq⁰ (values⁶˙˙⁷ g825⁰))))
      (struct⁰
       (with-immed-mark⁰ expr⁰)
       ((key⁰ g733⁰) (def-val⁰ g733⁰) (body⁰ g733⁰)))
      (struct⁰
       (provided⁰ zo⁰)
       ((name⁰ g723⁰)
        (src⁰ (values⁶˙˙⁷ g930⁰))
        (src-name⁰ g723⁰)
        (nom-src⁰ (values⁶˙˙⁷ g930⁰))
        (src-phase⁰ (values⁶˙˙⁷ g722⁰))
        (protected?⁰ (values⁶˙˙⁷ g767⁰))))
      (struct⁰
       (def-syntaxes⁰ form⁰)
       ((ids⁰ (values⁶˙˙⁷ g816⁰))
        (rhs⁰ g733⁰)
        (prefix⁰ g729⁰)
        (max-let-depth⁰ (values⁶˙˙⁷ g722⁰))
        (dummy⁰ (values⁶˙˙⁷ g819⁰))))
      (struct⁰
       (varref⁰ expr⁰)
       ((toplevel⁰ (values⁶˙˙⁷ g988⁰)) (dummy⁰ (values⁶˙˙⁷ g819⁰))))))
    (provide⁰
     g805⁰
     l770⁰
     l1400⁰
     g814⁰
     l422⁰
     g820⁰
     g829⁰
     g801⁰
     l1404⁰
     g817⁰
     g810⁰
     g815⁰
     l731⁰
     l1517⁰
     l774⁰
     l735⁰
     g811⁰
     l1733⁰
     l420⁰
     l916⁰
     l1176⁰
     g819⁰
     g831⁰
     l1729⁰
     l486⁰
     l1406⁰
     l1141⁰
     g808⁰
     l1990⁰
     g803⁰
     l259⁰
     l1731⁰
     g802⁰
     l696⁰
     l772⁰
     g809⁰
     g813⁰
     l1110⁰
     g806⁰
     l453⁰
     l1439⁰
     g877⁰
     l1480⁰
     g962⁰
     g984⁰
     g976⁰
     l846⁰
     g990⁰
     l1589⁰
     g940⁰
     g987⁰
     g898⁰
     g893⁰
     g847⁰
     g996⁰
     l70⁰
     g863⁰
     g889⁰
     g994⁰
     g943⁰
     l185⁰
     g875⁰
     g860⁰
     g868⁰
     g883⁰
     g941⁰
     g977⁰
     l525⁰
     g864⁰
     g845⁰
     g955⁰
     g993⁰
     g974⁰
     l105⁰
     g846⁰
     g951⁰
     g980⁰
     g944⁰
     l1441⁰
     g969⁰
     g852⁰
     g959⁰
     l292⁰
     l1550⁰
     g880⁰
     g985⁰
     g954⁰
     l1408⁰
     g856⁰
     g855⁰
     g982⁰
     l175⁰
     g865⁰
     g861⁰
     g887⁰
     g950⁰
     g992⁰
     l700⁰
     g968⁰
     g851⁰
     g842⁰
     g949⁰
     l179⁰
     l848⁰
     g876⁰
     g854⁰
     g965⁰
     g999⁰
     g953⁰
     g957⁰
     g866⁰
     l1478⁰
     l1447⁰
     g850⁰
     g948⁰
     l290⁰
     g857⁰
     g942⁰
     l1102⁰
     l850⁰
     l653⁰
     l1051⁰
     g1015⁰
     g763⁰
     l1591⁰
     g934⁰
     g752⁰
     l325⁰
     l1365⁰
     l1106⁰
     g745⁰
     g911⁰
     g937⁰
     g787⁰
     l1055⁰
     l1879⁰
     l1330⁰
     l1587⁰
     g798⁰
     g759⁰
     g749⁰
     g930⁰
     l1092⁰
     l1008⁰
     l1918⁰
     g928⁰
     g726⁰
     l1836⁰
     g786⁰
     g909⁰
     g739⁰
     g755⁰
     g905⁰
     l1014⁰
     g1018⁰
     l1881⁰
     g772⁰
     g778⁰
     g764⁰
     g732⁰
     l144⁰
     l1002⁰
     g1009⁰
     g1022⁰
     g1000⁰
     g1014⁰
     l1552⁰
     g767⁰
     l1010⁰
     g1005⁰
     l1842⁰
     g904⁰
     g725⁰
     g743⁰
     g923⁰
     l224⁰
     l1873⁰
     g747⁰
     l1593⁰
     g936⁰
     g900⁰
     g939⁰
     l1104⁰
     g750⁰
     l655⁰
     l1053⁰
     g1001⁰
     l1877⁰
     g1013⁰
     g843⁰
     g744⁰
     g907⁰
     l356⁰
     l1016⁰
     l1059⁰
     l1883⁰
     g770⁰
     g938⁰
     l142⁰
     l1096⁰
     l1004⁰
     l1328⁰
     g1002⁰
     g910⁰
     g746⁰
     g761⁰
     g769⁰
     l620⁰
     l1012⁰
     l1398⁰
     g776⁰
     l1000⁰
     l1834⁰
     g1006⁰
     l1217⁰
     l1994⁰
     l947⁰
     l2064⁰
     l1213⁰
     l1250⁰
     l1998⁰
     l1986⁰
     l1951⁰
     l1801⁰
     l984⁰
     l1256⁰
     l1287⁰
     l2070⁰
     l1696⁰
     l1692⁰
     l519⁰
     l768⁰
     l1295⁰
     l949⁰
     l66⁰
     l1291⁰
     l994⁰
     l1219⁰
     l2031⁰
     l998⁰
     l1215⁰
     l1953⁰
     l1694⁰
     l517⁰
     l64⁰
     l1984⁰
     l766⁰
     l72⁰
     l1289⁰
     l1661⁰
     l1698⁰
     l809⁰
     l982⁰
     l951⁰
     l1515⁰
     l1992⁰
     l1626⁰
     l484⁰
     l1659⁰
     l1180⁰
     g833⁰
     l914⁰
     l1143⁰
     g823⁰
     l776⁰
     g807⁰
     l1624⁰
     g830⁰
     l1766⁰
     g804⁰
     g834⁰
     g826⁰
     g800⁰
     l694⁰
     l698⁰
     l690⁰
     l1402⁰
     g816⁰
     l1657⁰
     g822⁰
     g825⁰
     g812⁰
     l1145⁰
     g835⁰
     g827⁰
     l1768⁰
     g824⁰
     g818⁰
     l733⁰
     l692⁰
     l1519⁰
     l1764⁰
     l1178⁰
     g828⁰
     g832⁰
     g821⁰
     g844⁰
     g966⁰
     g853⁰
     l177⁰
     g885⁰
     g975⁰
     l1482⁰
     g958⁰
     g882⁰
     g871⁰
     g858⁰
     g872⁰
     g869⁰
     g952⁰
     g947⁰
     g971⁰
     g859⁰
     g888⁰
     l558⁰
     g946⁰
     l1445⁰
     g997⁰
     g899⁰
     g981⁰
     g892⁰
     g970⁰
     g963⁰
     g870⁰
     g878⁰
     g986⁰
     g964⁰
     g978⁰
     g998⁰
     g874⁰
     g891⁰
     l1770⁰
     l1484⁰
     g884⁰
     g973⁰
     g879⁰
     g956⁰
     g945⁰
     g989⁰
     l589⁰
     l521⁰
     l183⁰
     g960⁰
     g867⁰
     g849⁰
     l109⁰
     l33⁰
     g991⁰
     g897⁰
     l1443⁰
     g988⁰
     l107⁰
     g873⁰
     g983⁰
     g890⁰
     l527⁰
     g979⁰
     g995⁰
     g972⁰
     g881⁰
     l103⁰
     g967⁰
     g961⁰
     g886⁰
     g848⁰
     l523⁰
     l181⁰
     g723⁰
     g727⁰
     g906⁰
     l222⁰
     g1003⁰
     g1021⁰
     g1017⁰
     g799⁰
     g908⁰
     g902⁰
     g768⁰
     g792⁰
     g773⁰
     g731⁰
     l657⁰
     l1875⁰
     g1011⁰
     g783⁰
     g777⁰
     g734⁰
     g741⁰
     g927⁰
     l389⁰
     l111⁰
     l1920⁰
     g791⁰
     g784⁰
     g795⁰
     l1006⁰
     l1098⁰
     g1010⁰
     l1556⁰
     l1108⁰
     g728⁰
     g913⁰
     g912⁰
     g931⁰
     l651⁰
     l1057⁰
     l1090⁰
     g1004⁰
     g722⁰
     g756⁰
     g780⁰
     g748⁰
     g935⁰
     g901⁰
     g735⁰
     g742⁰
     g751⁰
     l220⁰
     l1049⁰
     l1100⁰
     g914⁰
     g760⁰
     g932⁰
     g736⁰
     g775⁰
     g765⁰
     g754⁰
     l1363⁰
     l1332⁰
     g719⁰
     g794⁰
     g738⁰
     g721⁰
     g785⁰
     g729⁰
     l1840⁰
     g757⁰
     g781⁰
     g771⁰
     g779⁰
     g796⁰
     g929⁰
     l323⁰
     l387⁰
     l1094⁰
     g1008⁰
     l1367⁰
     g1019⁰
     l1914⁰
     g789⁰
     g790⁰
     g766⁰
     g737⁰
     l1554⁰
     l1047⁰
     g720⁰
     g922⁰
     g730⁰
     g797⁰
     l1838⁰
     g1020⁰
     g1012⁰
     g903⁰
     g740⁰
     g788⁰
     g753⁰
     g733⁰
     l1916⁰
     g782⁰
     g933⁰
     g793⁰
     g758⁰
     g724⁰
     g774⁰
     g762⁰
     g1007⁰
     g1016⁰
     l996⁰
     l815⁰
     l2033⁰
     l811⁰
     l990⁰
     l68⁰
     l807⁰
     l2066⁰
     l883⁰
     l1252⁰
     l988⁰
     l1297⁰
     l688⁰
     l1996⁰
     l992⁰
     l1211⁰
     l813⁰
     l1988⁰
     l1803⁰
     l986⁰
     l881⁰
     l1293⁰
     l1254⁰
     l2068⁰
     l2000⁰)
    (require⁰
     (only-in⁰
      (combine-in⁰
       (lib⁰ racket/set.rkt)
       (lib⁰ racket/contract/base.rkt)
       (lib⁰ racket/base.rkt)
       (lib⁰ racket/contract.rkt)
       (lib⁰ typed-racket/types/numeric-predicates.rkt))))
    (define⁰ g719⁰ (lambda⁴˙˙⁵ (x⁴˙˙⁵) (zo?⁰ x⁴˙˙⁵)))
    (define⁰ g720⁰ (->⁰ g719⁰))
    (define⁰ g721⁰ exact-nonnegative-integer?⁸˙˙⁹)
    (define⁰ g722⁰ (or/c⁰ g721⁰))
    (define⁰ g723⁰ symbol?¹⁰˙˙¹¹)
    (define⁰ g724⁰ identifier?¹²˙˙¹³)
    (define⁰ g725⁰ (hash/c⁰ g723⁰ g724⁰))
    (define⁰ g726⁰ (or/c⁰ g725⁰))
    (define⁰ g727⁰ (hash/c⁰ g722⁰ g726⁰))
    (define⁰ g728⁰ (or/c⁰ g727⁰))
    (define⁰ g729⁰ (lambda⁴˙˙⁵ (x⁴˙˙⁵) (prefix?⁰ x⁴˙˙⁵)))
    (define⁰ g730⁰ any/c⁰)
    (define⁰ g731⁰ (lambda⁴˙˙⁵ (x⁴˙˙⁵) (compilation-top?⁰ x⁴˙˙⁵)))
    (define⁰ g732⁰ (->⁰ any/c⁰ g729⁰))
    (define⁰ g733⁰ any/c⁰)
    (define⁰ g734⁰ (->⁰ any/c⁰ g733⁰))
    (define⁰ g735⁰ (quote⁴˙˙⁵ #f))
    (define⁰ g736⁰ (lambda⁴˙˙⁵ (x⁴˙˙⁵) (module-variable?⁰ x⁴˙˙⁵)))
    (define⁰ g737⁰ (lambda⁴˙˙⁵ (x⁴˙˙⁵) (global-bucket?⁰ x⁴˙˙⁵)))
    (define⁰ g738⁰ (or/c⁰ g723⁰ g735⁰ g736⁰ g737⁰))
    (define⁰ g739⁰ (listof⁰ g738⁰))
    (define⁰ g740⁰ (lambda⁴˙˙⁵ (x⁴˙˙⁵) (stx?⁰ x⁴˙˙⁵)))
    (define⁰ g741⁰ (or/c⁰ g735⁰ g740⁰))
    (define⁰ g742⁰ (listof⁰ g741⁰))
    (define⁰ g743⁰ (->⁰ any/c⁰ g723⁰))
    (define⁰ g744⁰ (->⁰ any/c⁰ g737⁰))
    (define⁰ g745⁰ (->⁰ any/c⁰ g723⁰))
    (define⁰ g746⁰ module-path-index?¹⁰˙˙¹¹)
    (define⁰ g747⁰ exact-integer?⁸˙˙⁹)
    (define⁰ g748⁰ (or/c⁰ g747⁰))
    (define⁰ g749⁰ (lambda⁴˙˙⁵ (x⁴˙˙⁵) (struct-shape?⁰ x⁴˙˙⁵)))
    (define⁰ g750⁰ (lambda⁴˙˙⁵ (x⁴˙˙⁵) (function-shape?⁰ x⁴˙˙⁵)))
    (define⁰ g751⁰ (quote⁴˙˙⁵ fixed⁴˙˙⁵))
    (define⁰ g752⁰ (quote⁴˙˙⁵ constant⁴˙˙⁵))
    (define⁰ g753⁰ (or/c⁰ g735⁰ g749⁰ g750⁰ g751⁰ g752⁰))
    (define⁰ g754⁰ (->⁰ any/c⁰ g746⁰))
    (define⁰ g755⁰ (->⁰ any/c⁰ g723⁰))
    (define⁰
     g756⁰
     (and/c⁰ exact-integer?¹⁴˙˙¹⁵ positive?¹⁴˙˙¹⁵ (not/c⁰ fixnum?¹⁴˙˙¹⁵)))
    (define⁰
     g757⁰
     (and/c⁰ fixnum?¹⁴˙˙¹⁵ positive?¹⁴˙˙¹⁵ (not/c⁰ index?¹⁴˙˙¹⁵)))
    (define⁰ g758⁰ (and/c⁰ index?¹⁴˙˙¹⁵ positive?¹⁴˙˙¹⁵ (not/c⁰ byte?¹⁴˙˙¹⁵)))
    (define⁰
     g759⁰
     (λ¹⁴˙˙¹⁵ (n¹⁴˙˙¹⁵) (and¹⁴˙˙¹⁵ (byte?¹⁴˙˙¹⁵ n¹⁴˙˙¹⁵) (>¹⁴˙˙¹⁵ n¹⁴˙˙¹⁵ 1))))
    (define⁰ g760⁰ (lambda⁴˙˙⁵ (x⁴˙˙⁵) (equal?⁴˙˙⁵ x⁴˙˙⁵ (quote⁴˙˙⁵ 1))))
    (define⁰ g761⁰ (lambda⁴˙˙⁵ (x⁴˙˙⁵) (equal?⁴˙˙⁵ x⁴˙˙⁵ (quote⁴˙˙⁵ 0))))
    (define⁰ g762⁰ (lambda⁴˙˙⁵ (x⁴˙˙⁵) (arity-at-least?¹⁶˙˙¹⁷ x⁴˙˙⁵)))
    (define⁰ g763⁰ (or/c⁰ g756⁰ g757⁰ g758⁰ g759⁰ g760⁰ g761⁰ g762⁰))
    (define⁰ g764⁰ (listof⁰ g763⁰))
    (define⁰ g765⁰ (or/c⁰ g756⁰ g757⁰ g758⁰ g759⁰ g760⁰ g761⁰ g764⁰ g762⁰))
    (define⁰ g766⁰ (quote⁴˙˙⁵ #t))
    (define⁰ g767⁰ (or/c⁰ g766⁰ g735⁰))
    (define⁰ g768⁰ (->⁰ g749⁰))
    (define⁰ g769⁰ (lambda⁴˙˙⁵ (x⁴˙˙⁵) (struct-type-shape?⁰ x⁴˙˙⁵)))
    (define⁰ g770⁰ (lambda⁴˙˙⁵ (x⁴˙˙⁵) (constructor-shape?⁰ x⁴˙˙⁵)))
    (define⁰ g771⁰ (lambda⁴˙˙⁵ (x⁴˙˙⁵) (predicate-shape?⁰ x⁴˙˙⁵)))
    (define⁰ g772⁰ (->⁰ g771⁰))
    (define⁰ g773⁰ (lambda⁴˙˙⁵ (x⁴˙˙⁵) (accessor-shape?⁰ x⁴˙˙⁵)))
    (define⁰ g774⁰ (lambda⁴˙˙⁵ (x⁴˙˙⁵) (mutator-shape?⁰ x⁴˙˙⁵)))
    (define⁰ g775⁰ (lambda⁴˙˙⁵ (x⁴˙˙⁵) (struct-other-shape?⁰ x⁴˙˙⁵)))
    (define⁰ g776⁰ (->⁰ g775⁰))
    (define⁰ g777⁰ (lambda⁴˙˙⁵ (x⁴˙˙⁵) (stx-obj?⁰ x⁴˙˙⁵)))
    (define⁰ g778⁰ (->⁰ any/c⁰ g740⁰))
    (define⁰ g779⁰ (->⁰ any/c⁰ g777⁰))
    (define⁰ g780⁰ (lambda⁴˙˙⁵ (x⁴˙˙⁵) (wrap?⁰ x⁴˙˙⁵)))
    (define⁰ g781⁰ (lambda⁴˙˙⁵ (x⁴˙˙⁵) (srcloc?¹⁶˙˙¹⁷ x⁴˙˙⁵)))
    (define⁰ g782⁰ (or/c⁰ g735⁰ g781⁰))
    (define⁰ g783⁰ (hash/c⁰ g723⁰ g730⁰))
    (define⁰ g784⁰ (or/c⁰ g783⁰))
    (define⁰ g785⁰ (quote⁴˙˙⁵ tainted⁴˙˙⁵))
    (define⁰ g786⁰ (quote⁴˙˙⁵ armed⁴˙˙⁵))
    (define⁰ g787⁰ (quote⁴˙˙⁵ clean⁴˙˙⁵))
    (define⁰ g788⁰ (or/c⁰ g785⁰ g786⁰ g787⁰))
    (define⁰ g789⁰ (->⁰ any/c⁰ g733⁰))
    (define⁰ g790⁰ (->⁰ any/c⁰ g780⁰))
    (define⁰ g791⁰ (hash/c⁰ g723⁰ g733⁰))
    (define⁰ g792⁰ (or/c⁰ g791⁰))
    (define⁰ g793⁰ (lambda⁴˙˙⁵ (x⁴˙˙⁵) (form?⁰ x⁴˙˙⁵)))
    (define⁰ g794⁰ (->⁰ g793⁰))
    (define⁰ g795⁰ (lambda⁴˙˙⁵ (x⁴˙˙⁵) (expr?⁰ x⁴˙˙⁵)))
    (define⁰ g796⁰ (->⁰ g795⁰))
    (define⁰ g797⁰ (lambda⁴˙˙⁵ (x⁴˙˙⁵) (binding?⁰ x⁴˙˙⁵)))
    (define⁰ g798⁰ (->⁰ g797⁰))
    (define⁰ g799⁰ (lambda⁴˙˙⁵ (x⁴˙˙⁵) (module-shift?⁰ x⁴˙˙⁵)))
    (define⁰ g800⁰ (listof⁰ g799⁰))
    (define⁰ g801⁰ (lambda⁴˙˙⁵ (x⁴˙˙⁵) (scope?⁰ x⁴˙˙⁵)))
    (define⁰ g802⁰ (listof⁰ g801⁰))
    (define⁰ g803⁰ (lambda⁴˙˙⁵ (x⁴˙˙⁵) (multi-scope?⁰ x⁴˙˙⁵)))
    (define⁰ g804⁰ (or/c⁰ g747⁰ g735⁰))
    (define⁰ g805⁰ (quote⁴˙˙⁵ ()))
    (define⁰ g806⁰ (cons/c⁰ g804⁰ g805⁰))
    (define⁰ g807⁰ (cons/c⁰ g803⁰ g806⁰))
    (define⁰ g808⁰ (listof⁰ g807⁰))
    (define⁰ g809⁰ (listof⁰ g723⁰))
    (define⁰ g810⁰ (or/c⁰ g723⁰ g735⁰))
    (define⁰ g811⁰ (lambda⁴˙˙⁵ (x⁴˙˙⁵) (all-from-module?⁰ x⁴˙˙⁵)))
    (define⁰ g812⁰ (->⁰ any/c⁰ g746⁰))
    (define⁰ g813⁰ (->⁰ any/c⁰ g723⁰))
    (define⁰ g814⁰ (lambda⁴˙˙⁵ (x⁴˙˙⁵) (toplevel?⁰ x⁴˙˙⁵)))
    (define⁰ g815⁰ (or/c⁰ g723⁰ g814⁰))
    (define⁰ g816⁰ (listof⁰ g815⁰))
    (define⁰ g817⁰ (lambda⁴˙˙⁵ (x⁴˙˙⁵) (def-values?⁰ x⁴˙˙⁵)))
    (define⁰ g818⁰ (->⁰ any/c⁰ g733⁰))
    (define⁰ g819⁰ (or/c⁰ g735⁰ g814⁰))
    (define⁰ g820⁰ (lambda⁴˙˙⁵ (x⁴˙˙⁵) (def-syntaxes?⁰ x⁴˙˙⁵)))
    (define⁰ g821⁰ (->⁰ any/c⁰ g733⁰))
    (define⁰ g822⁰ (->⁰ any/c⁰ g729⁰))
    (define⁰ g823⁰ (listof⁰ g730⁰))
    (define⁰ g824⁰ (lambda⁴˙˙⁵ (x⁴˙˙⁵) (seq-for-syntax?⁰ x⁴˙˙⁵)))
    (define⁰ g825⁰ (listof⁰ g733⁰))
    (define⁰ g826⁰ (->⁰ any/c⁰ g729⁰))
    (define⁰ g827⁰ (lambda⁴˙˙⁵ (x⁴˙˙⁵) (req?⁰ x⁴˙˙⁵)))
    (define⁰ g828⁰ (->⁰ any/c⁰ any/c⁰ g827⁰))
    (define⁰ g829⁰ (->⁰ any/c⁰ g740⁰))
    (define⁰ g830⁰ (->⁰ any/c⁰ g814⁰))
    (define⁰ g831⁰ (lambda⁴˙˙⁵ (x⁴˙˙⁵) (seq?⁰ x⁴˙˙⁵)))
    (define⁰ g832⁰ (lambda⁴˙˙⁵ (x⁴˙˙⁵) (splice?⁰ x⁴˙˙⁵)))
    (define⁰ g833⁰ (lambda⁴˙˙⁵ (x⁴˙˙⁵) (inline-variant?⁰ x⁴˙˙⁵)))
    (define⁰ g834⁰ (->⁰ any/c⁰ any/c⁰ g833⁰))
    (define⁰ g835⁰ (->⁰ any/c⁰ g795⁰))
    (define⁰ g842⁰ (or/c⁰ g723⁰ g809⁰))
    (define⁰ g843⁰ (lambda⁴˙˙⁵ (x⁴˙˙⁵) (provided?⁰ x⁴˙˙⁵)))
    (define⁰ g844⁰ (listof⁰ g843⁰))
    (define⁰ g845⁰ (cons/c⁰ g844⁰ g805⁰))
    (define⁰ g846⁰ (cons/c⁰ g844⁰ g845⁰))
    (define⁰ g847⁰ (cons/c⁰ g804⁰ g846⁰))
    (define⁰ g848⁰ (listof⁰ g847⁰))
    (define⁰ g849⁰ (listof⁰ g746⁰))
    (define⁰ g850⁰ (cons/c⁰ g804⁰ g849⁰))
    (define⁰ g851⁰ (listof⁰ g850⁰))
    (define⁰ g852⁰ (and/c⁰ exact-integer?⁸˙˙⁹ positive?⁸˙˙⁹))
    (define⁰ g853⁰ (or/c⁰ g852⁰))
    (define⁰ g854⁰ (or/c⁰ g824⁰ g820⁰))
    (define⁰ g855⁰ (listof⁰ g854⁰))
    (define⁰ g856⁰ (cons/c⁰ g853⁰ g855⁰))
    (define⁰ g857⁰ (listof⁰ g856⁰))
    (define⁰ g858⁰ (cons/c⁰ g809⁰ g805⁰))
    (define⁰ g859⁰ (cons/c⁰ g809⁰ g858⁰))
    (define⁰ g860⁰ (cons/c⁰ g722⁰ g859⁰))
    (define⁰ g861⁰ (listof⁰ g860⁰))
    (define⁰ g863⁰ path?¹⁰˙˙¹¹)
    (define⁰ g864⁰ string?¹⁰˙˙¹¹)
    (define⁰ g865⁰ (quote⁴˙˙⁵ submod⁴˙˙⁵))
    (define⁰ g866⁰ (quote⁴˙˙⁵ ..))
    (define⁰ g867⁰ (or/c⁰ g723⁰ g866⁰))
    (define⁰ g868⁰ (listof⁰ g867⁰))
    (define⁰ g869⁰ (quote⁴˙˙⁵ planet⁴˙˙⁵))
    (define⁰ g870⁰ (quote⁴˙˙⁵ -⁴˙˙⁵))
    (define⁰ g871⁰ (quote⁴˙˙⁵ +⁴˙˙⁵))
    (define⁰ g872⁰ (quote⁴˙˙⁵ =⁴˙˙⁵))
    (define⁰
     g873⁰
     (or/c⁰ g756⁰ g757⁰ g758⁰ g759⁰ g760⁰ g761⁰ g870⁰ g871⁰ g872⁰))
    (define⁰ g874⁰ (cons/c⁰ g722⁰ g805⁰))
    (define⁰ g875⁰ (cons/c⁰ g873⁰ g874⁰))
    (define⁰ g876⁰ (or/c⁰ g756⁰ g757⁰ g758⁰ g759⁰ g760⁰ g761⁰ g875⁰))
    (define⁰ g877⁰ (listof⁰ g876⁰))
    (define⁰ g878⁰ (cons/c⁰ g864⁰ g877⁰))
    (define⁰ g879⁰ (cons/c⁰ g864⁰ g878⁰))
    (define⁰ g880⁰ (cons/c⁰ g879⁰ g805⁰))
    (define⁰ g881⁰ (cons/c⁰ g864⁰ g880⁰))
    (define⁰ g882⁰ (cons/c⁰ g864⁰ g805⁰))
    (define⁰ g883⁰ (cons/c⁰ g723⁰ g805⁰))
    (define⁰ g884⁰ (or/c⁰ g881⁰ g882⁰ g883⁰))
    (define⁰ g885⁰ (cons/c⁰ g869⁰ g884⁰))
    (define⁰ g886⁰ (quote⁴˙˙⁵ file⁴˙˙⁵))
    (define⁰ g887⁰ (cons/c⁰ g886⁰ g882⁰))
    (define⁰ g888⁰ (quote⁴˙˙⁵ lib⁴˙˙⁵))
    (define⁰ g889⁰ (cons/c⁰ g888⁰ g882⁰))
    (define⁰ g890⁰ (quote⁴˙˙⁵ quote⁴˙˙⁵))
    (define⁰ g891⁰ (cons/c⁰ g890⁰ g883⁰))
    (define⁰
     g892⁰
     (letrec²˙˙³
      ((g21115838⁰ (recursive-contract⁰ g892⁰ #:flat))
       (g21115838862⁰
        (or/c⁰
         g863⁰
         g864⁰
         g723⁰
         (cons/c⁰ g865⁰ (cons/c⁰ g21115838⁰ g868⁰))
         g885⁰
         g887⁰
         g889⁰
         g891⁰)))
      g21115838⁰))
    (define⁰ g893⁰ (vector/c⁰ g892⁰ g723⁰ g730⁰))
    (define⁰
     g897⁰
     (letrec²²˙˙²³
      ((g21116839⁰ (recursive-contract⁰ g21116839894⁰ #:flat))
       (g21116840⁰ (recursive-contract⁰ g21116840895⁰ #:flat))
       (g21116841⁰ (recursive-contract⁰ g21116841896⁰ #:flat))
       (g21116839894⁰
        (or/c⁰
         g863⁰
         g864⁰
         g723⁰
         (cons/c⁰ g865⁰ (cons/c⁰ g21116839⁰ g868⁰))
         g885⁰
         g887⁰
         g889⁰
         g891⁰))
       (g21116840895⁰
        (or/c⁰
         g863⁰
         g864⁰
         g723⁰
         (cons/c⁰ g865⁰ (cons/c⁰ g21116840⁰ g868⁰))
         g885⁰
         g887⁰
         g889⁰
         g891⁰))
       (g21116841896⁰
        (or/c⁰
         g863⁰
         g864⁰
         g723⁰
         (cons/c⁰ g865⁰ (cons/c⁰ g21116841⁰ g868⁰))
         g885⁰
         g887⁰
         g889⁰
         g891⁰)))
      g21116840⁰))
    (define⁰ g898⁰ (vector/c⁰ g897⁰ g723⁰ g730⁰))
    (define⁰ g899⁰ (or/c⁰ g735⁰ g893⁰ g898⁰))
    (define⁰ g900⁰ (vectorof⁰ g740⁰))
    (define⁰ g901⁰ (or/c⁰ g766⁰ g735⁰ g900⁰ g740⁰))
    (define⁰ g902⁰ (or/c⁰ g766⁰ g740⁰))
    (define⁰ g903⁰ (hash/c⁰ g723⁰ g902⁰))
    (define⁰ g904⁰ (or/c⁰ g903⁰))
    (define⁰ g905⁰ (hash/c⁰ g748⁰ g904⁰))
    (define⁰ g906⁰ (or/c⁰ g905⁰))
    (define⁰ g907⁰ (quote⁴˙˙⁵ cross-phase⁴˙˙⁵))
    (define⁰ g908⁰ (listof⁰ g907⁰))
    (define⁰ g909⁰ (lambda⁴˙˙⁵ (x⁴˙˙⁵) (mod?⁰ x⁴˙˙⁵)))
    (define⁰ g910⁰ (listof⁰ g909⁰))
    (define⁰ g911⁰ (->⁰ any/c⁰ g723⁰))
    (define⁰ g912⁰ (->⁰ any/c⁰ g746⁰))
    (define⁰ g913⁰ (->⁰ any/c⁰ g729⁰))
    (define⁰ g914⁰ (->⁰ any/c⁰ g814⁰))
    (define⁰
     g922⁰
     (letrec²˙˙³
      ((g21151917⁰ (recursive-contract⁰ g922⁰ #:flat))
       (g21151917921⁰
        (or/c⁰
         g863⁰
         g864⁰
         g723⁰
         (cons/c⁰ g865⁰ (cons/c⁰ g21151917⁰ g868⁰))
         g885⁰
         g887⁰
         g889⁰
         g891⁰)))
      g21151917⁰))
    (define⁰ g923⁰ (vector/c⁰ g922⁰ g723⁰ g730⁰))
    (define⁰
     g927⁰
     (letrec²²˙˙²³
      ((g21152918⁰ (recursive-contract⁰ g21152918924⁰ #:flat))
       (g21152919⁰ (recursive-contract⁰ g21152919925⁰ #:flat))
       (g21152920⁰ (recursive-contract⁰ g21152920926⁰ #:flat))
       (g21152918924⁰
        (or/c⁰
         g863⁰
         g864⁰
         g723⁰
         (cons/c⁰ g865⁰ (cons/c⁰ g21152918⁰ g868⁰))
         g885⁰
         g887⁰
         g889⁰
         g891⁰))
       (g21152919925⁰
        (or/c⁰
         g863⁰
         g864⁰
         g723⁰
         (cons/c⁰ g865⁰ (cons/c⁰ g21152919⁰ g868⁰))
         g885⁰
         g887⁰
         g889⁰
         g891⁰))
       (g21152920926⁰
        (or/c⁰
         g863⁰
         g864⁰
         g723⁰
         (cons/c⁰ g865⁰ (cons/c⁰ g21152920⁰ g868⁰))
         g885⁰
         g887⁰
         g889⁰
         g891⁰)))
      g21152918⁰))
    (define⁰ g928⁰ (vector/c⁰ g927⁰ g723⁰ g733⁰))
    (define⁰ g929⁰ (or/c⁰ g735⁰ g923⁰ g928⁰))
    (define⁰ g930⁰ (or/c⁰ g746⁰ g735⁰))
    (define⁰ g931⁰ (->⁰ any/c⁰ g723⁰))
    (define⁰ g932⁰ (vectorof⁰ g730⁰))
    (define⁰ g933⁰ (or/c⁰ g723⁰ g805⁰ g932⁰))
    (define⁰ g934⁰ (quote⁴˙˙⁵ sfs-clear-rest-args⁴˙˙⁵))
    (define⁰ g935⁰ (quote⁴˙˙⁵ only-rest-arg-not-used⁴˙˙⁵))
    (define⁰ g936⁰ (quote⁴˙˙⁵ single-result⁴˙˙⁵))
    (define⁰ g937⁰ (quote⁴˙˙⁵ is-method⁴˙˙⁵))
    (define⁰ g938⁰ (quote⁴˙˙⁵ preserves-marks⁴˙˙⁵))
    (define⁰ g939⁰ (or/c⁰ g934⁰ g935⁰ g936⁰ g937⁰ g938⁰))
    (define⁰ g940⁰ (listof⁰ g939⁰))
    (define⁰ g941⁰ (quote⁴˙˙⁵ extflonum⁴˙˙⁵))
    (define⁰ g942⁰ (quote⁴˙˙⁵ fixnum⁴˙˙⁵))
    (define⁰ g943⁰ (quote⁴˙˙⁵ flonum⁴˙˙⁵))
    (define⁰ g944⁰ (quote⁴˙˙⁵ ref⁴˙˙⁵))
    (define⁰ g945⁰ (quote⁴˙˙⁵ val⁴˙˙⁵))
    (define⁰ g946⁰ (or/c⁰ g941⁰ g942⁰ g943⁰ g944⁰ g945⁰))
    (define⁰ g947⁰ (listof⁰ g946⁰))
    (define⁰ g948⁰ (vectorof⁰ g722⁰))
    (define⁰ g949⁰ (or/c⁰ g948⁰))
    (define⁰ g950⁰ (quote⁴˙˙⁵ val/ref⁴˙˙⁵))
    (define⁰ g951⁰ (or/c⁰ g941⁰ g942⁰ g943⁰ g950⁰))
    (define⁰ g952⁰ (listof⁰ g951⁰))
    (define⁰ g953⁰ (set/c¹⁸˙˙²¹ g722⁰))
    (define⁰ g954⁰ (or/c⁰ g735⁰ g953⁰))
    (define⁰ g955⁰ (lambda⁴˙˙⁵ (x⁴˙˙⁵) (lam?⁰ x⁴˙˙⁵)))
    (define⁰ g956⁰ (vectorof⁰ g730⁰))
    (define⁰ g957⁰ (vectorof⁰ g733⁰))
    (define⁰ g958⁰ (or/c⁰ g723⁰ g805⁰ g956⁰ g957⁰))
    (define⁰ g959⁰ (->⁰ any/c⁰ g733⁰))
    (define⁰ g960⁰ (lambda⁴˙˙⁵ (x⁴˙˙⁵) (closure?⁰ x⁴˙˙⁵)))
    (define⁰ g961⁰ (->⁰ any/c⁰ any/c⁰ g960⁰))
    (define⁰ g962⁰ (->⁰ any/c⁰ g955⁰))
    (define⁰ g963⁰ (->⁰ any/c⁰ g723⁰))
    (define⁰ g964⁰ (or/c⁰ g960⁰ g955⁰))
    (define⁰ g965⁰ (listof⁰ g964⁰))
    (define⁰ g966⁰ (lambda⁴˙˙⁵ (x⁴˙˙⁵) (case-lam?⁰ x⁴˙˙⁵)))
    (define⁰ g967⁰ (or/c⁰ g735⁰ g941⁰ g942⁰ g943⁰))
    (define⁰ g968⁰ (lambda⁴˙˙⁵ (x⁴˙˙⁵) (let-one?⁰ x⁴˙˙⁵)))
    (define⁰ g969⁰ (->⁰ any/c⁰ g733⁰))
    (define⁰ g970⁰ (lambda⁴˙˙⁵ (x⁴˙˙⁵) (let-void?⁰ x⁴˙˙⁵)))
    (define⁰ g971⁰ (->⁰ any/c⁰ g733⁰))
    (define⁰ g972⁰ (lambda⁴˙˙⁵ (x⁴˙˙⁵) (install-value?⁰ x⁴˙˙⁵)))
    (define⁰ g973⁰ (->⁰ any/c⁰ g733⁰))
    (define⁰ g974⁰ (listof⁰ g955⁰))
    (define⁰ g975⁰ (lambda⁴˙˙⁵ (x⁴˙˙⁵) (let-rec?⁰ x⁴˙˙⁵)))
    (define⁰ g976⁰ (->⁰ any/c⁰ g733⁰))
    (define⁰ g977⁰ (lambda⁴˙˙⁵ (x⁴˙˙⁵) (boxenv?⁰ x⁴˙˙⁵)))
    (define⁰ g978⁰ (->⁰ any/c⁰ g733⁰))
    (define⁰ g979⁰ (lambda⁴˙˙⁵ (x⁴˙˙⁵) (localref?⁰ x⁴˙˙⁵)))
    (define⁰ g980⁰ (lambda⁴˙˙⁵ (x⁴˙˙⁵) (topsyntax?⁰ x⁴˙˙⁵)))
    (define⁰ g981⁰ (lambda⁴˙˙⁵ (x⁴˙˙⁵) (application?⁰ x⁴˙˙⁵)))
    (define⁰ g982⁰ (->⁰ any/c⁰ g733⁰))
    (define⁰ g983⁰ (lambda⁴˙˙⁵ (x⁴˙˙⁵) (branch?⁰ x⁴˙˙⁵)))
    (define⁰ g984⁰ (->⁰ any/c⁰ g733⁰))
    (define⁰ g985⁰ (lambda⁴˙˙⁵ (x⁴˙˙⁵) (with-cont-mark?⁰ x⁴˙˙⁵)))
    (define⁰ g986⁰ (->⁰ any/c⁰ g733⁰))
    (define⁰ g987⁰ (lambda⁴˙˙⁵ (x⁴˙˙⁵) (beg0?⁰ x⁴˙˙⁵)))
    (define⁰ g988⁰ (or/c⁰ g766⁰ g814⁰))
    (define⁰ g989⁰ (lambda⁴˙˙⁵ (x⁴˙˙⁵) (varref?⁰ x⁴˙˙⁵)))
    (define⁰ g990⁰ (lambda⁴˙˙⁵ (x⁴˙˙⁵) (assign?⁰ x⁴˙˙⁵)))
    (define⁰ g991⁰ (->⁰ any/c⁰ g814⁰))
    (define⁰ g992⁰ (->⁰ any/c⁰ g733⁰))
    (define⁰ g993⁰ (lambda⁴˙˙⁵ (x⁴˙˙⁵) (apply-values?⁰ x⁴˙˙⁵)))
    (define⁰ g994⁰ (->⁰ any/c⁰ g733⁰))
    (define⁰ g995⁰ (lambda⁴˙˙⁵ (x⁴˙˙⁵) (with-immed-mark?⁰ x⁴˙˙⁵)))
    (define⁰ g996⁰ (->⁰ any/c⁰ g733⁰))
    (define⁰ g997⁰ (lambda⁴˙˙⁵ (x⁴˙˙⁵) (primval?⁰ x⁴˙˙⁵)))
    (define⁰ g998⁰ (quote⁴˙˙⁵ root⁴˙˙⁵))
    (define⁰ g999⁰ (or/c⁰ g756⁰ g757⁰ g758⁰ g759⁰ g760⁰ g761⁰ g998⁰))
    (define⁰ g1000⁰ (cons/c⁰ g797⁰ g805⁰))
    (define⁰ g1001⁰ (cons/c⁰ g802⁰ g1000⁰))
    (define⁰ g1002⁰ (cons/c⁰ g723⁰ g1001⁰))
    (define⁰ g1003⁰ (listof⁰ g1002⁰))
    (define⁰ g1004⁰ (cons/c⁰ g811⁰ g805⁰))
    (define⁰ g1005⁰ (cons/c⁰ g802⁰ g1004⁰))
    (define⁰ g1006⁰ (listof⁰ g1005⁰))
    (define⁰ g1007⁰ (or/c⁰ g735⁰ g803⁰))
    (define⁰ g1008⁰ (->⁰ any/c⁰ g723⁰))
    (define⁰ g1009⁰ (cons/c⁰ g801⁰ g805⁰))
    (define⁰ g1010⁰ (cons/c⁰ g804⁰ g1009⁰))
    (define⁰ g1011⁰ (listof⁰ g1010⁰))
    (define⁰ g1012⁰ (->⁰ any/c⁰ g733⁰))
    (define⁰ g1013⁰ (lambda⁴˙˙⁵ (x⁴˙˙⁵) (module-binding?⁰ x⁴˙˙⁵)))
    (define⁰ g1014⁰ (->⁰ any/c⁰ g733⁰))
    (define⁰ g1015⁰ (lambda⁴˙˙⁵ (x⁴˙˙⁵) (decoded-module-binding?⁰ x⁴˙˙⁵)))
    (define⁰ g1016⁰ (->⁰ any/c⁰ g723⁰))
    (define⁰ g1017⁰ (lambda⁴˙˙⁵ (x⁴˙˙⁵) (local-binding?⁰ x⁴˙˙⁵)))
    (define⁰ g1018⁰ (->⁰ any/c⁰ g1017⁰))
    (define⁰ g1019⁰ (->⁰ any/c⁰ g723⁰))
    (define⁰ g1020⁰ (lambda⁴˙˙⁵ (x⁴˙˙⁵) (free-id=?-binding?⁰ x⁴˙˙⁵)))
    (define⁰ g1021⁰ (->⁰ any/c⁰ g797⁰))
    (define⁰ g1022⁰ (->⁰ any/c⁰ g777⁰))
    (define⁰ l33⁰ g720⁰)
    (define⁰ l64⁰ (->⁰ g722⁰ g728⁰ g729⁰ g730⁰ (values⁶˙˙⁷ g731⁰)))
    (define⁰ l66⁰ (->⁰ g731⁰ (values⁶˙˙⁷ g722⁰)))
    (define⁰ l68⁰ (->⁰ g731⁰ (values⁶˙˙⁷ g728⁰)))
    (define⁰ l70⁰ g732⁰)
    (define⁰ l72⁰ g734⁰)
    (define⁰ l103⁰ (->⁰ g722⁰ g739⁰ g742⁰ g723⁰ (values⁶˙˙⁷ g729⁰)))
    (define⁰ l105⁰ (->⁰ g729⁰ (values⁶˙˙⁷ g722⁰)))
    (define⁰ l107⁰ (->⁰ g729⁰ (values⁶˙˙⁷ g739⁰)))
    (define⁰ l109⁰ (->⁰ g729⁰ (values⁶˙˙⁷ g742⁰)))
    (define⁰ l111⁰ g743⁰)
    (define⁰ l142⁰ g744⁰)
    (define⁰ l144⁰ g745⁰)
    (define⁰ l175⁰ (->⁰ g746⁰ g723⁰ g748⁰ g722⁰ g753⁰ (values⁶˙˙⁷ g736⁰)))
    (define⁰ l177⁰ g754⁰)
    (define⁰ l179⁰ g755⁰)
    (define⁰ l181⁰ (->⁰ g736⁰ (values⁶˙˙⁷ g748⁰)))
    (define⁰ l183⁰ (->⁰ g736⁰ (values⁶˙˙⁷ g722⁰)))
    (define⁰ l185⁰ (->⁰ g736⁰ (values⁶˙˙⁷ g753⁰)))
    (define⁰ l220⁰ (->⁰ g765⁰ g767⁰ (values⁶˙˙⁷ g750⁰)))
    (define⁰ l222⁰ (->⁰ g750⁰ (values⁶˙˙⁷ g765⁰)))
    (define⁰ l224⁰ (->⁰ g750⁰ (values⁶˙˙⁷ g767⁰)))
    (define⁰ l259⁰ g768⁰)
    (define⁰ l290⁰ (->⁰ g722⁰ (values⁶˙˙⁷ g769⁰)))
    (define⁰ l292⁰ (->⁰ g769⁰ (values⁶˙˙⁷ g722⁰)))
    (define⁰ l323⁰ (->⁰ g722⁰ (values⁶˙˙⁷ g770⁰)))
    (define⁰ l325⁰ (->⁰ g770⁰ (values⁶˙˙⁷ g722⁰)))
    (define⁰ l356⁰ g772⁰)
    (define⁰ l387⁰ (->⁰ g722⁰ (values⁶˙˙⁷ g773⁰)))
    (define⁰ l389⁰ (->⁰ g773⁰ (values⁶˙˙⁷ g722⁰)))
    (define⁰ l420⁰ (->⁰ g722⁰ (values⁶˙˙⁷ g774⁰)))
    (define⁰ l422⁰ (->⁰ g774⁰ (values⁶˙˙⁷ g722⁰)))
    (define⁰ l453⁰ g776⁰)
    (define⁰ l484⁰ g778⁰)
    (define⁰ l486⁰ g779⁰)
    (define⁰ l517⁰ (->⁰ g730⁰ g780⁰ g782⁰ g784⁰ g788⁰ (values⁶˙˙⁷ g777⁰)))
    (define⁰ l519⁰ g789⁰)
    (define⁰ l521⁰ g790⁰)
    (define⁰ l523⁰ (->⁰ g777⁰ (values⁶˙˙⁷ g782⁰)))
    (define⁰ l525⁰ (->⁰ g777⁰ (values⁶˙˙⁷ g792⁰)))
    (define⁰ l527⁰ (->⁰ g777⁰ (values⁶˙˙⁷ g788⁰)))
    (define⁰ l558⁰ g794⁰)
    (define⁰ l589⁰ g796⁰)
    (define⁰ l620⁰ g798⁰)
    (define⁰ l651⁰ (->⁰ g800⁰ g802⁰ g808⁰ (values⁶˙˙⁷ g780⁰)))
    (define⁰ l653⁰ (->⁰ g780⁰ (values⁶˙˙⁷ g800⁰)))
    (define⁰ l655⁰ (->⁰ g780⁰ (values⁶˙˙⁷ g802⁰)))
    (define⁰ l657⁰ (->⁰ g780⁰ (values⁶˙˙⁷ g808⁰)))
    (define⁰
     l688⁰
     (->⁰ g746⁰ g804⁰ g804⁰ g723⁰ g809⁰ g810⁰ (values⁶˙˙⁷ g811⁰)))
    (define⁰ l690⁰ g812⁰)
    (define⁰ l692⁰ (->⁰ g811⁰ (values⁶˙˙⁷ g804⁰)))
    (define⁰ l694⁰ (->⁰ g811⁰ (values⁶˙˙⁷ g804⁰)))
    (define⁰ l696⁰ g813⁰)
    (define⁰ l698⁰ (->⁰ g811⁰ (values⁶˙˙⁷ g809⁰)))
    (define⁰ l700⁰ (->⁰ g811⁰ (values⁶˙˙⁷ g810⁰)))
    (define⁰ l731⁰ (->⁰ g816⁰ g730⁰ (values⁶˙˙⁷ g817⁰)))
    (define⁰ l733⁰ (->⁰ g817⁰ (values⁶˙˙⁷ g816⁰)))
    (define⁰ l735⁰ g818⁰)
    (define⁰ l766⁰ (->⁰ g816⁰ g730⁰ g729⁰ g722⁰ g819⁰ (values⁶˙˙⁷ g820⁰)))
    (define⁰ l768⁰ (->⁰ g820⁰ (values⁶˙˙⁷ g816⁰)))
    (define⁰ l770⁰ g821⁰)
    (define⁰ l772⁰ g822⁰)
    (define⁰ l774⁰ (->⁰ g820⁰ (values⁶˙˙⁷ g722⁰)))
    (define⁰ l776⁰ (->⁰ g820⁰ (values⁶˙˙⁷ g819⁰)))
    (define⁰ l807⁰ (->⁰ g823⁰ g729⁰ g722⁰ g819⁰ (values⁶˙˙⁷ g824⁰)))
    (define⁰ l809⁰ (->⁰ g824⁰ (values⁶˙˙⁷ g825⁰)))
    (define⁰ l811⁰ g826⁰)
    (define⁰ l813⁰ (->⁰ g824⁰ (values⁶˙˙⁷ g722⁰)))
    (define⁰ l815⁰ (->⁰ g824⁰ (values⁶˙˙⁷ g819⁰)))
    (define⁰ l846⁰ g828⁰)
    (define⁰ l848⁰ g829⁰)
    (define⁰ l850⁰ g830⁰)
    (define⁰ l881⁰ (->⁰ g823⁰ (values⁶˙˙⁷ g831⁰)))
    (define⁰ l883⁰ (->⁰ g831⁰ (values⁶˙˙⁷ g825⁰)))
    (define⁰ l914⁰ (->⁰ g823⁰ (values⁶˙˙⁷ g832⁰)))
    (define⁰ l916⁰ (->⁰ g832⁰ (values⁶˙˙⁷ g825⁰)))
    (define⁰ l947⁰ g834⁰)
    (define⁰ l949⁰ g835⁰)
    (define⁰ l951⁰ g835⁰)
    (define⁰
     l982⁰
     (->⁰
      g842⁰
      g723⁰
      g746⁰
      g729⁰
      g848⁰
      g851⁰
      g823⁰
      g857⁰
      g861⁰
      g722⁰
      g814⁰
      g899⁰
      g901⁰
      g906⁰
      g908⁰
      g910⁰
      g910⁰
      (values⁶˙˙⁷ g909⁰)))
    (define⁰ l984⁰ (->⁰ g909⁰ (values⁶˙˙⁷ g842⁰)))
    (define⁰ l986⁰ g911⁰)
    (define⁰ l988⁰ g912⁰)
    (define⁰ l990⁰ g913⁰)
    (define⁰ l992⁰ (->⁰ g909⁰ (values⁶˙˙⁷ g848⁰)))
    (define⁰ l994⁰ (->⁰ g909⁰ (values⁶˙˙⁷ g851⁰)))
    (define⁰ l996⁰ (->⁰ g909⁰ (values⁶˙˙⁷ g825⁰)))
    (define⁰ l998⁰ (->⁰ g909⁰ (values⁶˙˙⁷ g857⁰)))
    (define⁰ l1000⁰ (->⁰ g909⁰ (values⁶˙˙⁷ g861⁰)))
    (define⁰ l1002⁰ (->⁰ g909⁰ (values⁶˙˙⁷ g722⁰)))
    (define⁰ l1004⁰ g914⁰)
    (define⁰ l1006⁰ (->⁰ g909⁰ (values⁶˙˙⁷ g929⁰)))
    (define⁰ l1008⁰ (->⁰ g909⁰ (values⁶˙˙⁷ g901⁰)))
    (define⁰ l1010⁰ (->⁰ g909⁰ (values⁶˙˙⁷ g906⁰)))
    (define⁰ l1012⁰ (->⁰ g909⁰ (values⁶˙˙⁷ g908⁰)))
    (define⁰ l1014⁰ (->⁰ g909⁰ (values⁶˙˙⁷ g910⁰)))
    (define⁰ l1016⁰ (->⁰ g909⁰ (values⁶˙˙⁷ g910⁰)))
    (define⁰
     l1047⁰
     (->⁰ g723⁰ g930⁰ g723⁰ g930⁰ g722⁰ g767⁰ (values⁶˙˙⁷ g843⁰)))
    (define⁰ l1049⁰ g931⁰)
    (define⁰ l1051⁰ (->⁰ g843⁰ (values⁶˙˙⁷ g930⁰)))
    (define⁰ l1053⁰ g931⁰)
    (define⁰ l1055⁰ (->⁰ g843⁰ (values⁶˙˙⁷ g930⁰)))
    (define⁰ l1057⁰ (->⁰ g843⁰ (values⁶˙˙⁷ g722⁰)))
    (define⁰ l1059⁰ (->⁰ g843⁰ (values⁶˙˙⁷ g767⁰)))
    (define⁰
     l1090⁰
     (->⁰
      g933⁰
      g940⁰
      g722⁰
      g947⁰
      g767⁰
      g949⁰
      g952⁰
      g954⁰
      g722⁰
      g730⁰
      (values⁶˙˙⁷ g955⁰)))
    (define⁰ l1092⁰ (->⁰ g955⁰ (values⁶˙˙⁷ g958⁰)))
    (define⁰ l1094⁰ (->⁰ g955⁰ (values⁶˙˙⁷ g940⁰)))
    (define⁰ l1096⁰ (->⁰ g955⁰ (values⁶˙˙⁷ g722⁰)))
    (define⁰ l1098⁰ (->⁰ g955⁰ (values⁶˙˙⁷ g947⁰)))
    (define⁰ l1100⁰ (->⁰ g955⁰ (values⁶˙˙⁷ g767⁰)))
    (define⁰ l1102⁰ (->⁰ g955⁰ (values⁶˙˙⁷ g949⁰)))
    (define⁰ l1104⁰ (->⁰ g955⁰ (values⁶˙˙⁷ g952⁰)))
    (define⁰ l1106⁰ (->⁰ g955⁰ (values⁶˙˙⁷ g954⁰)))
    (define⁰ l1108⁰ (->⁰ g955⁰ (values⁶˙˙⁷ g722⁰)))
    (define⁰ l1110⁰ g959⁰)
    (define⁰ l1141⁰ g961⁰)
    (define⁰ l1143⁰ g962⁰)
    (define⁰ l1145⁰ g963⁰)
    (define⁰ l1176⁰ (->⁰ g933⁰ g965⁰ (values⁶˙˙⁷ g966⁰)))
    (define⁰ l1178⁰ (->⁰ g966⁰ (values⁶˙˙⁷ g958⁰)))
    (define⁰ l1180⁰ (->⁰ g966⁰ (values⁶˙˙⁷ g965⁰)))
    (define⁰ l1211⁰ (->⁰ g730⁰ g730⁰ g967⁰ g767⁰ (values⁶˙˙⁷ g968⁰)))
    (define⁰ l1213⁰ g969⁰)
    (define⁰ l1215⁰ g969⁰)
    (define⁰ l1217⁰ (->⁰ g968⁰ (values⁶˙˙⁷ g967⁰)))
    (define⁰ l1219⁰ (->⁰ g968⁰ (values⁶˙˙⁷ g767⁰)))
    (define⁰ l1250⁰ (->⁰ g722⁰ g767⁰ g730⁰ (values⁶˙˙⁷ g970⁰)))
    (define⁰ l1252⁰ (->⁰ g970⁰ (values⁶˙˙⁷ g722⁰)))
    (define⁰ l1254⁰ (->⁰ g970⁰ (values⁶˙˙⁷ g767⁰)))
    (define⁰ l1256⁰ g971⁰)
    (define⁰ l1287⁰ (->⁰ g722⁰ g722⁰ g767⁰ g730⁰ g730⁰ (values⁶˙˙⁷ g972⁰)))
    (define⁰ l1289⁰ (->⁰ g972⁰ (values⁶˙˙⁷ g722⁰)))
    (define⁰ l1291⁰ (->⁰ g972⁰ (values⁶˙˙⁷ g722⁰)))
    (define⁰ l1293⁰ (->⁰ g972⁰ (values⁶˙˙⁷ g767⁰)))
    (define⁰ l1295⁰ g973⁰)
    (define⁰ l1297⁰ g973⁰)
    (define⁰ l1328⁰ (->⁰ g974⁰ g730⁰ (values⁶˙˙⁷ g975⁰)))
    (define⁰ l1330⁰ (->⁰ g975⁰ (values⁶˙˙⁷ g974⁰)))
    (define⁰ l1332⁰ g976⁰)
    (define⁰ l1363⁰ (->⁰ g722⁰ g730⁰ (values⁶˙˙⁷ g977⁰)))
    (define⁰ l1365⁰ (->⁰ g977⁰ (values⁶˙˙⁷ g722⁰)))
    (define⁰ l1367⁰ g978⁰)
    (define⁰ l1398⁰ (->⁰ g767⁰ g722⁰ g767⁰ g767⁰ g967⁰ (values⁶˙˙⁷ g979⁰)))
    (define⁰ l1400⁰ (->⁰ g979⁰ (values⁶˙˙⁷ g767⁰)))
    (define⁰ l1402⁰ (->⁰ g979⁰ (values⁶˙˙⁷ g722⁰)))
    (define⁰ l1404⁰ (->⁰ g979⁰ (values⁶˙˙⁷ g767⁰)))
    (define⁰ l1406⁰ (->⁰ g979⁰ (values⁶˙˙⁷ g767⁰)))
    (define⁰ l1408⁰ (->⁰ g979⁰ (values⁶˙˙⁷ g967⁰)))
    (define⁰ l1439⁰ (->⁰ g722⁰ g722⁰ g767⁰ g767⁰ (values⁶˙˙⁷ g814⁰)))
    (define⁰ l1441⁰ (->⁰ g814⁰ (values⁶˙˙⁷ g722⁰)))
    (define⁰ l1443⁰ (->⁰ g814⁰ (values⁶˙˙⁷ g722⁰)))
    (define⁰ l1445⁰ (->⁰ g814⁰ (values⁶˙˙⁷ g767⁰)))
    (define⁰ l1447⁰ (->⁰ g814⁰ (values⁶˙˙⁷ g767⁰)))
    (define⁰ l1478⁰ (->⁰ g722⁰ g722⁰ g722⁰ (values⁶˙˙⁷ g980⁰)))
    (define⁰ l1480⁰ (->⁰ g980⁰ (values⁶˙˙⁷ g722⁰)))
    (define⁰ l1482⁰ (->⁰ g980⁰ (values⁶˙˙⁷ g722⁰)))
    (define⁰ l1484⁰ (->⁰ g980⁰ (values⁶˙˙⁷ g722⁰)))
    (define⁰ l1515⁰ (->⁰ g730⁰ g823⁰ (values⁶˙˙⁷ g981⁰)))
    (define⁰ l1517⁰ g982⁰)
    (define⁰ l1519⁰ (->⁰ g981⁰ (values⁶˙˙⁷ g825⁰)))
    (define⁰ l1550⁰ (->⁰ g730⁰ g730⁰ g730⁰ (values⁶˙˙⁷ g983⁰)))
    (define⁰ l1552⁰ g984⁰)
    (define⁰ l1554⁰ g984⁰)
    (define⁰ l1556⁰ g984⁰)
    (define⁰ l1587⁰ (->⁰ g730⁰ g730⁰ g730⁰ (values⁶˙˙⁷ g985⁰)))
    (define⁰ l1589⁰ g986⁰)
    (define⁰ l1591⁰ g986⁰)
    (define⁰ l1593⁰ g986⁰)
    (define⁰ l1624⁰ (->⁰ g823⁰ (values⁶˙˙⁷ g987⁰)))
    (define⁰ l1626⁰ (->⁰ g987⁰ (values⁶˙˙⁷ g825⁰)))
    (define⁰ l1657⁰ (->⁰ g988⁰ g819⁰ (values⁶˙˙⁷ g989⁰)))
    (define⁰ l1659⁰ (->⁰ g989⁰ (values⁶˙˙⁷ g988⁰)))
    (define⁰ l1661⁰ (->⁰ g989⁰ (values⁶˙˙⁷ g819⁰)))
    (define⁰ l1692⁰ (->⁰ g814⁰ g730⁰ g767⁰ (values⁶˙˙⁷ g990⁰)))
    (define⁰ l1694⁰ g991⁰)
    (define⁰ l1696⁰ g992⁰)
    (define⁰ l1698⁰ (->⁰ g990⁰ (values⁶˙˙⁷ g767⁰)))
    (define⁰ l1729⁰ (->⁰ g730⁰ g730⁰ (values⁶˙˙⁷ g993⁰)))
    (define⁰ l1731⁰ g994⁰)
    (define⁰ l1733⁰ g994⁰)
    (define⁰ l1764⁰ (->⁰ g730⁰ g730⁰ g730⁰ (values⁶˙˙⁷ g995⁰)))
    (define⁰ l1766⁰ g996⁰)
    (define⁰ l1768⁰ g996⁰)
    (define⁰ l1770⁰ g996⁰)
    (define⁰ l1801⁰ (->⁰ g722⁰ (values⁶˙˙⁷ g997⁰)))
    (define⁰ l1803⁰ (->⁰ g997⁰ (values⁶˙˙⁷ g722⁰)))
    (define⁰ l1834⁰ (->⁰ g930⁰ g930⁰ g810⁰ g810⁰ (values⁶˙˙⁷ g799⁰)))
    (define⁰ l1836⁰ (->⁰ g799⁰ (values⁶˙˙⁷ g930⁰)))
    (define⁰ l1838⁰ (->⁰ g799⁰ (values⁶˙˙⁷ g930⁰)))
    (define⁰ l1840⁰ (->⁰ g799⁰ (values⁶˙˙⁷ g810⁰)))
    (define⁰ l1842⁰ (->⁰ g799⁰ (values⁶˙˙⁷ g810⁰)))
    (define⁰ l1873⁰ (->⁰ g999⁰ g723⁰ g1003⁰ g1006⁰ g1007⁰ (values⁶˙˙⁷ g801⁰)))
    (define⁰ l1875⁰ (->⁰ g801⁰ (values⁶˙˙⁷ g999⁰)))
    (define⁰ l1877⁰ g1008⁰)
    (define⁰ l1879⁰ (->⁰ g801⁰ (values⁶˙˙⁷ g1003⁰)))
    (define⁰ l1881⁰ (->⁰ g801⁰ (values⁶˙˙⁷ g1006⁰)))
    (define⁰ l1883⁰ (->⁰ g801⁰ (values⁶˙˙⁷ g1007⁰)))
    (define⁰ l1914⁰ (->⁰ g722⁰ g730⁰ g1011⁰ (values⁶˙˙⁷ g803⁰)))
    (define⁰ l1916⁰ (->⁰ g803⁰ (values⁶˙˙⁷ g722⁰)))
    (define⁰ l1918⁰ g1012⁰)
    (define⁰ l1920⁰ (->⁰ g803⁰ (values⁶˙˙⁷ g1011⁰)))
    (define⁰ l1951⁰ (->⁰ g730⁰ (values⁶˙˙⁷ g1013⁰)))
    (define⁰ l1953⁰ g1014⁰)
    (define⁰
     l1984⁰
     (->⁰ g930⁰ g723⁰ g748⁰ g930⁰ g723⁰ g804⁰ g804⁰ g810⁰ (values⁶˙˙⁷ g1015⁰)))
    (define⁰ l1986⁰ (->⁰ g1015⁰ (values⁶˙˙⁷ g930⁰)))
    (define⁰ l1988⁰ g1016⁰)
    (define⁰ l1990⁰ (->⁰ g1015⁰ (values⁶˙˙⁷ g748⁰)))
    (define⁰ l1992⁰ (->⁰ g1015⁰ (values⁶˙˙⁷ g930⁰)))
    (define⁰ l1994⁰ g1016⁰)
    (define⁰ l1996⁰ (->⁰ g1015⁰ (values⁶˙˙⁷ g804⁰)))
    (define⁰ l1998⁰ (->⁰ g1015⁰ (values⁶˙˙⁷ g804⁰)))
    (define⁰ l2000⁰ (->⁰ g1015⁰ (values⁶˙˙⁷ g810⁰)))
    (define⁰ l2031⁰ g1018⁰)
    (define⁰ l2033⁰ g1019⁰)
    (define⁰ l2064⁰ (->⁰ g797⁰ g777⁰ g804⁰ (values⁶˙˙⁷ g1020⁰)))
    (define⁰ l2066⁰ g1021⁰)
    (define⁰ l2068⁰ g1022⁰)
    (define⁰ l2070⁰ (->⁰ g1020⁰ (values⁶˙˙⁷ g804⁰)))))
  (require⁰ (quote⁰ require/contracts⁰))
  (begin⁰
   (require⁰ (only-in⁰ (quote⁰˙˙¹ require/contracts⁰˙˙¹)))
   (define-values⁰ () (values⁰))))
 (define-type⁰
  Spec⁰
  (Rec⁰
   Spec⁰
   (Pair⁰ String⁰ (Listof⁰ (Pair⁰ String⁰ (->⁰ (U⁰ Spec⁰ String⁰)))))))
 (scv-ignore:provide⁰ Spec⁰)
 (scv-ignore:provide⁰
  (struct-out⁰ zo⁰)
  (struct-out⁰ compilation-top⁰)
  (struct-out⁰ prefix⁰)
  (struct-out⁰ global-bucket⁰)
  (struct-out⁰ module-variable⁰)
  (struct-out⁰ function-shape⁰)
  (struct-out⁰ struct-shape⁰)
  (struct-out⁰ struct-type-shape⁰)
  (struct-out⁰ constructor-shape⁰)
  (struct-out⁰ predicate-shape⁰)
  (struct-out⁰ accessor-shape⁰)
  (struct-out⁰ mutator-shape⁰)
  (struct-out⁰ struct-other-shape⁰)
  (struct-out⁰ stx⁰)
  (struct-out⁰ stx-obj⁰)
  (struct-out⁰ form⁰)
  (struct-out⁰ expr⁰)
  (struct-out⁰ binding⁰)
  (struct-out⁰ wrap⁰)
  (struct-out⁰ all-from-module⁰)
  (struct-out⁰ def-values⁰)
  (struct-out⁰ def-syntaxes⁰)
  (struct-out⁰ seq-for-syntax⁰)
  (struct-out⁰ req⁰)
  (struct-out⁰ seq⁰)
  (struct-out⁰ splice⁰)
  (struct-out⁰ inline-variant⁰)
  (struct-out⁰ mod⁰)
  (struct-out⁰ provided⁰)
  (struct-out⁰ lam⁰)
  (struct-out⁰ closure⁰)
  (struct-out⁰ case-lam⁰)
  (struct-out⁰ let-one⁰)
  (struct-out⁰ let-void⁰)
  (struct-out⁰ install-value⁰)
  (struct-out⁰ let-rec⁰)
  (struct-out⁰ boxenv⁰)
  (struct-out⁰ localref⁰)
  (struct-out⁰ toplevel⁰)
  (struct-out⁰ topsyntax⁰)
  (struct-out⁰ application⁰)
  (struct-out⁰ branch⁰)
  (struct-out⁰ with-cont-mark⁰)
  (struct-out⁰ beg0⁰)
  (struct-out⁰ varref⁰)
  (struct-out⁰ assign⁰)
  (struct-out⁰ apply-values⁰)
  (struct-out⁰ with-immed-mark⁰)
  (struct-out⁰ primval⁰)
  (struct-out⁰ module-shift⁰)
  (struct-out⁰ scope⁰)
  (struct-out⁰ multi-scope⁰)
  (struct-out⁰ module-binding⁰)
  (struct-out⁰ decoded-module-binding⁰)
  (struct-out⁰ local-binding⁰)
  (struct-out⁰ free-id=?-binding⁰))).
scv-cr: Working on /home/camoy/wrk/scv-cr/test/zordoz/zo-find.rkt.
scv-cr: Raw syntax is '(module zo-find typed/racket/base
   (#%module-begin
    (provide zo-find (struct-out result))
    (require (only-in racket/list empty?)
             (only-in racket/string string-split string-trim)
             scv-cr/require-typed-check
             "typed-zo-structs.rkt"
             racket/match)
    (require/typed/check
     "zo-transition.rkt"
     (zo-transition (-> zo String (values (U zo (Listof zo)) Boolean))))
    (require/typed/check "zo-string.rkt" (zo->spec (-> zo Spec)))
    (struct result ((zo : zo) (path : (Listof zo))) #:transparent)
    (: append-all (All (A) (-> (Listof (Listof A)) (Listof A))))
    (define (append-all xss)
      (cond
       ((empty? xss) '())
       (else (append (car xss) (append-all (cdr xss))))))
    (: zo-find (->* (zo String) ((U Natural #f)) (Listof result)))
    (define (zo-find z str (lim #f))
      (define-values (_ children) (parse-zo z))
      (append-all
       (for/list
        :
        (Listof (Listof result))
        ((z* : zo children))
        (zo-find-aux z* '() str 1 lim))))
    (: may-loop? (-> String Boolean))
    (define (may-loop? str)
      (if (member str '("closure" "multi-scope" "scope")) #t #f))
    (:
     zo-find-aux
     (-> zo (Listof zo) String Natural (U Natural #f) (Listof result)))
    (define (zo-find-aux z hist str i lim)
      (define-values (title children) (parse-zo z))
      (: results (Listof result))
      (define results
        (cond
         ((and lim (<= lim i)) '())
         ((and (may-loop? title) (memq z hist)) '())
         (else
          (: hist* (Listof zo))
          (define hist* (cons z hist))
          (append-all
           (for/list
            :
            (Listof (Listof result))
            ((z* : zo children))
            (zo-find-aux z* hist* str (add1 i) lim))))))
      (if (and (string=? str title) (not (memq z (map result-zo results))))
        (cons (result z hist) results)
        results))
    (: parse-zo (-> zo (values String (Listof zo))))
    (define (parse-zo z)
      (: z-spec Spec)
      (define z-spec (zo->spec z))
      (: title String)
      (define title (car z-spec))
      (: child-strs (Listof String))
      (define child-strs
        (for/list
         :
         (Listof String)
         ((pair : (Pair String (-> (U String Spec))) (cdr z-spec)))
         (car pair)))
      (values title (get-children z child-strs)))
    (: get-children (-> zo (Listof String) (Listof zo)))
    (define (get-children z strs)
      (match
       strs
       ('() '())
       ((cons hd tl)
        (define-values (r* success*) (zo-transition z hd))
        (: r (U zo (Listof zo)))
        (define r r*)
        (: success? Boolean)
        (define success? success*)
        (cond
         ((not success?) (get-children z tl))
         ((list? r) (append (filter zo? r) (get-children z tl)))
         ((zo? r) (cons r (get-children z tl))))))))).
scv-cr: Elaborated syntax is (module⁰
 zo-find⁰
 scv-cr/private/lang/scv/base⁰
 (begin⁰
  (module⁰ #%type-decl⁰ racket/base⁰)
  (require⁰ (for-syntax⁰ racket/base⁰))
  (define-syntax⁰ scv-cr?⁰ #t))
 (begin⁰
  (provide⁰
   (contract-out⁰
    (zo-find⁰ generated-contract31⁰)
    (struct⁰ result⁰ ((zo⁰ (values²⁴˙˙²⁵ g32⁰)) (path⁰ (values²⁴˙˙²⁵ g33⁰))))))
  (provide⁰
   g46⁰
   g38⁰
   g40⁰
   generated-contract28⁰
   g33⁰
   g37⁰
   g32⁰
   g44⁰
   generated-contract26⁰
   generated-contract27⁰
   g41⁰
   g45⁰
   g34⁰
   generated-contract25⁰
   g43⁰
   generated-contract30⁰
   g36⁰
   g42⁰
   generated-contract31⁰
   g39⁰
   g35⁰)
  (require⁰
   (only-in⁰
    (combine-in⁰
     (lib⁰ racket/contract/base.rkt)
     (lib⁰ racket/base.rkt)
     (submod⁰ typed-zo-structs.rkt #%type-decl⁰ ..)
     (lib⁰ racket/contract.rkt))))
  (define⁰ g32⁰ (lambda²⁶˙˙²⁷ (x²⁶˙˙²⁷) (zo?²⁸˙˙³⁵ x²⁶˙˙²⁷)))
  (define⁰ g33⁰ (listof⁰ g32⁰))
  (define⁰ g34⁰ (lambda²⁶˙˙²⁷ (x²⁶˙˙²⁷) (result?⁰ x²⁶˙˙²⁷)))
  (define⁰ g35⁰ struct-type?²˙˙³)
  (define⁰ g36⁰ (λ²˙˙³ (_²˙˙³) #f))
  (define⁰ g37⁰ any/c⁰)
  (define⁰ g38⁰ (quote²⁶˙˙²⁷ #t))
  (define⁰ g39⁰ (quote²⁶˙˙²⁷ #f))
  (define⁰ g40⁰ (or/c⁰ g38⁰ g39⁰))
  (define⁰ g41⁰ (->⁰ g37⁰ (values²⁴˙˙²⁵ g40⁰)))
  (define⁰ g42⁰ (or/c⁰ g36⁰ g41⁰))
  (define⁰ g43⁰ string?¹⁰˙˙¹¹)
  (define⁰ g44⁰ exact-nonnegative-integer?³⁶˙˙³⁷)
  (define⁰ g45⁰ (or/c⁰ g44⁰ g39⁰))
  (define⁰ g46⁰ (listof⁰ g34⁰))
  (define⁰ generated-contract25⁰ g35⁰)
  (define⁰ generated-contract26⁰ g42⁰)
  (define⁰ generated-contract27⁰ (->⁰ g34⁰ (values²⁴˙˙²⁵ g33⁰)))
  (define⁰ generated-contract28⁰ (->⁰ g34⁰ (values²⁴˙˙²⁵ g32⁰)))
  (define⁰ generated-contract30⁰ (->⁰ g32⁰ g33⁰ (values²⁴˙˙²⁵ g34⁰)))
  (define⁰
   generated-contract31⁰
   (case->⁰
    (->⁰ g32⁰ g43⁰ (values²⁴˙˙²⁵ g46⁰))
    (->⁰ g32⁰ g43⁰ g45⁰ (values²⁴˙˙²⁵ g46⁰)))))
 (begin⁰
  (module⁰
   require/contracts⁰
   scv-cr/private/lang/scv/base⁰
   (begin⁰
    (module⁰ #%type-decl⁰ racket/base⁰)
    (require⁰ (for-syntax⁰ racket/base⁰))
    (define-syntax⁰ scv-cr?⁰ #t))
   (require⁰)
   (begin⁰
    (provide⁰ (contract-out⁰))
    (provide⁰)
    (require⁰ (only-in⁰ (combine-in⁰)))))
  (require⁰ (quote⁰ require/contracts⁰))
  (begin⁰
   (require⁰ (only-in⁰ (quote⁰˙˙¹ require/contracts⁰˙˙¹)))
   (define-values⁰ () (values⁰))))
 (scv-ignore:provide⁰)
 (require⁰
  (only-in⁰ racket/list⁰ empty?⁰)
  (only-in⁰ racket/string⁰ string-split⁰ string-trim⁰)
  scv-cr/require-typed-check⁰
  typed-zo-structs.rkt
  racket/match⁰)
 (require/typed/check⁰
  zo-transition.rkt
  (zo-transition⁰ (->⁰ zo⁰ String⁰ (values⁰ (U⁰ zo⁰ (Listof⁰ zo⁰)) Boolean⁰))))
 (require/typed/check⁰ zo-string.rkt (zo->spec⁰ (->⁰ zo⁰ Spec⁰)))
 (struct⁰ result⁰ ((zo⁰ :⁰ zo⁰) (path⁰ :⁰ (Listof⁰ zo⁰))) #:transparent)
 (:⁰ append-all⁰ (All⁰ (A⁰) (->⁰ (Listof⁰ (Listof⁰ A⁰)) (Listof⁰ A⁰))))
 (define⁰
  (append-all⁰ xss⁰)
  (cond⁰
   ((empty?⁰ xss⁰) (quote⁰ ()))
   (else⁰ (append⁰ (car⁰ xss⁰) (append-all⁰ (cdr⁰ xss⁰))))))
 (:⁰ zo-find⁰ (->*⁰ (zo⁰ String⁰) ((U⁰ Natural⁰ #f)) (Listof⁰ result⁰)))
 (define⁰
  (zo-find⁰ z⁰ str⁰ (lim⁰ #f))
  (define-values⁰ (_⁰ children⁰) (parse-zo⁰ z⁰))
  (append-all⁰
   (for/list⁰
    :⁰
    (Listof⁰ (Listof⁰ result⁰))
    ((z*⁰ :⁰ zo⁰ children⁰))
    (zo-find-aux⁰ z*⁰ (quote⁰ ()) str⁰ 1 lim⁰))))
 (:⁰ may-loop?⁰ (->⁰ String⁰ Boolean⁰))
 (define⁰
  (may-loop?⁰ str⁰)
  (if⁰ (member⁰ str⁰ (quote⁰ (closure multi-scope scope))) #t #f))
 (:⁰
  zo-find-aux⁰
  (->⁰ zo⁰ (Listof⁰ zo⁰) String⁰ Natural⁰ (U⁰ Natural⁰ #f) (Listof⁰ result⁰)))
 (define⁰
  (zo-find-aux⁰ z⁰ hist⁰ str⁰ i⁰ lim⁰)
  (define-values⁰ (title⁰ children⁰) (parse-zo⁰ z⁰))
  (:⁰ results⁰ (Listof⁰ result⁰))
  (define⁰
   results⁰
   (cond⁰
    ((and⁰ lim⁰ (<=⁰ lim⁰ i⁰)) (quote⁰ ()))
    ((and⁰ (may-loop?⁰ title⁰) (memq⁰ z⁰ hist⁰)) (quote⁰ ()))
    (else⁰
     (:⁰ hist*⁰ (Listof⁰ zo⁰))
     (define⁰ hist*⁰ (cons⁰ z⁰ hist⁰))
     (append-all⁰
      (for/list⁰
       :⁰
       (Listof⁰ (Listof⁰ result⁰))
       ((z*⁰ :⁰ zo⁰ children⁰))
       (zo-find-aux⁰ z*⁰ hist*⁰ str⁰ (add1⁰ i⁰) lim⁰))))))
  (if⁰
   (and⁰ (string=?⁰ str⁰ title⁰) (not⁰ (memq⁰ z⁰ (map⁰ result-zo⁰ results⁰))))
   (cons⁰ (result⁰ z⁰ hist⁰) results⁰)
   results⁰))
 (:⁰ parse-zo⁰ (->⁰ zo⁰ (values⁰ String⁰ (Listof⁰ zo⁰))))
 (define⁰
  (parse-zo⁰ z⁰)
  (:⁰ z-spec⁰ Spec⁰)
  (define⁰ z-spec⁰ (zo->spec⁰ z⁰))
  (:⁰ title⁰ String⁰)
  (define⁰ title⁰ (car⁰ z-spec⁰))
  (:⁰ child-strs⁰ (Listof⁰ String⁰))
  (define⁰
   child-strs⁰
   (for/list⁰
    :⁰
    (Listof⁰ String⁰)
    ((pair⁰ :⁰ (Pair⁰ String⁰ (->⁰ (U⁰ String⁰ Spec⁰))) (cdr⁰ z-spec⁰)))
    (car⁰ pair⁰)))
  (values⁰ title⁰ (get-children⁰ z⁰ child-strs⁰)))
 (:⁰ get-children⁰ (->⁰ zo⁰ (Listof⁰ String⁰) (Listof⁰ zo⁰)))
 (define⁰
  (get-children⁰ z⁰ strs⁰)
  (match⁰
   strs⁰
   ((quote⁰ ()) (quote⁰ ()))
   ((cons⁰ hd⁰ tl⁰)
    (define-values⁰ (r*⁰ success*⁰) (zo-transition⁰ z⁰ hd⁰))
    (:⁰ r⁰ (U⁰ zo⁰ (Listof⁰ zo⁰)))
    (define⁰ r⁰ r*⁰)
    (:⁰ success?⁰ Boolean⁰)
    (define⁰ success?⁰ success*⁰)
    (cond⁰
     ((not⁰ success?⁰) (get-children⁰ z⁰ tl⁰))
     ((list?⁰ r⁰) (append⁰ (filter⁰ zo?⁰ r⁰) (get-children⁰ z⁰ tl⁰)))
     ((zo?⁰ r⁰) (cons⁰ r⁰ (get-children⁰ z⁰ tl⁰)))))))).
scv-cr: Working on /home/camoy/wrk/scv-cr/test/zordoz/zo-shell.rkt.
scv-cr: Raw syntax is '(module zo-shell typed/racket/base
   (#%module-begin
    (provide zo-read init)
    (require scv-cr/require-typed-check
             (only-in racket/string string-split string-join string-trim)
             "typed-zo-structs.rkt"
             racket/match
             scv-cr/opaque)
    (require/typed/check
     "zo-string.rkt"
     (zo->spec (-> zo Spec))
     (zo->string (->* (zo) (Boolean) String)))
    (require/typed/check
     "zo-transition.rkt"
     (zo-transition (-> zo String (values (U zo (Listof zo)) Boolean))))
    (require/typed/check
     "zo-find.rkt"
     (zo-find (->* (zo String) ((U Natural #f)) (Listof result)))
     (#:struct result ((zo : zo) (path : (Listof zo)))))
    (require/typed/opaque
     "fake-compiler-zo-parse.rkt"
     (zo-parse (->* () (Input-Port) zo)))
    (define DEBUG #f)
    (define VERSION 1.0)
    (define VNAME "vortex")
    (define-type Context (U zo (Listof zo) (Listof result)))
    (define-type History (Listof Context))
    (define-type History* (Listof History))
    (: init (-> (Immutable-Vector zo String) Void))
    (define (init args)
      (match args ((vector ctx arg) (find-all ctx (list arg)))))
    (: zo-read (-> Path-String zo))
    (define (zo-read fname)
      (call-with-input-file fname (lambda (port) (zo-parse port))))
    (struct
     command
     ((name : String)
      (num-args : Natural)
      (aliases : (Listof String))
      (help-msg : String))
     #:transparent)
    (define-type Command command)
    (define ALST
      (command "alst" 0 (list "a" "alias" "aliases") "Print command aliases"))
    (define BACK
      (command
       "back"
       0
       (list "b" "up" "u" ".." "../" "cd .." "cd ../")
       "Move up to the previous context"))
    (define DIVE
      (command
       "dive"
       1
       (list "d" "cd" "next" "step")
       "Step into struct field ARG"))
    (define FIND
      (command
       "find"
       1
       (list "f" "query" "search" "look")
       "Search the current subtree for structs with the name ARG"))
    (define HELP
      (command
       "help"
       0
       (list "h" "-h" "--h" "-help" "--help")
       "Print this message"))
    (define INFO
      (command
       "info"
       0
       (list "i" "ls" "print" "p" "show")
       "Show information about current context"))
    (define JUMP
      (command
       "jump"
       0
       (list "j" "warp" "top")
       "Revert to last saved position"))
    (define SAVE
      (command
       "save"
       0
       (list "mark")
       "Save the current context as jump target"))
    (define QUIT
      (command
       "quit"
       0
       (list "q" "exit" "leave" "bye")
       "Exit the interpreter"))
    (define COMMANDS (list ALST BACK DIVE FIND HELP INFO JUMP SAVE QUIT))
    (: cmd? (-> Command (-> String Boolean)))
    (define ((cmd? c) str)
      (define splt (string-split str))
      (or (and (string=? "back" (command-name c))
               (member? str (list "cd .." "cd ../")))
          (and (= (sub1 (length splt)) (command-num-args c))
               (or (string=? (car splt) (command-name c))
                   (member? (car splt) (command-aliases c))))))
    (: filename->shell (-> String Void))
    (define (filename->shell name)
      (print-info (format "Loading bytecode file '~a'..." name))
      (call-with-input-file
       name
       (lambda ((port : Input-Port))
         (print-info "Parsing bytecode...")
         (define ctx (zo-parse port))
         (print-info "Parsing complete!")
         (print-welcome)
         ((repl ctx '() '()) '()))))
    (: zo->shell (-> zo Void))
    (define (zo->shell z) (print-welcome) ((repl z '() '()) '()))
    (: split-cd (-> (Listof String) (Listof String)))
    (define (split-cd cmd*)
      (match
       cmd*
       ('() '())
       ((cons cd-cmd rest)
        #:when
        (starts-with? cd-cmd "cd ")
        (append
         (map
          (lambda ((x : String)) (string-append "cd " x))
          (string-split (substring cd-cmd 3) "/"))
         (split-cd rest)))
       ((cons cmd rest) (cons cmd (split-cd rest)))))
    (: repl (-> Context History (Listof History) (-> (Listof String) Void)))
    (define ((repl ctx hist pre-hist) cmd*)
      (when DEBUG (print-history hist))
      (match
       cmd*
       ('()
        (print-prompt ctx)
        (define ln (read-line))
        (if (eof-object? ln)
          (error 'zo-shell:repl "EOF: you have penetrated me")
          ((repl ctx hist pre-hist)
           (split-cd
            (for/list
             :
             (Listof String)
             ((str (in-list (string-split ln ";"))))
             (string-trim str))))))
       ((cons (? (cmd? ALST) raw) cmd*)
        (print-alias)
        ((repl ctx hist pre-hist) cmd*))
       ((cons (? (cmd? BACK) raw) cmd*)
        ((let-values (((c h p) (back raw ctx hist pre-hist))) (repl c h p))
         cmd*))
       ((cons (? (cmd? DIVE) raw) cmd*)
        ((let-values (((c h p) (dive raw ctx hist pre-hist))) (repl c h p))
         cmd*))
       ((cons (? (cmd? FIND) raw) cmd*)
        ((let-values (((c h p) (find raw ctx hist pre-hist))) (repl c h p))
         cmd*))
       ((cons (? (cmd? HELP) raw) cmd*)
        (begin (print-help) ((repl ctx hist pre-hist) cmd*)))
       ((cons (? (cmd? INFO) raw) cmd*)
        (begin (print-context ctx) ((repl ctx hist pre-hist) cmd*)))
       ((cons (? (cmd? JUMP) raw) cmd*)
        ((let-values (((c h p) (jump raw ctx hist pre-hist))) (repl c h p))
         cmd*))
       ((cons (? (cmd? SAVE) raw) cmd*)
        ((let-values (((c h p) (save raw ctx hist pre-hist))) (repl c h p))
         cmd*))
       ((cons (? (cmd? QUIT) raw) cmd*) (print-goodbye))
       ((cons raw cmd*)
        (begin (print-unknown raw) ((repl ctx hist pre-hist) cmd*)))))
    (define BACK-WARNING
      (string-append
       "BACK removing most recent 'save' mark. "
       "Be sure to save if you want to continue exploring search result."))
    (:
     back
     (-> String Context History History* (Values Context History History*)))
    (define (back raw ctx hist pre-hist)
      (match
       (list hist pre-hist)
       ((list '() '()) (print-unknown raw) (values ctx hist pre-hist))
       ((list '() _)
        (displayln BACK-WARNING)
        (define-values (hist* pre-hist*) (pop pre-hist))
        (back raw ctx hist* pre-hist*))
       (_
        (define-values (ctx* hist*) (pop hist))
        (values ctx* hist* pre-hist))))
    (:
     dive
     (-> String Context History History* (Values Context History History*)))
    (define (dive raw ctx hist pre-hist)
      (define arg (split-snd raw))
      (define-values
       (ctx* hist*)
       (cond
        ((not arg) (print-unknown raw) (values ctx hist))
        ((list? ctx) (dive-list ctx hist arg))
        ((zo? ctx) (dive-zo ctx hist arg))
        (else (error 'zo-shell:dive (format "Invalid context '~a'" ctx)))))
      (values ctx* hist* pre-hist))
    (:
     dive-list
     (->
      (U (Listof result) (Listof zo))
      History
      String
      (Values Context History)))
    (define (dive-list ctx hist arg)
      (define index (string->number arg))
      (cond
       ((or (not index)
            (not (index? index))
            (< index 0)
            (>= index (length ctx)))
        (print-unknown (format "dive ~a" arg))
        (values ctx hist))
       (else
        (define res (list-ref ctx index))
        (if (result? res)
          (values (result-zo res) (result-path res))
          (values res (push hist ctx))))))
    (: dive-zo (-> zo History String (Values Context History)))
    (define (dive-zo ctx hist field)
      (define-values (ctx* success?) (zo-transition ctx field))
      (cond
       (success? (values ctx* (push hist ctx)))
       (else (print-unknown (format "dive ~a" field)) (values ctx hist))))
    (:
     find
     (-> String Context History History* (Values Context History History*)))
    (define (find raw ctx hist pre-hist)
      (define arg (split-snd raw))
      (cond
       ((and arg (zo? ctx))
        (define results (zo-find ctx arg))
        (printf "FIND returned ~a results\n" (length results))
        (match
         results
         ('() (values ctx hist pre-hist))
         (_
          (printf "FIND automatically saving context\n")
          (print-context results)
          (save "" results (push hist ctx) pre-hist))))
       (else (print-unknown raw) (values ctx hist pre-hist))))
    (:
     jump
     (-> String Context History History* (Values Context History History*)))
    (define (jump raw ctx hist pre-hist)
      (match
       pre-hist
       ('() (print-unknown raw) (values ctx hist pre-hist))
       (_
        (define-values (hist* pre-hist*) (pop pre-hist))
        (back raw ctx hist* pre-hist*))))
    (:
     save
     (-> String Context History History* (Values Context History History*)))
    (define (save raw ctx hist pre-hist)
      (values ctx '() (push pre-hist (push hist ctx))))
    (: push (All (A) (-> (Listof A) A (Listof A))))
    (define (push hist ctx) (cons ctx hist))
    (: pop (All (A) (-> (Listof A) (values A (Listof A)))))
    (define (pop hist) (values (car hist) (cdr hist)))
    (define (print-alias)
      (displayln "At your service. Command aliases:")
      (displayln
       (string-join
        (for/list
         :
         (Listof String)
         ((cmd : Command COMMANDS))
         (format
          "  ~a        ~a"
          (command-name cmd)
          (string-join (command-aliases cmd))))))
      (newline))
    (: print-history (-> History Void))
    (define (print-history hist) (printf "History is: ~a\n" hist))
    (define (print-help)
      (displayln "At your service. Available commands:")
      (displayln
       (string-join
        (for/list
         :
         (Listof String)
         ((cmd COMMANDS))
         (format
          "  ~a~a    ~a"
          (command-name cmd)
          (if (= 1 (command-num-args cmd)) " ARG" "    ")
          (command-help-msg cmd)))
        "\n")))
    (: print-context (-> Context Void))
    (define (print-context ctx)
      (match
       ctx
       ((? zo?) (displayln (zo->string ctx)))
       ('() (displayln "'()"))
       ((cons x _)
        (define z (if (result? x) (result-zo x) x))
        (printf "~a[~a]\n" (zo->string z #f) (length ctx)))
       (_ (error 'zo-shell:info (format "Unknown context '~a'" ctx)))))
    (: print-unknown (-> String Void))
    (define (print-unknown raw) (printf "'~a' not permitted.\n" raw))
    (define (print-goodbye)
      (printf "Ascending to second-level meditation. Goodbye.\n\n"))
    (: print-debug (-> String Void))
    (define (print-debug str) (printf "DEBUG: ~a\n" str))
    (define (print-welcome)
      (display
       (format
        "\e[1;34m--- Welcome to the .zo shell, version ~a '~a' ---\e[0;0m\n"
        VERSION
        VNAME)))
    (: print-prompt (-> Context Void))
    (define (print-prompt ctx)
      (define tag
        (cond
         ((list? ctx) (format "[~a]" (length ctx)))
         ((zo? ctx) (format "(~a)" (car (zo->spec ctx))))
         (else "")))
      (display (string-append tag " \e[1;32mzo> \e[0;0m")))
    (: print-info (-> String Void))
    (define (print-info str) (printf "INFO: ~a\n" str))
    (: print-warn (-> String Void))
    (define (print-warn str) (printf "WARN: ~a\n" str))
    (define (print-error str) (printf "ERROR: ~a\n" str))
    (define USAGE "Usage: zo-shell <OPTIONS> FILE.zo")
    (define (print-usage) (displayln USAGE))
    (: member? (-> String (Listof String) Boolean))
    (define (member? s str*) (if (member s str*) #t #f))
    (: starts-with? (-> String String Boolean))
    (define (starts-with? str prefix)
      (and (<= (string-length prefix) (string-length str))
           (for/and
            ((i1 (in-range (string-length str)))
             (i2 (in-range (string-length prefix))))
            (char=? (string-ref str i1) (string-ref prefix i2)))))
    (: find-all (->* (zo (Listof String)) ((U Natural #f)) Void))
    (define (find-all ctx args (lim #f))
      (for ((arg (in-list args))) (void (length (zo-find ctx arg lim))))
      (void))
    (: split-snd (-> String (U #f String)))
    (define (split-snd raw)
      (define splt (string-split raw))
      (match
       splt
       ((list _ x) x)
       ((list _ x ys ...)
        (print-warn (format "Ignoring extra arguments: '~a'" ys))
        x)
       (_ #f)))
    (: has-any-flags? (-> (Vectorof String) Boolean))
    (define (has-any-flags? v)
      (for/or
       ((i (in-range (vector-length v))))
       (let ((str (vector-ref v i)))
         (and (< 0 (string-length str)) (eq? #\- (string-ref str 0)))))))).
scv-cr: Elaborated syntax is (module⁰
 zo-shell⁰
 scv-cr/private/lang/scv/base⁰
 (begin⁰
  (module⁰ #%type-decl⁰ racket/base⁰)
  (require⁰ (for-syntax⁰ racket/base⁰))
  (define-syntax⁰ scv-cr?⁰ #t))
 (begin⁰
  (provide⁰
   (contract-out⁰
    (init⁰ generated-contract219⁰)
    (zo-read⁰ generated-contract220⁰)))
  (provide⁰
   g227⁰
   g223⁰
   g228⁰
   generated-contract219⁰
   g226⁰
   g225⁰
   g224⁰
   generated-contract220⁰)
  (require⁰
   (only-in⁰
    (combine-in⁰
     (lib⁰ racket/contract/base.rkt)
     (lib⁰ racket/base.rkt)
     (submod⁰ typed-zo-structs.rkt #%type-decl⁰ ..)
     (lib⁰ racket/contract.rkt))))
  (define⁰ g223⁰ (lambda²⁶˙˙²⁷ (x²⁶˙˙²⁷) (zo?³⁸˙˙⁴⁵ x²⁶˙˙²⁷)))
  (define⁰ g224⁰ string?¹⁰˙˙¹¹)
  (define⁰ g225⁰ (vector/c⁰ g223⁰ g224⁰))
  (define⁰ g226⁰ (lambda²⁶˙˙²⁷ (x²⁶˙˙²⁷) (equal?²⁶˙˙²⁷ x²⁶˙˙²⁷ (void²˙˙³))))
  (define⁰ g227⁰ path?¹⁰˙˙¹¹)
  (define⁰ g228⁰ (or/c⁰ g227⁰ g224⁰))
  (define⁰ generated-contract219⁰ (->⁰ g225⁰ (values²⁴˙˙²⁵ g226⁰)))
  (define⁰ generated-contract220⁰ (->⁰ g228⁰ (values²⁴˙˙²⁵ g223⁰))))
 (begin⁰
  (module⁰
   require/contracts⁰
   scv-cr/private/lang/scv/base⁰
   (begin⁰
    (module⁰ #%type-decl⁰ racket/base⁰)
    (require⁰ (for-syntax⁰ racket/base⁰))
    (define-syntax⁰ scv-cr?⁰ #t))
   (require⁰)
   (begin⁰
    (provide⁰ (contract-out⁰ (zo-parse⁰ l1⁰)))
    (provide⁰ l1⁰ g222⁰ g221⁰)
    (require⁰
     (only-in⁰
      (combine-in⁰
       (lib⁰ racket/base.rkt)
       (submod⁰ typed-zo-structs.rkt #%type-decl⁰ ..)
       (lib⁰ racket/contract.rkt))))
    (define⁰ g221⁰ input-port?¹⁰˙˙¹¹)
    (define⁰ g222⁰ (lambda²⁶˙˙²⁷ (x²⁶˙˙²⁷) (zo?³⁸˙˙⁴⁵ x²⁶˙˙²⁷)))
    (define⁰
     l1⁰
     (case->⁰ (->⁰ (values²⁴˙˙²⁵ g222⁰)) (->⁰ g221⁰ (values²⁴˙˙²⁵ g222⁰)))))
   (begin⁰ (define⁰ zo-parse⁰ #:opaque)))
  (require⁰ (quote⁰ require/contracts⁰))
  (begin⁰
   (require⁰ (only-in⁰ (quote⁰˙˙¹ require/contracts⁰˙˙¹) zo-parse⁰))
   (define-values⁰ (zo-parse⁰) (values⁰ zo-parse⁰˙˙¹))))
 (scv-ignore:provide⁰)
 (require⁰
  scv-cr/require-typed-check⁰
  (only-in⁰ racket/string⁰ string-split⁰ string-join⁰ string-trim⁰)
  typed-zo-structs.rkt
  racket/match⁰
  scv-cr/opaque⁰)
 (require/typed/check⁰
  zo-string.rkt
  (zo->spec⁰ (->⁰ zo⁰ Spec⁰))
  (zo->string⁰ (->*⁰ (zo⁰) (Boolean⁰) String⁰)))
 (require/typed/check⁰
  zo-transition.rkt
  (zo-transition⁰ (->⁰ zo⁰ String⁰ (values⁰ (U⁰ zo⁰ (Listof⁰ zo⁰)) Boolean⁰))))
 (require/typed/check⁰
  zo-find.rkt
  (zo-find⁰ (->*⁰ (zo⁰ String⁰) ((U⁰ Natural⁰ #f)) (Listof⁰ result⁰)))
  (#:struct result⁰ ((zo⁰ :⁰ zo⁰) (path⁰ :⁰ (Listof⁰ zo⁰)))))
 (void⁰)
 (define⁰ DEBUG⁰ #f)
 (define⁰ VERSION⁰ 1.0)
 (define⁰ VNAME⁰ vortex)
 (define-type⁰ Context⁰ (U⁰ zo⁰ (Listof⁰ zo⁰) (Listof⁰ result⁰)))
 (define-type⁰ History⁰ (Listof⁰ Context⁰))
 (define-type⁰ History*⁰ (Listof⁰ History⁰))
 (:⁰ init⁰ (->⁰ (Immutable-Vector⁰ zo⁰ String⁰) Void⁰))
 (define⁰
  (init⁰ args⁰)
  (match⁰ args⁰ ((vector⁰ ctx⁰ arg⁰) (find-all⁰ ctx⁰ (list⁰ arg⁰)))))
 (:⁰ zo-read⁰ (->⁰ Path-String⁰ zo⁰))
 (define⁰
  (zo-read⁰ fname⁰)
  (call-with-input-file⁰ fname⁰ (lambda⁰ (port⁰) (zo-parse⁰ port⁰))))
 (struct⁰
  command⁰
  ((name⁰ :⁰ String⁰)
   (num-args⁰ :⁰ Natural⁰)
   (aliases⁰ :⁰ (Listof⁰ String⁰))
   (help-msg⁰ :⁰ String⁰))
  #:transparent)
 (define-type⁰ Command⁰ command⁰)
 (define⁰
  ALST⁰
  (command⁰ alst 0 (list⁰ a alias aliases) Print command aliases))
 (define⁰
  BACK⁰
  (command⁰
   back
   0
   (list⁰ b up u .. ../ cd .. cd ../)
   Move up to the previous context))
 (define⁰
  DIVE⁰
  (command⁰ dive 1 (list⁰ d cd next step) Step into struct field ARG))
 (define⁰
  FIND⁰
  (command⁰
   find
   1
   (list⁰ f query search look)
   Search the current subtree for structs with the name ARG))
 (define⁰
  HELP⁰
  (command⁰ help 0 (list⁰ h -h --h -help --help) Print this message))
 (define⁰
  INFO⁰
  (command⁰
   info
   0
   (list⁰ i ls print p show)
   Show information about current context))
 (define⁰
  JUMP⁰
  (command⁰ jump 0 (list⁰ j warp top) Revert to last saved position))
 (define⁰
  SAVE⁰
  (command⁰ save 0 (list⁰ mark) Save the current context as jump target))
 (define⁰
  QUIT⁰
  (command⁰ quit 0 (list⁰ q exit leave bye) Exit the interpreter))
 (define⁰
  COMMANDS⁰
  (list⁰ ALST⁰ BACK⁰ DIVE⁰ FIND⁰ HELP⁰ INFO⁰ JUMP⁰ SAVE⁰ QUIT⁰))
 (:⁰ cmd?⁰ (->⁰ Command⁰ (->⁰ String⁰ Boolean⁰)))
 (define⁰
  ((cmd?⁰ c⁰) str⁰)
  (define⁰ splt⁰ (string-split⁰ str⁰))
  (or⁰
   (and⁰
    (string=?⁰ back (command-name⁰ c⁰))
    (member?⁰ str⁰ (list⁰ cd .. cd ../)))
   (and⁰
    (=⁰ (sub1⁰ (length⁰ splt⁰)) (command-num-args⁰ c⁰))
    (or⁰
     (string=?⁰ (car⁰ splt⁰) (command-name⁰ c⁰))
     (member?⁰ (car⁰ splt⁰) (command-aliases⁰ c⁰))))))
 (:⁰ filename->shell⁰ (->⁰ String⁰ Void⁰))
 (define⁰
  (filename->shell⁰ name⁰)
  (print-info⁰ (format⁰ Loading bytecode file '~a'... name⁰))
  (call-with-input-file⁰
   name⁰
   (lambda⁰
    ((port⁰ :⁰ Input-Port⁰))
    (print-info⁰ Parsing bytecode...)
    (define⁰ ctx⁰ (zo-parse⁰ port⁰))
    (print-info⁰ Parsing complete!)
    (print-welcome⁰)
    ((repl⁰ ctx⁰ (quote⁰ ()) (quote⁰ ())) (quote⁰ ())))))
 (:⁰ zo->shell⁰ (->⁰ zo⁰ Void⁰))
 (define⁰
  (zo->shell⁰ z⁰)
  (print-welcome⁰)
  ((repl⁰ z⁰ (quote⁰ ()) (quote⁰ ())) (quote⁰ ())))
 (:⁰ split-cd⁰ (->⁰ (Listof⁰ String⁰) (Listof⁰ String⁰)))
 (define⁰
  (split-cd⁰ cmd*⁰)
  (match⁰
   cmd*⁰
   ((quote⁰ ()) (quote⁰ ()))
   ((cons⁰ cd-cmd⁰ rest⁰)
    #:when
    (starts-with?⁰ cd-cmd⁰ cd )
    (append⁰
     (map⁰
      (lambda⁰ ((x⁰ :⁰ String⁰)) (string-append⁰ cd  x⁰))
      (string-split⁰ (substring⁰ cd-cmd⁰ 3) /))
     (split-cd⁰ rest⁰)))
   ((cons⁰ cmd⁰ rest⁰) (cons⁰ cmd⁰ (split-cd⁰ rest⁰)))))
 (:⁰
  repl⁰
  (->⁰ Context⁰ History⁰ (Listof⁰ History⁰) (->⁰ (Listof⁰ String⁰) Void⁰)))
 (define⁰
  ((repl⁰ ctx⁰ hist⁰ pre-hist⁰) cmd*⁰)
  (when⁰ DEBUG⁰ (print-history⁰ hist⁰))
  (match⁰
   cmd*⁰
   ((quote⁰ ())
    (print-prompt⁰ ctx⁰)
    (define⁰ ln⁰ (read-line⁰))
    (if⁰
     (eof-object?⁰ ln⁰)
     (error⁰ (quote⁰ zo-shell:repl⁰) EOF: you have penetrated me)
     ((repl⁰ ctx⁰ hist⁰ pre-hist⁰)
      (split-cd⁰
       (for/list⁰
        :⁰
        (Listof⁰ String⁰)
        ((str⁰ (in-list⁰ (string-split⁰ ln⁰ ;))))
        (string-trim⁰ str⁰))))))
   ((cons⁰ (?⁰ (cmd?⁰ ALST⁰) raw⁰) cmd*⁰)
    (print-alias⁰)
    ((repl⁰ ctx⁰ hist⁰ pre-hist⁰) cmd*⁰))
   ((cons⁰ (?⁰ (cmd?⁰ BACK⁰) raw⁰) cmd*⁰)
    ((let-values⁰
      (((c⁰ h⁰ p⁰) (back⁰ raw⁰ ctx⁰ hist⁰ pre-hist⁰)))
      (repl⁰ c⁰ h⁰ p⁰))
     cmd*⁰))
   ((cons⁰ (?⁰ (cmd?⁰ DIVE⁰) raw⁰) cmd*⁰)
    ((let-values⁰
      (((c⁰ h⁰ p⁰) (dive⁰ raw⁰ ctx⁰ hist⁰ pre-hist⁰)))
      (repl⁰ c⁰ h⁰ p⁰))
     cmd*⁰))
   ((cons⁰ (?⁰ (cmd?⁰ FIND⁰) raw⁰) cmd*⁰)
    ((let-values⁰
      (((c⁰ h⁰ p⁰) (find⁰ raw⁰ ctx⁰ hist⁰ pre-hist⁰)))
      (repl⁰ c⁰ h⁰ p⁰))
     cmd*⁰))
   ((cons⁰ (?⁰ (cmd?⁰ HELP⁰) raw⁰) cmd*⁰)
    (begin⁰ (print-help⁰) ((repl⁰ ctx⁰ hist⁰ pre-hist⁰) cmd*⁰)))
   ((cons⁰ (?⁰ (cmd?⁰ INFO⁰) raw⁰) cmd*⁰)
    (begin⁰ (print-context⁰ ctx⁰) ((repl⁰ ctx⁰ hist⁰ pre-hist⁰) cmd*⁰)))
   ((cons⁰ (?⁰ (cmd?⁰ JUMP⁰) raw⁰) cmd*⁰)
    ((let-values⁰
      (((c⁰ h⁰ p⁰) (jump⁰ raw⁰ ctx⁰ hist⁰ pre-hist⁰)))
      (repl⁰ c⁰ h⁰ p⁰))
     cmd*⁰))
   ((cons⁰ (?⁰ (cmd?⁰ SAVE⁰) raw⁰) cmd*⁰)
    ((let-values⁰
      (((c⁰ h⁰ p⁰) (save⁰ raw⁰ ctx⁰ hist⁰ pre-hist⁰)))
      (repl⁰ c⁰ h⁰ p⁰))
     cmd*⁰))
   ((cons⁰ (?⁰ (cmd?⁰ QUIT⁰) raw⁰) cmd*⁰) (print-goodbye⁰))
   ((cons⁰ raw⁰ cmd*⁰)
    (begin⁰ (print-unknown⁰ raw⁰) ((repl⁰ ctx⁰ hist⁰ pre-hist⁰) cmd*⁰)))))
 (define⁰
  BACK-WARNING⁰
  (string-append⁰
   BACK removing most recent 'save' mark. 
   Be sure to save if you want to continue exploring search result.))
 (:⁰
  back⁰
  (->⁰
   String⁰
   Context⁰
   History⁰
   History*⁰
   (Values⁰ Context⁰ History⁰ History*⁰)))
 (define⁰
  (back⁰ raw⁰ ctx⁰ hist⁰ pre-hist⁰)
  (match⁰
   (list⁰ hist⁰ pre-hist⁰)
   ((list⁰ (quote⁰ ()) (quote⁰ ()))
    (print-unknown⁰ raw⁰)
    (values⁰ ctx⁰ hist⁰ pre-hist⁰))
   ((list⁰ (quote⁰ ()) _⁰)
    (displayln⁰ BACK-WARNING⁰)
    (define-values⁰ (hist*⁰ pre-hist*⁰) (pop⁰ pre-hist⁰))
    (back⁰ raw⁰ ctx⁰ hist*⁰ pre-hist*⁰))
   (_⁰
    (define-values⁰ (ctx*⁰ hist*⁰) (pop⁰ hist⁰))
    (values⁰ ctx*⁰ hist*⁰ pre-hist⁰))))
 (:⁰
  dive⁰
  (->⁰
   String⁰
   Context⁰
   History⁰
   History*⁰
   (Values⁰ Context⁰ History⁰ History*⁰)))
 (define⁰
  (dive⁰ raw⁰ ctx⁰ hist⁰ pre-hist⁰)
  (define⁰ arg⁰ (split-snd⁰ raw⁰))
  (define-values⁰
   (ctx*⁰ hist*⁰)
   (cond⁰
    ((not⁰ arg⁰) (print-unknown⁰ raw⁰) (values⁰ ctx⁰ hist⁰))
    ((list?⁰ ctx⁰) (dive-list⁰ ctx⁰ hist⁰ arg⁰))
    ((zo?⁰ ctx⁰) (dive-zo⁰ ctx⁰ hist⁰ arg⁰))
    (else⁰
     (error⁰ (quote⁰ zo-shell:dive⁰) (format⁰ Invalid context '~a' ctx⁰)))))
  (values⁰ ctx*⁰ hist*⁰ pre-hist⁰))
 (:⁰
  dive-list⁰
  (->⁰
   (U⁰ (Listof⁰ result⁰) (Listof⁰ zo⁰))
   History⁰
   String⁰
   (Values⁰ Context⁰ History⁰)))
 (define⁰
  (dive-list⁰ ctx⁰ hist⁰ arg⁰)
  (define⁰ index⁰ (string->number⁰ arg⁰))
  (cond⁰
   ((or⁰
     (not⁰ index⁰)
     (not⁰ (index?⁰ index⁰))
     (<⁰ index⁰ 0)
     (>=⁰ index⁰ (length⁰ ctx⁰)))
    (print-unknown⁰ (format⁰ dive ~a arg⁰))
    (values⁰ ctx⁰ hist⁰))
   (else⁰
    (define⁰ res⁰ (list-ref⁰ ctx⁰ index⁰))
    (if⁰
     (result?⁰ res⁰)
     (values⁰ (result-zo⁰ res⁰) (result-path⁰ res⁰))
     (values⁰ res⁰ (push⁰ hist⁰ ctx⁰))))))
 (:⁰ dive-zo⁰ (->⁰ zo⁰ History⁰ String⁰ (Values⁰ Context⁰ History⁰)))
 (define⁰
  (dive-zo⁰ ctx⁰ hist⁰ field⁰)
  (define-values⁰ (ctx*⁰ success?⁰) (zo-transition⁰ ctx⁰ field⁰))
  (cond⁰
   (success?⁰ (values⁰ ctx*⁰ (push⁰ hist⁰ ctx⁰)))
   (else⁰ (print-unknown⁰ (format⁰ dive ~a field⁰)) (values⁰ ctx⁰ hist⁰))))
 (:⁰
  find⁰
  (->⁰
   String⁰
   Context⁰
   History⁰
   History*⁰
   (Values⁰ Context⁰ History⁰ History*⁰)))
 (define⁰
  (find⁰ raw⁰ ctx⁰ hist⁰ pre-hist⁰)
  (define⁰ arg⁰ (split-snd⁰ raw⁰))
  (cond⁰
   ((and⁰ arg⁰ (zo?⁰ ctx⁰))
    (define⁰ results⁰ (zo-find⁰ ctx⁰ arg⁰))
    (printf⁰ FIND returned ~a results
 (length⁰ results⁰))
    (match⁰
     results⁰
     ((quote⁰ ()) (values⁰ ctx⁰ hist⁰ pre-hist⁰))
     (_⁰ (printf⁰ FIND automatically saving context
) (print-context⁰ results⁰) (save⁰  results⁰ (push⁰ hist⁰ ctx⁰) pre-hist⁰))))
   (else⁰ (print-unknown⁰ raw⁰) (values⁰ ctx⁰ hist⁰ pre-hist⁰))))
 (:⁰
  jump⁰
  (->⁰
   String⁰
   Context⁰
   History⁰
   History*⁰
   (Values⁰ Context⁰ History⁰ History*⁰)))
 (define⁰
  (jump⁰ raw⁰ ctx⁰ hist⁰ pre-hist⁰)
  (match⁰
   pre-hist⁰
   ((quote⁰ ()) (print-unknown⁰ raw⁰) (values⁰ ctx⁰ hist⁰ pre-hist⁰))
   (_⁰
    (define-values⁰ (hist*⁰ pre-hist*⁰) (pop⁰ pre-hist⁰))
    (back⁰ raw⁰ ctx⁰ hist*⁰ pre-hist*⁰))))
 (:⁰
  save⁰
  (->⁰
   String⁰
   Context⁰
   History⁰
   History*⁰
   (Values⁰ Context⁰ History⁰ History*⁰)))
 (define⁰
  (save⁰ raw⁰ ctx⁰ hist⁰ pre-hist⁰)
  (values⁰ ctx⁰ (quote⁰ ()) (push⁰ pre-hist⁰ (push⁰ hist⁰ ctx⁰))))
 (:⁰ push⁰ (All⁰ (A⁰) (->⁰ (Listof⁰ A⁰) A⁰ (Listof⁰ A⁰))))
 (define⁰ (push⁰ hist⁰ ctx⁰) (cons⁰ ctx⁰ hist⁰))
 (:⁰ pop⁰ (All⁰ (A⁰) (->⁰ (Listof⁰ A⁰) (values⁰ A⁰ (Listof⁰ A⁰)))))
 (define⁰ (pop⁰ hist⁰) (values⁰ (car⁰ hist⁰) (cdr⁰ hist⁰)))
 (define⁰
  (print-alias⁰)
  (displayln⁰ At your service. Command aliases:)
  (displayln⁰
   (string-join⁰
    (for/list⁰
     :⁰
     (Listof⁰ String⁰)
     ((cmd⁰ :⁰ Command⁰ COMMANDS⁰))
     (format⁰
        ~a        ~a
      (command-name⁰ cmd⁰)
      (string-join⁰ (command-aliases⁰ cmd⁰))))))
  (newline⁰))
 (:⁰ print-history⁰ (->⁰ History⁰ Void⁰))
 (define⁰ (print-history⁰ hist⁰) (printf⁰ History is: ~a
 hist⁰))
 (define⁰
  (print-help⁰)
  (displayln⁰ At your service. Available commands:)
  (displayln⁰
   (string-join⁰
    (for/list⁰
     :⁰
     (Listof⁰ String⁰)
     ((cmd⁰ COMMANDS⁰))
     (format⁰
        ~a~a    ~a
      (command-name⁰ cmd⁰)
      (if⁰ (=⁰ 1 (command-num-args⁰ cmd⁰))  ARG     )
      (command-help-msg⁰ cmd⁰)))
    
)))
 (:⁰ print-context⁰ (->⁰ Context⁰ Void⁰))
 (define⁰
  (print-context⁰ ctx⁰)
  (match⁰
   ctx⁰
   ((?⁰ zo?⁰) (displayln⁰ (zo->string⁰ ctx⁰)))
   ((quote⁰ ()) (displayln⁰ '()))
   ((cons⁰ x⁰ _⁰) (define⁰ z⁰ (if⁰ (result?⁰ x⁰) (result-zo⁰ x⁰) x⁰)) (printf⁰ ~a[~a]
 (zo->string⁰ z⁰ #f) (length⁰ ctx⁰)))
   (_⁰ (error⁰ (quote⁰ zo-shell:info⁰) (format⁰ Unknown context '~a' ctx⁰)))))
 (:⁰ print-unknown⁰ (->⁰ String⁰ Void⁰))
 (define⁰ (print-unknown⁰ raw⁰) (printf⁰ '~a' not permitted.
 raw⁰))
 (define⁰ (print-goodbye⁰) (printf⁰ Ascending to second-level meditation. Goodbye.

))
 (:⁰ print-debug⁰ (->⁰ String⁰ Void⁰))
 (define⁰ (print-debug⁰ str⁰) (printf⁰ DEBUG: ~a
 str⁰))
 (define⁰ (print-welcome⁰) (display⁰ (format⁰ [1;34m--- Welcome to the .zo shell, version ~a '~a' ---[0;0m
 VERSION⁰ VNAME⁰)))
 (:⁰ print-prompt⁰ (->⁰ Context⁰ Void⁰))
 (define⁰
  (print-prompt⁰ ctx⁰)
  (define⁰
   tag⁰
   (cond⁰
    ((list?⁰ ctx⁰) (format⁰ [~a] (length⁰ ctx⁰)))
    ((zo?⁰ ctx⁰) (format⁰ (~a) (car⁰ (zo->spec⁰ ctx⁰))))
    (else⁰ )))
  (display⁰ (string-append⁰ tag⁰  [1;32mzo> [0;0m)))
 (:⁰ print-info⁰ (->⁰ String⁰ Void⁰))
 (define⁰ (print-info⁰ str⁰) (printf⁰ INFO: ~a
 str⁰))
 (:⁰ print-warn⁰ (->⁰ String⁰ Void⁰))
 (define⁰ (print-warn⁰ str⁰) (printf⁰ WARN: ~a
 str⁰))
 (define⁰ (print-error⁰ str⁰) (printf⁰ ERROR: ~a
 str⁰))
 (define⁰ USAGE⁰ Usage: zo-shell <OPTIONS> FILE.zo)
 (define⁰ (print-usage⁰) (displayln⁰ USAGE⁰))
 (:⁰ member?⁰ (->⁰ String⁰ (Listof⁰ String⁰) Boolean⁰))
 (define⁰ (member?⁰ s⁰ str*⁰) (if⁰ (member⁰ s⁰ str*⁰) #t #f))
 (:⁰ starts-with?⁰ (->⁰ String⁰ String⁰ Boolean⁰))
 (define⁰
  (starts-with?⁰ str⁰ prefix⁰)
  (and⁰
   (<=⁰ (string-length⁰ prefix⁰) (string-length⁰ str⁰))
   (for/and⁰
    ((i1⁰ (in-range⁰ (string-length⁰ str⁰)))
     (i2⁰ (in-range⁰ (string-length⁰ prefix⁰))))
    (char=?⁰ (string-ref⁰ str⁰ i1⁰) (string-ref⁰ prefix⁰ i2⁰)))))
 (:⁰ find-all⁰ (->*⁰ (zo⁰ (Listof⁰ String⁰)) ((U⁰ Natural⁰ #f)) Void⁰))
 (define⁰
  (find-all⁰ ctx⁰ args⁰ (lim⁰ #f))
  (for⁰ ((arg⁰ (in-list⁰ args⁰))) (void⁰ (length⁰ (zo-find⁰ ctx⁰ arg⁰ lim⁰))))
  (void⁰))
 (:⁰ split-snd⁰ (->⁰ String⁰ (U⁰ #f String⁰)))
 (define⁰
  (split-snd⁰ raw⁰)
  (define⁰ splt⁰ (string-split⁰ raw⁰))
  (match⁰
   splt⁰
   ((list⁰ _⁰ x⁰) x⁰)
   ((list⁰ _⁰ x⁰ ys⁰ ...⁰)
    (print-warn⁰ (format⁰ Ignoring extra arguments: '~a' ys⁰))
    x⁰)
   (_⁰ #f)))
 (:⁰ has-any-flags?⁰ (->⁰ (Vectorof⁰ String⁰) Boolean⁰))
 (define⁰
  (has-any-flags?⁰ v⁰)
  (for/or⁰
   ((i⁰ (in-range⁰ (vector-length⁰ v⁰))))
   (let⁰
    ((str⁰ (vector-ref⁰ v⁰ i⁰)))
    (and⁰ (<⁰ 0 (string-length⁰ str⁰)) (eq?⁰ - (string-ref⁰ str⁰ 0))))))).
scv-cr: Working on /home/camoy/wrk/scv-cr/test/zordoz/zo-string.rkt.
scv-cr: Raw syntax is '(module zo-string typed/racket/base
   (#%module-begin
    (provide zo->string zo->spec Spec)
    (require racket/match
             (only-in racket/list empty?)
             (only-in racket/string string-join)
             (for-syntax racket/base racket/syntax)
             "typed-zo-structs.rkt")
    (require/typed racket/base (srcloc->string (-> (U #f srcloc) String)))
    (: zo->spec (-> zo Spec))
    (define (zo->spec z)
      (: z* (U Spec #f))
      (define z* (try-spec z))
      (if z* z* (error (format "Cannot format unknown struct ~e" z))))
    (: zo->string (->* (zo) (Boolean) String))
    (define (zo->string z (deep? #t)) (format-spec deep? (zo->spec z)))
    (define-syntax (lcons stx)
      (syntax-case stx ()
        ((_) (raise-syntax-error #f "[lcons] Expected two arguments."))
        ((_ _) (raise-syntax-error #f "[lcons] Expected two arguments."))
        ((_ hd tl) #'(cons hd (lambda () tl)))))
    (: try-spec (-> zo Spec))
    (define (try-spec z)
      (match
       z
       ((? compilation-top?) (compilation-top->spec z))
       ((? prefix?) (prefix->spec z))
       ((? global-bucket?) (global-bucket->spec z))
       ((? module-variable?) (module-variable->spec z))
       ((? stx?) (stx->spec z))
       ((? form?) (form->spec z))
       ((? expr?) (expr->spec z))
       ((? stx-obj?) (stx-obj->spec z))
       ((? wrap?) (wrap->spec z))
       ((? module-shift?) (module-shift->spec z))
       ((? scope?) (scope->spec z))
       ((? multi-scope?) (multi-scope->spec z))
       ((? binding?) (binding->spec z))
       ((? all-from-module?) (all-from-module->spec z))
       ((? provided?) (provided->spec z))
       (x (error 'try-spec (format "unknown struct ~e" z)))))
    (: form->spec (-> form Spec))
    (define (form->spec z)
      (match
       z
       ((? def-values?) (def-values->spec z))
       ((? def-syntaxes?) (def-syntaxes->spec z))
       ((? seq-for-syntax?) (seq-for-syntax->spec z))
       ((? req?) (req->spec z))
       ((? seq?) (seq->spec z))
       ((? splice?) (splice->spec z))
       ((? inline-variant?) (inline-variant->spec z))
       ((? mod?) (mod->spec z))
       ((? expr?) (expr->spec z))
       (x (error 'form (format "unknown struct ~e" z)))))
    (: expr->spec (-> expr Spec))
    (define (expr->spec z)
      (match
       z
       ((? lam?) (lam->spec z))
       ((? closure?) (closure->spec z))
       ((? case-lam?) (case-lam->spec z))
       ((? let-one?) (let-one->spec z))
       ((? let-void?) (let-void->spec z))
       ((? install-value?) (install-value->spec z))
       ((? let-rec?) (let-rec->spec z))
       ((? boxenv?) (boxenv->spec z))
       ((? localref?) (localref->spec z))
       ((? toplevel?) (toplevel->spec z))
       ((? topsyntax?) (topsyntax->spec z))
       ((? application?) (application->spec z))
       ((? branch?) (branch->spec z))
       ((? with-cont-mark?) (with-cont-mark->spec z))
       ((? beg0?) (beg0->spec z))
       ((? varref?) (varref->spec z))
       ((? assign?) (assign->spec z))
       ((? apply-values?) (apply-values->spec z))
       ((? with-immed-mark?) (with-immed-mark->spec z))
       ((? primval?) (primval->spec z))
       (x (error 'expr (format "unknown struct ~e" z)))))
    (: binding->spec (-> binding Spec))
    (define (binding->spec z)
      (match
       z
       ((? module-binding?) (module-binding->spec z))
       ((? decoded-module-binding?) (decoded-module-binding->spec z))
       ((? local-binding?) (local-binding->spec z))
       ((? free-id=?-binding?) (free-id=?-binding->spec z))
       (x 'binding (error (format "unknown struct ~e" z)))))
    (: compilation-top->spec (-> compilation-top Spec))
    (define (compilation-top->spec z)
      (list
       "compilation-top"
       (lcons
        "max-let-depth"
        (number->string (compilation-top-max-let-depth z)))
       (lcons
        "binding-namess"
        (hash->string (compilation-top-binding-namess z)))
       (lcons "prefix" (prefix->spec (compilation-top-prefix z)))
       (lcons "code" (form-or-any->string (compilation-top-code z)))))
    (: prefix->spec (-> prefix Spec))
    (define (prefix->spec z)
      (: tl->spec (-> (U #f Symbol global-bucket module-variable) String))
      (define (tl->spec tl)
        (match
         tl
         ((? module-variable?) (format-spec #f (module-variable->spec tl)))
         ((? global-bucket?) (format-spec #f (global-bucket->spec tl)))
         ((? symbol?) (symbol->string tl))
         (#f "#f")))
      (list
       "prefix"
       (lcons "num-lifts" (number->string (prefix-num-lifts z)))
       (lcons "toplevels" (list->string tl->spec (prefix-toplevels z)))
       (lcons
        "stxs"
        (listof-zo->string
         stx->spec
         (for/list : (Listof stx) ((sx (prefix-stxs z)) #:when sx) sx)))
       (lcons
        "src-inspector-desc"
        (symbol->string (prefix-src-inspector-desc z)))))
    (: global-bucket->spec (-> global-bucket Spec))
    (define (global-bucket->spec z)
      (list
       "global-bucket"
       (lcons "name" (symbol->string (global-bucket-name z)))))
    (: module-variable->spec (-> module-variable Spec))
    (define (module-variable->spec z)
      (:
       constantness->spec
       (-> (U #f 'constant 'fixed function-shape struct-shape) String))
      (define (constantness->spec cs)
        (cond
         ((symbol? cs) (symbol->string cs))
         ((function-shape? cs) (function-shape->spec cs))
         ((struct-shape? cs) (struct-shape->spec cs))
         (else "#f")))
      (list
       "module-variable"
       (lcons "modidx" (module-path-index->string (module-variable-modidx z)))
       (lcons "sym" (symbol->string (module-variable-sym z)))
       (lcons "pos" (number->string (module-variable-pos z)))
       (lcons "phase" (number->string (module-variable-phase z)))
       (lcons
        "constantness"
        (constantness->spec (module-variable-constantness z)))))
    (: stx->spec (-> stx Spec))
    (define (stx->spec z)
      (list "stx" (lcons "content" (stx-obj->spec (stx-content z)))))
    (: all-from-module->spec (-> all-from-module Spec))
    (define (all-from-module->spec z)
      (list
       "all-from-module"
       (lcons "path" (module-path-index->string (all-from-module-path z)))
       (lcons "phase" (number-or-f->string (all-from-module-phase z)))
       (lcons "src-phase" (number-or-f->string (all-from-module-src-phase z)))
       (lcons
        "inspector-desc"
        (symbol->string (all-from-module-inspector-desc z)))
       (lcons
        "exceptions"
        (list->string symbol->string (all-from-module-exceptions z)))
       (lcons "prefix" (symbol-or-f->string (all-from-module-prefix z)))))
    (: def-values->spec (-> def-values Spec))
    (define (def-values->spec z)
      (: toplevel-or-symbol->string (-> (U toplevel Symbol) String))
      (define (toplevel-or-symbol->string tl)
        (match
         tl
         ((? toplevel?) (format-spec #f (toplevel->spec tl)))
         ((? symbol?) (symbol->string tl))))
      (list
       "def-values"
       (lcons
        "ids"
        (list->string toplevel-or-symbol->string (def-values-ids z)))
       (lcons
        "rhs"
        (let ((rhs (def-values-rhs z)))
          (cond
           ((inline-variant? rhs) (inline-variant->spec rhs))
           (else (expr-seq-any->string rhs)))))))
    (: def-syntaxes->spec (-> def-syntaxes Spec))
    (define (def-syntaxes->spec z)
      (: toplevel-or-symbol->string (-> (U toplevel Symbol) String))
      (define (toplevel-or-symbol->string tl)
        (match
         tl
         ((? toplevel?) (format-spec #f (toplevel->spec tl)))
         ((? symbol?) (symbol->string tl))))
      (list
       "def-syntaxes"
       (lcons
        "ids"
        (list->string toplevel-or-symbol->string (def-syntaxes-ids z)))
       (lcons "rhs" (expr-seq-any->string (def-syntaxes-rhs z)))
       (lcons "prefix" (prefix->spec (def-syntaxes-prefix z)))
       (lcons "max-let-depth" (number->string (def-syntaxes-max-let-depth z)))
       (lcons "dummy" (toplevel-or-any->string (def-syntaxes-dummy z)))))
    (: seq-for-syntax->spec (-> seq-for-syntax Spec))
    (define (seq-for-syntax->spec z)
      (list
       "seq-for-syntax"
       (lcons "forms" (listof-form-or-any->string (seq-for-syntax-forms z)))
       (lcons "prefix" (prefix->spec (seq-for-syntax-prefix z)))
       (lcons
        "max-let-depth"
        (number->string (seq-for-syntax-max-let-depth z)))
       (lcons "dummy" (toplevel-or-any->string (seq-for-syntax-dummy z)))))
    (: req->spec (-> req Spec))
    (define (req->spec z)
      (list
       "req"
       (lcons "reqs" (stx->spec (req-reqs z)))
       (lcons "dummy" (toplevel->spec (req-dummy z)))))
    (: seq->spec (-> seq Spec))
    (define (seq->spec z)
      (list "seq" (lcons "forms" (listof-form-or-any->string (seq-forms z)))))
    (: splice->spec (-> splice Spec))
    (define (splice->spec z)
      (list
       "splice"
       (lcons "forms" (listof-form-or-any->string (splice-forms z)))))
    (: inline-variant->spec (-> inline-variant Spec))
    (define (inline-variant->spec z)
      (list
       "inline-variant"
       (lcons "direct" (expr->spec (inline-variant-direct z)))
       (lcons "inline" (expr->spec (inline-variant-inline z)))))
    (: mod->spec (-> mod Spec))
    (define (mod->spec z)
      (: name->spec (-> (U Symbol (Listof Symbol)) String))
      (define (name->spec nm)
        (match
         nm
         ((? list?) (list->string symbol->string nm))
         ((? symbol?) (symbol->string nm))))
      (:
       unexported->spec
       (->
        (Listof
         (List Exact-Nonnegative-Integer (Listof Symbol) (Listof Symbol)))
        String))
      (define (unexported->spec ux)
        (:
         elem->spec
         (->
          (List Exact-Nonnegative-Integer (Listof Symbol) (Listof Symbol))
          String))
        (define (elem->spec e)
          (format-list
           (list
            (number->string (car e))
            (list->string symbol->string (cadr e))
            (list->string symbol->string (caddr e)))
           " "))
        (list->string elem->spec ux))
      (: lang-info->spec (-> (U #f (Vector Module-Path Symbol Any)) String))
      (define (lang-info->spec li)
        (match
         li
         ((vector mp sym any)
          (format-list
           (list (module-path->spec mp) (symbol->string sym) (any->string any))
           " "))
         (#f "#f")))
      (:
       provides->spec
       (->
        (Listof (List (U Integer #f) (Listof provided) (Listof provided)))
        String))
      (define (provides->spec pds)
        (:
         elem->spec
         (-> (List (U Integer #f) (Listof provided) (Listof provided)) String))
        (define (elem->spec e)
          (format-list
           (list
            (if (number? (car e)) (number->string (car e)) "#f")
            (listof-zo->string provided->spec (cadr e))
            (listof-zo->string provided->spec (caddr e)))
           " "))
        (list->string elem->spec pds))
      (:
       requires->spec
       (-> (Listof (Pair (U Integer #f) (Listof Module-Path-Index))) String))
      (define (requires->spec rqs)
        (:
         elem->spec
         (-> (Pair (U Integer #f) (Listof Module-Path-Index)) String))
        (define (elem->spec e)
          (format-list
           (list
            (if (number? (car e)) (number->string (car e)) "#f")
            (list->string module-path-index->string (cdr e)))
           " "))
        (list->string elem->spec rqs))
      (:
       syntax-bodies->spec
       (->
        (Listof
         (Pair
          Exact-Positive-Integer
          (Listof (U def-syntaxes seq-for-syntax))))
        String))
      (define (syntax-bodies->spec sbs)
        (: ds-or-sfs->spec (-> (U def-syntaxes seq-for-syntax) String))
        (define (ds-or-sfs->spec d)
          (cond
           ((def-syntaxes? d) (format-spec #f (def-syntaxes->spec d)))
           ((seq-for-syntax? d) (format-spec #f (seq-for-syntax->spec d)))))
        (:
         elem->spec
         (->
          (Pair
           Exact-Positive-Integer
           (Listof (U def-syntaxes seq-for-syntax)))
          String))
        (define (elem->spec e)
          (format-list
           (list
            (number->string (car e))
            (list->string ds-or-sfs->spec (cdr e)))
           " "))
        (list->string elem->spec sbs))
      (:
       internal-context->string
       (-> (U #f #t stx (Vectorof stx)) (U Spec String)))
      (define (internal-context->string ic)
        (match
         ic
         ((? stx? ic) (stx->spec ic))
         ((? vector? ic) (listof-zo->string stx->spec (vector->list ic)))
         ((? boolean? ic) (boolean->string ic))))
      (list
       "mod"
       (lcons "name" (name->spec (mod-name z)))
       (lcons "srcname" (symbol->string (mod-srcname z)))
       (lcons "self-modidx" (module-path-index->string (mod-self-modidx z)))
       (lcons "prefix" (prefix->spec (mod-prefix z)))
       (lcons "provides" (provides->spec (mod-provides z)))
       (lcons "requires" (requires->spec (mod-requires z)))
       (lcons "body" (listof-form-or-any->string (mod-body z)))
       (lcons "syntax-bodies" (syntax-bodies->spec (mod-syntax-bodies z)))
       (lcons "unexported" (unexported->spec (mod-unexported z)))
       (lcons "max-let-depth" (number->string (mod-max-let-depth z)))
       (lcons "dummy" (toplevel->spec (mod-dummy z)))
       (lcons "lang-info" (lang-info->spec (mod-lang-info z)))
       (lcons
        "internal-context"
        (internal-context->string (mod-internal-context z)))
       (lcons "binding-names" (format "~a" (mod-binding-names z)))
       (lcons "flags" (list->string symbol->string (mod-flags z)))
       (lcons
        "pre-submodules"
        (listof-zo->string mod->spec (mod-pre-submodules z)))
       (lcons
        "post-submodules"
        (listof-zo->string mod->spec (mod-post-submodules z)))))
    (: provided->spec (-> provided Spec))
    (define (provided->spec z)
      (: mpi-or-f->string (-> (U Module-Path-Index #f) String))
      (define (mpi-or-f->string x)
        (if (eq? #f x) "#f" (module-path-index->string x)))
      (list
       "provided"
       (lcons "name" (symbol->string (provided-name z)))
       (lcons "src" (mpi-or-f->string (provided-src z)))
       (lcons "src-name" (symbol->string (provided-src-name z)))
       (lcons "nom-src" (any->string (provided-nom-src z)))
       (lcons "src-phase" (number->string (provided-src-phase z)))
       (lcons "protected?" (boolean->string (provided-protected? z)))))
    (: lam-name->spec (-> (U Symbol (Vectorof Any) (List)) String))
    (define (lam-name->spec nm)
      (match
       nm
       ((? vector?) (any->string nm))
       ((? empty?) "()")
       ((? symbol?) (symbol->string nm))))
    (: lam->spec (-> lam Spec))
    (define (lam->spec z)
      (: closure-map->spec (-> (Vectorof Exact-Nonnegative-Integer) String))
      (define (closure-map->spec cm)
        (list->string number->string (vector->list cm)))
      (:
       toplevel-map->spec
       (-> (U #f (Setof Exact-Nonnegative-Integer)) String))
      (define (toplevel-map->spec tm)
        (cond
         ((eq? #f tm) "#f")
         (else
          (format-list
           (for/list
            :
            (Listof String)
            ((n : Exact-Nonnegative-Integer tm))
            (number->string n))
           " "))))
      (list
       "lam"
       (lcons "name" (lam-name->spec (lam-name z)))
       (lcons "flags" (list->string symbol->string (lam-flags z)))
       (lcons "num-params" (number->string (lam-num-params z)))
       (lcons "param-types" (list->string symbol->string (lam-param-types z)))
       (lcons "rest?" (boolean->string (lam-rest? z)))
       (lcons "closure-map" (closure-map->spec (lam-closure-map z)))
       (lcons
        "closure-types"
        (list->string symbol->string (lam-closure-types z)))
       (lcons "toplevel-map" (toplevel-map->spec (lam-toplevel-map z)))
       (lcons "max-let-depth" (number->string (lam-max-let-depth z)))
       (lcons "body" (expr-seq-any->string (lam-body z)))))
    (: closure->spec (-> closure Spec))
    (define (closure->spec z)
      (list
       "closure"
       (lcons "code" (lam->spec (closure-code z)))
       (lcons "gen-id" (symbol->string (closure-gen-id z)))))
    (: case-lam->spec (-> case-lam Spec))
    (define (case-lam->spec z)
      (list
       "case-lam"
       (lcons "name" (lam-name->spec (case-lam-name z)))
       (lcons
        "clauses"
        (list->string
         (lambda ((x : (U lam closure))) (format-spec #f (expr->spec x)))
         (case-lam-clauses z)))))
    (: let-one->spec (-> let-one Spec))
    (define (let-one->spec z)
      (list
       "let-one"
       (lcons "rhs" (expr-seq-any->string (let-one-rhs z)))
       (lcons "body" (expr-seq-any->string (let-one-body z)))
       (lcons "type" (symbol-or-f->string (let-one-type z)))
       (lcons "unused?" (boolean->string (let-one-unused? z)))))
    (: let-void->spec (-> let-void Spec))
    (define (let-void->spec z)
      (list
       "let-void"
       (lcons "count" (number->string (let-void-count z)))
       (lcons "boxes" (boolean->string (let-void-boxes? z)))
       (lcons "body" (expr-seq-any->string (let-void-body z)))))
    (: install-value->spec (-> install-value Spec))
    (define (install-value->spec z)
      (list
       "install-value"
       (lcons "count" (number->string (install-value-count z)))
       (lcons "pos" (number->string (install-value-pos z)))
       (lcons "boxes?" (boolean->string (install-value-boxes? z)))
       (lcons "rhs" (expr-seq-any->string (install-value-rhs z)))
       (lcons "body" (expr-seq-any->string (install-value-body z)))))
    (: let-rec->spec (-> let-rec Spec))
    (define (let-rec->spec z)
      (list
       "let-rec"
       (lcons
        "procs"
        (list->string
         (lambda ((lm : lam)) (format-spec #f (lam->spec lm)))
         (let-rec-procs z)))
       (lcons "body" (expr-seq-any->string (let-rec-body z)))))
    (: boxenv->spec (-> boxenv Spec))
    (define (boxenv->spec z)
      (list
       "boxenv"
       (lcons "pos" (number->string (boxenv-pos z)))
       (lcons "body" (expr-seq-any->string (boxenv-body z)))))
    (: localref->spec (-> localref Spec))
    (define (localref->spec z)
      (list
       "localref"
       (lcons "unbox?" (boolean->string (localref-unbox? z)))
       (lcons "pos" (number->string (localref-pos z)))
       (lcons "clear?" (boolean->string (localref-clear? z)))
       (lcons "other-clears?" (boolean->string (localref-other-clears? z)))
       (lcons "type" (symbol-or-f->string (localref-type z)))))
    (: toplevel->spec (-> toplevel Spec))
    (define (toplevel->spec z)
      (list
       "toplevel"
       (lcons "depth" (number->string (toplevel-depth z)))
       (lcons "pos" (number->string (toplevel-pos z)))
       (lcons "const?" (boolean->string (toplevel-const? z)))
       (lcons "ready?" (boolean->string (toplevel-ready? z)))))
    (: topsyntax->spec (-> topsyntax Spec))
    (define (topsyntax->spec z)
      (list
       "topsyntax"
       (lcons "depth" (number->string (topsyntax-depth z)))
       (lcons "pos" (number->string (topsyntax-pos z)))
       (lcons "midpt" (number->string (topsyntax-midpt z)))))
    (: application->spec (-> application Spec))
    (define (application->spec z)
      (list
       "application"
       (lcons "rator" (expr-seq-any->string (application-rator z)))
       (lcons
        "rands"
        (list->string expr-seq-any->string (application-rands z)))))
    (: branch->spec (-> branch Spec))
    (define (branch->spec z)
      (list
       "branch"
       (lcons "test" (expr-seq-any->string (branch-test z)))
       (lcons "then" (expr-seq-any->string (branch-then z)))
       (lcons "else" (expr-seq-any->string (branch-else z)))))
    (: with-cont-mark->spec (-> with-cont-mark Spec))
    (define (with-cont-mark->spec z)
      (list
       "with-cont-mark"
       (lcons "key" (expr-seq-any->string (with-cont-mark-key z)))
       (lcons "val" (expr-seq-any->string (with-cont-mark-val z)))
       (lcons "body" (expr-seq-any->string (with-cont-mark-body z)))))
    (: beg0->spec (-> beg0 Spec))
    (define (beg0->spec z)
      (list
       "beg0"
       (lcons "seq" (list->string expr-seq-any->string (beg0-seq z)))))
    (: varref->spec (-> varref Spec))
    (define (varref->spec z)
      (list
       "varref"
       (lcons
        "toplevel"
        (match
         (varref-toplevel z)
         ((? toplevel? tl) (toplevel->spec tl))
         (#t "#t")))
       (lcons
        "dummy"
        (match
         (varref-dummy z)
         ((? toplevel? dm) (toplevel->spec dm))
         (#f "#f")))))
    (: assign->spec (-> assign Spec))
    (define (assign->spec z)
      (list
       "assign"
       (lcons "id" (toplevel->spec (assign-id z)))
       (lcons "rhs" (expr-seq-any->string (assign-rhs z)))
       (lcons "undef-ok?" (boolean->string (assign-undef-ok? z)))))
    (: apply-values->spec (-> apply-values Spec))
    (define (apply-values->spec z)
      (list
       "apply-values"
       (lcons "proc" (expr-seq-any->string (apply-values-proc z)))
       (lcons "args-expr" (expr-seq-any->string (apply-values-args-expr z)))))
    (: with-immed-mark->spec (-> with-immed-mark Spec))
    (define (with-immed-mark->spec z)
      (list
       "with-immed-mark"
       (lcons "key" (expr-seq-any->string (with-immed-mark-key z)))
       (lcons "def-val" (expr-seq-any->string (with-immed-mark-def-val z)))
       (lcons "body" (expr-seq-any->string (with-immed-mark-body z)))))
    (: primval->spec (-> primval Spec))
    (define (primval->spec z)
      (list "primval" (lcons "id" (number->string (primval-id z)))))
    (: stx-obj->spec (-> stx-obj Spec))
    (define (stx-obj->spec so)
      (list
       "stx-obj"
       (lcons "datum" (any->string (stx-obj-datum so)))
       (lcons "wrap" (wrap->spec (stx-obj-wrap so)))
       (lcons "srcloc" (srcloc->string (stx-obj-srcloc so)))
       (lcons "props" (hash->string (stx-obj-props so)))
       (lcons "tamper-status" (symbol->string (stx-obj-tamper-status so)))))
    (: wrap->spec (-> wrap Spec))
    (define (wrap->spec wp)
      (: ms->string (-> (List multi-scope (U #f Integer)) String))
      (define (ms->string ms+id)
        (format
         "(~a ~a)"
         (format-spec #f (multi-scope->spec (car ms+id)))
         (number-or-f->string (cadr ms+id))))
      (list
       "wrap"
       (lcons "shifts" (listof-zo->string module-shift->spec (wrap-shifts wp)))
       (lcons
        "simple-scopes"
        (listof-zo->string scope->spec (wrap-simple-scopes wp)))
       (lcons
        "multi-scopes"
        (list->string ms->string (wrap-multi-scopes wp)))))
    (: module-shift->spec (-> module-shift Spec))
    (define (module-shift->spec ms)
      (list
       "module-shift"
       (lcons
        "from"
        (cond
         ((module-shift-from ms) => module-path-index->string)
         (else "#f")))
       (lcons
        "to"
        (cond ((module-shift-to ms) => module-path-index->string) (else "#f")))
       (lcons
        "from-inspector-desc"
        (symbol-or-f->string (module-shift-from-inspector-desc ms)))
       (lcons
        "to-inspector-desc"
        (symbol-or-f->string (module-shift-to-inspector-desc ms)))))
    (: scope->spec (-> scope Spec))
    (define (scope->spec sc)
      (:
       sym+scope+binding->string
       (-> (List Symbol (Listof scope) binding) String))
      (define (sym+scope+binding->string ssbs)
        (format
         "(~a ~a ~a)"
         (symbol->string (car ssbs))
         (listof-zo->string scope->spec (cadr ssbs))
         (format-spec #f (binding->spec (caddr ssbs)))))
      (:
       scope+all-from-module->string
       (-> (List (Listof scope) all-from-module) String))
      (define (scope+all-from-module->string bbs)
        (format
         "(~a ~a)"
         (listof-zo->string scope->spec (car bbs))
         (format-spec #f (all-from-module->spec (cadr bbs)))))
      (list
       "scope"
       (lcons
        "name"
        (let ((name : (U 'root Integer) (scope-name sc)))
          (cond ((eq? 'root name) "root") (else (number->string name)))))
       (lcons "kind" (symbol->string (scope-kind sc)))
       (lcons
        "bindings"
        (list->string sym+scope+binding->string (scope-bindings sc)))
       (lcons
        "bulk-bindings"
        (list->string scope+all-from-module->string (scope-bulk-bindings sc)))
       (lcons
        "multi-owner"
        (cond ((scope-multi-owner sc) => multi-scope->spec) (else "#f")))))
    (: multi-scope->spec (-> multi-scope Spec))
    (define (multi-scope->spec ms)
      (: sc->string (-> (List (U Integer #f) scope) String))
      (define (sc->string id+scope)
        (format
         "(~a ~a)"
         (number-or-f->string (car id+scope))
         (format-spec #f (scope->spec (cadr id+scope)))))
      (list
       "multi-scope"
       (lcons "name" (number->string (multi-scope-name ms)))
       (lcons "src-name" (any->string (multi-scope-src-name ms)))
       (lcons "scopes" (list->string sc->string (multi-scope-scopes ms)))))
    (: module-binding->spec (-> module-binding Spec))
    (define (module-binding->spec mb)
      (list
       "module-binding"
       (lcons "encoded" (any->string (module-binding-encoded mb)))))
    (: decoded-module-binding->spec (-> decoded-module-binding Spec))
    (define (decoded-module-binding->spec dmb)
      (list
       "decoded-module-binding"
       (lcons
        "path"
        (cond
         ((decoded-module-binding-path dmb) => module-path-index->string)
         (else "#f")))
       (lcons "name" (symbol->string (decoded-module-binding-name dmb)))
       (lcons "phase" (number->string (decoded-module-binding-phase dmb)))
       (lcons
        "nominal-path"
        (cond
         ((decoded-module-binding-nominal-path dmb)
          =>
          module-path-index->string)
         (else "#f")))
       (lcons
        "nominal-export-name"
        (symbol->string (decoded-module-binding-nominal-export-name dmb)))
       (lcons
        "nominal-phase"
        (number-or-f->string (decoded-module-binding-nominal-phase dmb)))
       (lcons
        "import-phase"
        (number-or-f->string (decoded-module-binding-import-phase dmb)))
       (lcons
        "inspector-desc"
        (symbol-or-f->string (decoded-module-binding-inspector-desc dmb)))))
    (: local-binding->spec (-> local-binding Spec))
    (define (local-binding->spec lb)
      (list
       "local-binding"
       (lcons "name" (symbol->string (local-binding-name lb)))))
    (: free-id=?-binding->spec (-> free-id=?-binding Spec))
    (define (free-id=?-binding->spec fib)
      (list
       "free-id=?-binding"
       (lcons "base" (binding->spec (free-id=?-binding-base fib)))
       (lcons "id" (stx-obj->spec (free-id=?-binding-id fib)))
       (lcons "phase" (number-or-f->string (free-id=?-binding-phase fib)))))
    (: function-shape->spec (-> function-shape String))
    (define (function-shape->spec fs)
      (format-list
       (list
        "function-shape"
        (format "arity : ~a" (function-shape-arity fs))
        (format "preserves-marks? : ~a" (function-shape-preserves-marks? fs)))
       " "))
    (: struct-shape->spec (-> struct-shape String))
    (define (struct-shape->spec ss)
      (cond
       ((struct-type-shape? ss) (struct-type-shape->spec ss))
       ((constructor-shape? ss) (constructor-shape->spec ss))
       ((predicate-shape? ss) (predicate-shape->spec ss))
       ((accessor-shape? ss) (accessor-shape->spec ss))
       ((mutator-shape? ss) (mutator-shape->spec ss))
       ((struct-other-shape? ss) (struct-other-shape->spec ss))
       (else (error (format "unknown struct shape ~a" ss)))))
    (: struct-type-shape->spec (-> struct-type-shape String))
    (define (struct-type-shape->spec sts)
      (format-list
       (list
        "struct-type-shape"
        (format "field-count : ~a" (struct-type-shape-field-count sts)))
       " "))
    (: constructor-shape->spec (-> constructor-shape String))
    (define (constructor-shape->spec cs)
      (format-list
       (list
        "constructor-shape"
        (format "arity : ~a" (constructor-shape-arity cs)))
       " "))
    (: predicate-shape->spec (-> predicate-shape String))
    (define (predicate-shape->spec ps) (format-list (list "predicate-shape")))
    (: accessor-shape->spec (-> accessor-shape String))
    (define (accessor-shape->spec sts)
      (format-list
       (list
        "accessor-shape"
        (format "field-count : ~a" (accessor-shape-field-count sts)))
       " "))
    (: mutator-shape->spec (-> mutator-shape String))
    (define (mutator-shape->spec sts)
      (format-list
       (list
        "mutator-shape"
        (format "field-count : ~a" (mutator-shape-field-count sts)))
       " "))
    (: struct-other-shape->spec (-> struct-other-shape String))
    (define (struct-other-shape->spec ps)
      (format-list (list "struct-other-shape")))
    (: any->string (-> Any String))
    (define (any->string z) (format "~a" z))
    (: boolean->string (-> Boolean String))
    (define (boolean->string b) (any->string b))
    (: expr-seq-any->string (-> (U expr seq Any) String))
    (define (expr-seq-any->string z)
      (cond
       ((expr? z) (format-spec #f (expr->spec z)))
       ((seq? z) (format-spec #f (seq->spec z)))
       (else (any->string z))))
    (: form-or-any->string (-> (U form Any) String))
    (define (form-or-any->string fm)
      (cond
       ((form? fm) (format-spec #f (form->spec fm)))
       (else (any->string fm))))
    (: format-list (->* ((Listof String)) (String) String))
    (define (format-list xs (sep "\n")) (string-join xs sep))
    (: format-spec (-> Boolean Spec String))
    (define (format-spec deep? struct-spec)
      (: fields (Listof (Pair String (-> (U Spec String)))))
      (define fields (cdr struct-spec))
      (: title String)
      (define title (format "<struct:~a>" (car struct-spec)))
      (: field-name-lengths (Listof Index))
      (define field-name-lengths
        (for/list ((fd fields)) (string-length (car fd))))
      (: w Nonnegative-Fixnum)
      (define w (if (empty? fields) 0 (apply max field-name-lengths)))
      (if (not deep?)
        title
        (format-list
         (cons
          title
          (for/list
           :
           (Listof String)
           ((fd : (Pair String (-> (U Spec String))) fields))
           (: forced (U String Spec))
           (define forced ((cdr fd)))
           (: rest String)
           (define rest (if (string? forced) forced (format-spec #f forced)))
           (format "  ~a : ~a" (pad (car fd) w) rest))))))
    (: list->string (All (A) (-> (-> A String) (Listof A) String)))
    (define (list->string f xs)
      (format
       "[~a]"
       (format-list (for/list : (Listof String) ((x : A xs)) (f x)) " ")))
    (: listof-form-or-any->string (-> (Listof (U form Any)) String))
    (define (listof-form-or-any->string xs)
      (list->string form-or-any->string xs))
    (: listof-zo->string (All (A) (-> (-> A Spec) (Listof A) String)))
    (define (listof-zo->string z->spec zs)
      (cond
       ((empty? zs) "[]")
       (else
        (format "~a[~a]" (format-spec #f (z->spec (car zs))) (length zs)))))
    (: module-path-index->string (-> Module-Path-Index String))
    (define (module-path-index->string mpi) (any->string mpi))
    (: module-path->spec (-> Module-Path String))
    (define (module-path->spec mp) (any->string mp))
    (: number-or-f->string (-> (U Number #f) String))
    (define (number-or-f->string nf) (if (eq? #f nf) "#f" (number->string nf)))
    (: symbol-or-f->string (-> (U Symbol #f) String))
    (define (symbol-or-f->string sf) (if (eq? #f sf) "#f" (symbol->string sf)))
    (: hash->string (All (A B) (-> (HashTable A B) String)))
    (define (hash->string h) (format "~a" h))
    (: toplevel-or-any->string (-> (U toplevel Any) String))
    (define (toplevel-or-any->string tl)
      (cond
       ((toplevel? tl) (format-spec #f (toplevel->spec tl)))
       (else (any->string tl))))
    (: pad (->* (String Natural) (Char) String))
    (define (pad str w (c #\space))
      (: l Index)
      (define l (string-length str))
      (cond
       ((< l w) (format "~a~a" str (make-string (- w l) c)))
       (else str))))).
scv-cr: Elaborated syntax is (module⁰
 zo-string⁰
 scv-cr/private/lang/scv/base⁰
 (begin⁰
  (module⁰ #%type-decl⁰ racket/base⁰)
  (require⁰ (for-syntax⁰ racket/base⁰))
  (define-syntax⁰ scv-cr?⁰ #t))
 (begin⁰
  (provide⁰
   (contract-out⁰
    (zo->string⁰ generated-contract359⁰)
    (zo->spec⁰ generated-contract358⁰)))
  (provide⁰
   g375⁰
   generated-contract359⁰
   generated-contract358⁰
   g372⁰
   g373⁰
   g374⁰
   g371⁰
   g367⁰)
  (require⁰
   (only-in⁰
    (combine-in⁰
     (lib⁰ racket/contract/base.rkt)
     (lib⁰ racket/base.rkt)
     (submod⁰ typed-zo-structs.rkt #%type-decl⁰ ..)
     (lib⁰ racket/contract.rkt))))
  (define⁰ g367⁰ (lambda⁴⁶˙˙⁴⁷ (x⁴⁶˙˙⁴⁷) (zo?⁴⁸˙˙⁵⁵ x⁴⁶˙˙⁴⁷)))
  (define⁰ g371⁰ string?¹⁰˙˙¹¹)
  (define⁰
   g372⁰
   (letrec⁵⁶˙˙⁵⁷
    ((g44398364⁰ (recursive-contract⁰ g44398364368⁰ #:chaperone))
     (g44398365⁰ (recursive-contract⁰ g44398365369⁰ #:chaperone))
     (g44398366⁰ (recursive-contract⁰ g44398366370⁰ #:chaperone))
     (g44398364368⁰
      (cons/c⁰
       g371⁰
       (listof⁰
        (cons/c⁰ g371⁰ (->⁰ (values⁵⁸˙˙⁵⁹ (or/c⁰ g371⁰ g44398364⁰)))))))
     (g44398365369⁰
      (cons/c⁰
       g371⁰
       (listof⁰
        (cons/c⁰ g371⁰ (->⁰ (values⁵⁸˙˙⁵⁹ (or/c⁰ g371⁰ g44398365⁰)))))))
     (g44398366370⁰
      (cons/c⁰
       g371⁰
       (listof⁰
        (cons/c⁰ g371⁰ (->⁰ (values⁵⁸˙˙⁵⁹ (or/c⁰ g371⁰ g44398366⁰))))))))
    g44398365⁰))
  (define⁰ g373⁰ (quote⁴⁶˙˙⁴⁷ #t))
  (define⁰ g374⁰ (quote⁴⁶˙˙⁴⁷ #f))
  (define⁰ g375⁰ (or/c⁰ g373⁰ g374⁰))
  (define⁰ generated-contract358⁰ (->⁰ g367⁰ (values⁵⁸˙˙⁵⁹ g372⁰)))
  (define⁰
   generated-contract359⁰
   (case->⁰
    (->⁰ g367⁰ (values⁵⁸˙˙⁵⁹ g371⁰))
    (->⁰ g367⁰ g375⁰ (values⁵⁸˙˙⁵⁹ g371⁰)))))
 (begin⁰
  (module⁰
   require/contracts⁰
   scv-cr/private/lang/scv/base⁰
   (begin⁰
    (module⁰ #%type-decl⁰ racket/base⁰)
    (require⁰ (for-syntax⁰ racket/base⁰))
    (define-syntax⁰ scv-cr?⁰ #t))
   (require⁰ racket/base⁰)
   (begin⁰
    (provide⁰ (contract-out⁰ (srcloc->string⁰ l1⁰)))
    (provide⁰ g360⁰ g363⁰ g362⁰ g361⁰ l1⁰)
    (require⁰
     (only-in⁰
      (combine-in⁰
       (lib⁰ racket/contract/base.rkt)
       (lib⁰ racket/base.rkt)
       (lib⁰ racket/contract.rkt))))
    (define⁰ g360⁰ (quote⁴⁶˙˙⁴⁷ #f))
    (define⁰ g361⁰ (lambda⁴⁶˙˙⁴⁷ (x⁴⁶˙˙⁴⁷) (srcloc?⁶⁰˙˙⁶¹ x⁴⁶˙˙⁴⁷)))
    (define⁰ g362⁰ (or/c⁰ g360⁰ g361⁰))
    (define⁰ g363⁰ string?¹⁰˙˙¹¹)
    (define⁰ l1⁰ (->⁰ g362⁰ (values⁵⁸˙˙⁵⁹ g363⁰)))))
  (require⁰ (quote⁰ require/contracts⁰))
  (begin⁰
   (require⁰ (only-in⁰ (quote⁰˙˙¹ require/contracts⁰˙˙¹) srcloc->string⁰))
   (define-values⁰ (srcloc->string⁰) (values⁰ srcloc->string⁰˙˙¹))))
 (scv-ignore:provide⁰ Spec⁰)
 (require⁰
  racket/match⁰
  (only-in⁰ racket/list⁰ empty?⁰)
  (only-in⁰ racket/string⁰ string-join⁰)
  (for-syntax⁰ racket/base⁰ racket/syntax⁰)
  typed-zo-structs.rkt)
 (void⁰)
 (:⁰ zo->spec⁰ (->⁰ zo⁰ Spec⁰))
 (define⁰
  (zo->spec⁰ z⁰)
  (:⁰ z*⁰ (U⁰ Spec⁰ #f))
  (define⁰ z*⁰ (try-spec⁰ z⁰))
  (if⁰ z*⁰ z*⁰ (error⁰ (format⁰ Cannot format unknown struct ~e z⁰))))
 (:⁰ zo->string⁰ (->*⁰ (zo⁰) (Boolean⁰) String⁰))
 (define⁰ (zo->string⁰ z⁰ (deep?⁰ #t)) (format-spec⁰ deep?⁰ (zo->spec⁰ z⁰)))
 (define-syntax⁰
  (lcons⁰ stx⁰)
  (syntax-case⁰
   stx⁰
   ()
   ((_⁰) (raise-syntax-error⁰ #f [lcons] Expected two arguments.))
   ((_⁰ _⁰) (raise-syntax-error⁰ #f [lcons] Expected two arguments.))
   ((_⁰ hd⁰ tl⁰) (syntax⁰ (cons⁰ hd⁰ (lambda⁰ () tl⁰))))))
 (:⁰ try-spec⁰ (->⁰ zo⁰ Spec⁰))
 (define⁰
  (try-spec⁰ z⁰)
  (match⁰
   z⁰
   ((?⁰ compilation-top?⁰) (compilation-top->spec⁰ z⁰))
   ((?⁰ prefix?⁰) (prefix->spec⁰ z⁰))
   ((?⁰ global-bucket?⁰) (global-bucket->spec⁰ z⁰))
   ((?⁰ module-variable?⁰) (module-variable->spec⁰ z⁰))
   ((?⁰ stx?⁰) (stx->spec⁰ z⁰))
   ((?⁰ form?⁰) (form->spec⁰ z⁰))
   ((?⁰ expr?⁰) (expr->spec⁰ z⁰))
   ((?⁰ stx-obj?⁰) (stx-obj->spec⁰ z⁰))
   ((?⁰ wrap?⁰) (wrap->spec⁰ z⁰))
   ((?⁰ module-shift?⁰) (module-shift->spec⁰ z⁰))
   ((?⁰ scope?⁰) (scope->spec⁰ z⁰))
   ((?⁰ multi-scope?⁰) (multi-scope->spec⁰ z⁰))
   ((?⁰ binding?⁰) (binding->spec⁰ z⁰))
   ((?⁰ all-from-module?⁰) (all-from-module->spec⁰ z⁰))
   ((?⁰ provided?⁰) (provided->spec⁰ z⁰))
   (x⁰ (error⁰ (quote⁰ try-spec⁰) (format⁰ unknown struct ~e z⁰)))))
 (:⁰ form->spec⁰ (->⁰ form⁰ Spec⁰))
 (define⁰
  (form->spec⁰ z⁰)
  (match⁰
   z⁰
   ((?⁰ def-values?⁰) (def-values->spec⁰ z⁰))
   ((?⁰ def-syntaxes?⁰) (def-syntaxes->spec⁰ z⁰))
   ((?⁰ seq-for-syntax?⁰) (seq-for-syntax->spec⁰ z⁰))
   ((?⁰ req?⁰) (req->spec⁰ z⁰))
   ((?⁰ seq?⁰) (seq->spec⁰ z⁰))
   ((?⁰ splice?⁰) (splice->spec⁰ z⁰))
   ((?⁰ inline-variant?⁰) (inline-variant->spec⁰ z⁰))
   ((?⁰ mod?⁰) (mod->spec⁰ z⁰))
   ((?⁰ expr?⁰) (expr->spec⁰ z⁰))
   (x⁰ (error⁰ (quote⁰ form⁰) (format⁰ unknown struct ~e z⁰)))))
 (:⁰ expr->spec⁰ (->⁰ expr⁰ Spec⁰))
 (define⁰
  (expr->spec⁰ z⁰)
  (match⁰
   z⁰
   ((?⁰ lam?⁰) (lam->spec⁰ z⁰))
   ((?⁰ closure?⁰) (closure->spec⁰ z⁰))
   ((?⁰ case-lam?⁰) (case-lam->spec⁰ z⁰))
   ((?⁰ let-one?⁰) (let-one->spec⁰ z⁰))
   ((?⁰ let-void?⁰) (let-void->spec⁰ z⁰))
   ((?⁰ install-value?⁰) (install-value->spec⁰ z⁰))
   ((?⁰ let-rec?⁰) (let-rec->spec⁰ z⁰))
   ((?⁰ boxenv?⁰) (boxenv->spec⁰ z⁰))
   ((?⁰ localref?⁰) (localref->spec⁰ z⁰))
   ((?⁰ toplevel?⁰) (toplevel->spec⁰ z⁰))
   ((?⁰ topsyntax?⁰) (topsyntax->spec⁰ z⁰))
   ((?⁰ application?⁰) (application->spec⁰ z⁰))
   ((?⁰ branch?⁰) (branch->spec⁰ z⁰))
   ((?⁰ with-cont-mark?⁰) (with-cont-mark->spec⁰ z⁰))
   ((?⁰ beg0?⁰) (beg0->spec⁰ z⁰))
   ((?⁰ varref?⁰) (varref->spec⁰ z⁰))
   ((?⁰ assign?⁰) (assign->spec⁰ z⁰))
   ((?⁰ apply-values?⁰) (apply-values->spec⁰ z⁰))
   ((?⁰ with-immed-mark?⁰) (with-immed-mark->spec⁰ z⁰))
   ((?⁰ primval?⁰) (primval->spec⁰ z⁰))
   (x⁰ (error⁰ (quote⁰ expr⁰) (format⁰ unknown struct ~e z⁰)))))
 (:⁰ binding->spec⁰ (->⁰ binding⁰ Spec⁰))
 (define⁰
  (binding->spec⁰ z⁰)
  (match⁰
   z⁰
   ((?⁰ module-binding?⁰) (module-binding->spec⁰ z⁰))
   ((?⁰ decoded-module-binding?⁰) (decoded-module-binding->spec⁰ z⁰))
   ((?⁰ local-binding?⁰) (local-binding->spec⁰ z⁰))
   ((?⁰ free-id=?-binding?⁰) (free-id=?-binding->spec⁰ z⁰))
   (x⁰ (quote⁰ binding⁰) (error⁰ (format⁰ unknown struct ~e z⁰)))))
 (:⁰ compilation-top->spec⁰ (->⁰ compilation-top⁰ Spec⁰))
 (define⁰
  (compilation-top->spec⁰ z⁰)
  (list⁰
   compilation-top
   (lcons⁰ max-let-depth (number->string⁰ (compilation-top-max-let-depth⁰ z⁰)))
   (lcons⁰ binding-namess (hash->string⁰ (compilation-top-binding-namess⁰ z⁰)))
   (lcons⁰ prefix (prefix->spec⁰ (compilation-top-prefix⁰ z⁰)))
   (lcons⁰ code (form-or-any->string⁰ (compilation-top-code⁰ z⁰)))))
 (:⁰ prefix->spec⁰ (->⁰ prefix⁰ Spec⁰))
 (define⁰
  (prefix->spec⁰ z⁰)
  (:⁰ tl->spec⁰ (->⁰ (U⁰ #f Symbol⁰ global-bucket⁰ module-variable⁰) String⁰))
  (define⁰
   (tl->spec⁰ tl⁰)
   (match⁰
    tl⁰
    ((?⁰ module-variable?⁰) (format-spec⁰ #f (module-variable->spec⁰ tl⁰)))
    ((?⁰ global-bucket?⁰) (format-spec⁰ #f (global-bucket->spec⁰ tl⁰)))
    ((?⁰ symbol?⁰) (symbol->string⁰ tl⁰))
    (#f #f)))
  (list⁰
   prefix
   (lcons⁰ num-lifts (number->string⁰ (prefix-num-lifts⁰ z⁰)))
   (lcons⁰ toplevels (list->string⁰ tl->spec⁰ (prefix-toplevels⁰ z⁰)))
   (lcons⁰
    stxs
    (listof-zo->string⁰
     stx->spec⁰
     (for/list⁰ :⁰ (Listof⁰ stx⁰) ((sx⁰ (prefix-stxs⁰ z⁰)) #:when sx⁰) sx⁰)))
   (lcons⁰
    src-inspector-desc
    (symbol->string⁰ (prefix-src-inspector-desc⁰ z⁰)))))
 (:⁰ global-bucket->spec⁰ (->⁰ global-bucket⁰ Spec⁰))
 (define⁰
  (global-bucket->spec⁰ z⁰)
  (list⁰
   global-bucket
   (lcons⁰ name (symbol->string⁰ (global-bucket-name⁰ z⁰)))))
 (:⁰ module-variable->spec⁰ (->⁰ module-variable⁰ Spec⁰))
 (define⁰
  (module-variable->spec⁰ z⁰)
  (:⁰
   constantness->spec⁰
   (->⁰
    (U⁰ #f (quote⁰ constant⁰) (quote⁰ fixed⁰) function-shape⁰ struct-shape⁰)
    String⁰))
  (define⁰
   (constantness->spec⁰ cs⁰)
   (cond⁰
    ((symbol?⁰ cs⁰) (symbol->string⁰ cs⁰))
    ((function-shape?⁰ cs⁰) (function-shape->spec⁰ cs⁰))
    ((struct-shape?⁰ cs⁰) (struct-shape->spec⁰ cs⁰))
    (else⁰ #f)))
  (list⁰
   module-variable
   (lcons⁰ modidx (module-path-index->string⁰ (module-variable-modidx⁰ z⁰)))
   (lcons⁰ sym (symbol->string⁰ (module-variable-sym⁰ z⁰)))
   (lcons⁰ pos (number->string⁰ (module-variable-pos⁰ z⁰)))
   (lcons⁰ phase (number->string⁰ (module-variable-phase⁰ z⁰)))
   (lcons⁰
    constantness
    (constantness->spec⁰ (module-variable-constantness⁰ z⁰)))))
 (:⁰ stx->spec⁰ (->⁰ stx⁰ Spec⁰))
 (define⁰
  (stx->spec⁰ z⁰)
  (list⁰ stx (lcons⁰ content (stx-obj->spec⁰ (stx-content⁰ z⁰)))))
 (:⁰ all-from-module->spec⁰ (->⁰ all-from-module⁰ Spec⁰))
 (define⁰
  (all-from-module->spec⁰ z⁰)
  (list⁰
   all-from-module
   (lcons⁰ path (module-path-index->string⁰ (all-from-module-path⁰ z⁰)))
   (lcons⁰ phase (number-or-f->string⁰ (all-from-module-phase⁰ z⁰)))
   (lcons⁰ src-phase (number-or-f->string⁰ (all-from-module-src-phase⁰ z⁰)))
   (lcons⁰
    inspector-desc
    (symbol->string⁰ (all-from-module-inspector-desc⁰ z⁰)))
   (lcons⁰
    exceptions
    (list->string⁰ symbol->string⁰ (all-from-module-exceptions⁰ z⁰)))
   (lcons⁰ prefix (symbol-or-f->string⁰ (all-from-module-prefix⁰ z⁰)))))
 (:⁰ def-values->spec⁰ (->⁰ def-values⁰ Spec⁰))
 (define⁰
  (def-values->spec⁰ z⁰)
  (:⁰ toplevel-or-symbol->string⁰ (->⁰ (U⁰ toplevel⁰ Symbol⁰) String⁰))
  (define⁰
   (toplevel-or-symbol->string⁰ tl⁰)
   (match⁰
    tl⁰
    ((?⁰ toplevel?⁰) (format-spec⁰ #f (toplevel->spec⁰ tl⁰)))
    ((?⁰ symbol?⁰) (symbol->string⁰ tl⁰))))
  (list⁰
   def-values
   (lcons⁰
    ids
    (list->string⁰ toplevel-or-symbol->string⁰ (def-values-ids⁰ z⁰)))
   (lcons⁰
    rhs
    (let⁰
     ((rhs⁰ (def-values-rhs⁰ z⁰)))
     (cond⁰
      ((inline-variant?⁰ rhs⁰) (inline-variant->spec⁰ rhs⁰))
      (else⁰ (expr-seq-any->string⁰ rhs⁰)))))))
 (:⁰ def-syntaxes->spec⁰ (->⁰ def-syntaxes⁰ Spec⁰))
 (define⁰
  (def-syntaxes->spec⁰ z⁰)
  (:⁰ toplevel-or-symbol->string⁰ (->⁰ (U⁰ toplevel⁰ Symbol⁰) String⁰))
  (define⁰
   (toplevel-or-symbol->string⁰ tl⁰)
   (match⁰
    tl⁰
    ((?⁰ toplevel?⁰) (format-spec⁰ #f (toplevel->spec⁰ tl⁰)))
    ((?⁰ symbol?⁰) (symbol->string⁰ tl⁰))))
  (list⁰
   def-syntaxes
   (lcons⁰
    ids
    (list->string⁰ toplevel-or-symbol->string⁰ (def-syntaxes-ids⁰ z⁰)))
   (lcons⁰ rhs (expr-seq-any->string⁰ (def-syntaxes-rhs⁰ z⁰)))
   (lcons⁰ prefix (prefix->spec⁰ (def-syntaxes-prefix⁰ z⁰)))
   (lcons⁰ max-let-depth (number->string⁰ (def-syntaxes-max-let-depth⁰ z⁰)))
   (lcons⁰ dummy (toplevel-or-any->string⁰ (def-syntaxes-dummy⁰ z⁰)))))
 (:⁰ seq-for-syntax->spec⁰ (->⁰ seq-for-syntax⁰ Spec⁰))
 (define⁰
  (seq-for-syntax->spec⁰ z⁰)
  (list⁰
   seq-for-syntax
   (lcons⁰ forms (listof-form-or-any->string⁰ (seq-for-syntax-forms⁰ z⁰)))
   (lcons⁰ prefix (prefix->spec⁰ (seq-for-syntax-prefix⁰ z⁰)))
   (lcons⁰ max-let-depth (number->string⁰ (seq-for-syntax-max-let-depth⁰ z⁰)))
   (lcons⁰ dummy (toplevel-or-any->string⁰ (seq-for-syntax-dummy⁰ z⁰)))))
 (:⁰ req->spec⁰ (->⁰ req⁰ Spec⁰))
 (define⁰
  (req->spec⁰ z⁰)
  (list⁰
   req
   (lcons⁰ reqs (stx->spec⁰ (req-reqs⁰ z⁰)))
   (lcons⁰ dummy (toplevel->spec⁰ (req-dummy⁰ z⁰)))))
 (:⁰ seq->spec⁰ (->⁰ seq⁰ Spec⁰))
 (define⁰
  (seq->spec⁰ z⁰)
  (list⁰ seq (lcons⁰ forms (listof-form-or-any->string⁰ (seq-forms⁰ z⁰)))))
 (:⁰ splice->spec⁰ (->⁰ splice⁰ Spec⁰))
 (define⁰
  (splice->spec⁰ z⁰)
  (list⁰
   splice
   (lcons⁰ forms (listof-form-or-any->string⁰ (splice-forms⁰ z⁰)))))
 (:⁰ inline-variant->spec⁰ (->⁰ inline-variant⁰ Spec⁰))
 (define⁰
  (inline-variant->spec⁰ z⁰)
  (list⁰
   inline-variant
   (lcons⁰ direct (expr->spec⁰ (inline-variant-direct⁰ z⁰)))
   (lcons⁰ inline (expr->spec⁰ (inline-variant-inline⁰ z⁰)))))
 (:⁰ mod->spec⁰ (->⁰ mod⁰ Spec⁰))
 (define⁰
  (mod->spec⁰ z⁰)
  (:⁰ name->spec⁰ (->⁰ (U⁰ Symbol⁰ (Listof⁰ Symbol⁰)) String⁰))
  (define⁰
   (name->spec⁰ nm⁰)
   (match⁰
    nm⁰
    ((?⁰ list?⁰) (list->string⁰ symbol->string⁰ nm⁰))
    ((?⁰ symbol?⁰) (symbol->string⁰ nm⁰))))
  (:⁰
   unexported->spec⁰
   (->⁰
    (Listof⁰
     (List⁰ Exact-Nonnegative-Integer⁰ (Listof⁰ Symbol⁰) (Listof⁰ Symbol⁰)))
    String⁰))
  (define⁰
   (unexported->spec⁰ ux⁰)
   (:⁰
    elem->spec⁰
    (->⁰
     (List⁰ Exact-Nonnegative-Integer⁰ (Listof⁰ Symbol⁰) (Listof⁰ Symbol⁰))
     String⁰))
   (define⁰
    (elem->spec⁰ e⁰)
    (format-list⁰
     (list⁰
      (number->string⁰ (car⁰ e⁰))
      (list->string⁰ symbol->string⁰ (cadr⁰ e⁰))
      (list->string⁰ symbol->string⁰ (caddr⁰ e⁰)))
      ))
   (list->string⁰ elem->spec⁰ ux⁰))
  (:⁰
   lang-info->spec⁰
   (->⁰ (U⁰ #f (Vector⁰ Module-Path⁰ Symbol⁰ Any⁰)) String⁰))
  (define⁰
   (lang-info->spec⁰ li⁰)
   (match⁰
    li⁰
    ((vector⁰ mp⁰ sym⁰ any⁰)
     (format-list⁰
      (list⁰
       (module-path->spec⁰ mp⁰)
       (symbol->string⁰ sym⁰)
       (any->string⁰ any⁰))
       ))
    (#f #f)))
  (:⁰
   provides->spec⁰
   (->⁰
    (Listof⁰ (List⁰ (U⁰ Integer⁰ #f) (Listof⁰ provided⁰) (Listof⁰ provided⁰)))
    String⁰))
  (define⁰
   (provides->spec⁰ pds⁰)
   (:⁰
    elem->spec⁰
    (->⁰
     (List⁰ (U⁰ Integer⁰ #f) (Listof⁰ provided⁰) (Listof⁰ provided⁰))
     String⁰))
   (define⁰
    (elem->spec⁰ e⁰)
    (format-list⁰
     (list⁰
      (if⁰ (number?⁰ (car⁰ e⁰)) (number->string⁰ (car⁰ e⁰)) #f)
      (listof-zo->string⁰ provided->spec⁰ (cadr⁰ e⁰))
      (listof-zo->string⁰ provided->spec⁰ (caddr⁰ e⁰)))
      ))
   (list->string⁰ elem->spec⁰ pds⁰))
  (:⁰
   requires->spec⁰
   (->⁰
    (Listof⁰ (Pair⁰ (U⁰ Integer⁰ #f) (Listof⁰ Module-Path-Index⁰)))
    String⁰))
  (define⁰
   (requires->spec⁰ rqs⁰)
   (:⁰
    elem->spec⁰
    (->⁰ (Pair⁰ (U⁰ Integer⁰ #f) (Listof⁰ Module-Path-Index⁰)) String⁰))
   (define⁰
    (elem->spec⁰ e⁰)
    (format-list⁰
     (list⁰
      (if⁰ (number?⁰ (car⁰ e⁰)) (number->string⁰ (car⁰ e⁰)) #f)
      (list->string⁰ module-path-index->string⁰ (cdr⁰ e⁰)))
      ))
   (list->string⁰ elem->spec⁰ rqs⁰))
  (:⁰
   syntax-bodies->spec⁰
   (->⁰
    (Listof⁰
     (Pair⁰
      Exact-Positive-Integer⁰
      (Listof⁰ (U⁰ def-syntaxes⁰ seq-for-syntax⁰))))
    String⁰))
  (define⁰
   (syntax-bodies->spec⁰ sbs⁰)
   (:⁰ ds-or-sfs->spec⁰ (->⁰ (U⁰ def-syntaxes⁰ seq-for-syntax⁰) String⁰))
   (define⁰
    (ds-or-sfs->spec⁰ d⁰)
    (cond⁰
     ((def-syntaxes?⁰ d⁰) (format-spec⁰ #f (def-syntaxes->spec⁰ d⁰)))
     ((seq-for-syntax?⁰ d⁰) (format-spec⁰ #f (seq-for-syntax->spec⁰ d⁰)))))
   (:⁰
    elem->spec⁰
    (->⁰
     (Pair⁰
      Exact-Positive-Integer⁰
      (Listof⁰ (U⁰ def-syntaxes⁰ seq-for-syntax⁰)))
     String⁰))
   (define⁰
    (elem->spec⁰ e⁰)
    (format-list⁰
     (list⁰
      (number->string⁰ (car⁰ e⁰))
      (list->string⁰ ds-or-sfs->spec⁰ (cdr⁰ e⁰)))
      ))
   (list->string⁰ elem->spec⁰ sbs⁰))
  (:⁰
   internal-context->string⁰
   (->⁰ (U⁰ #f #t stx⁰ (Vectorof⁰ stx⁰)) (U⁰ Spec⁰ String⁰)))
  (define⁰
   (internal-context->string⁰ ic⁰)
   (match⁰
    ic⁰
    ((?⁰ stx?⁰ ic⁰) (stx->spec⁰ ic⁰))
    ((?⁰ vector?⁰ ic⁰) (listof-zo->string⁰ stx->spec⁰ (vector->list⁰ ic⁰)))
    ((?⁰ boolean?⁰ ic⁰) (boolean->string⁰ ic⁰))))
  (list⁰
   mod
   (lcons⁰ name (name->spec⁰ (mod-name⁰ z⁰)))
   (lcons⁰ srcname (symbol->string⁰ (mod-srcname⁰ z⁰)))
   (lcons⁰ self-modidx (module-path-index->string⁰ (mod-self-modidx⁰ z⁰)))
   (lcons⁰ prefix (prefix->spec⁰ (mod-prefix⁰ z⁰)))
   (lcons⁰ provides (provides->spec⁰ (mod-provides⁰ z⁰)))
   (lcons⁰ requires (requires->spec⁰ (mod-requires⁰ z⁰)))
   (lcons⁰ body (listof-form-or-any->string⁰ (mod-body⁰ z⁰)))
   (lcons⁰ syntax-bodies (syntax-bodies->spec⁰ (mod-syntax-bodies⁰ z⁰)))
   (lcons⁰ unexported (unexported->spec⁰ (mod-unexported⁰ z⁰)))
   (lcons⁰ max-let-depth (number->string⁰ (mod-max-let-depth⁰ z⁰)))
   (lcons⁰ dummy (toplevel->spec⁰ (mod-dummy⁰ z⁰)))
   (lcons⁰ lang-info (lang-info->spec⁰ (mod-lang-info⁰ z⁰)))
   (lcons⁰
    internal-context
    (internal-context->string⁰ (mod-internal-context⁰ z⁰)))
   (lcons⁰ binding-names (format⁰ ~a (mod-binding-names⁰ z⁰)))
   (lcons⁰ flags (list->string⁰ symbol->string⁰ (mod-flags⁰ z⁰)))
   (lcons⁰
    pre-submodules
    (listof-zo->string⁰ mod->spec⁰ (mod-pre-submodules⁰ z⁰)))
   (lcons⁰
    post-submodules
    (listof-zo->string⁰ mod->spec⁰ (mod-post-submodules⁰ z⁰)))))
 (:⁰ provided->spec⁰ (->⁰ provided⁰ Spec⁰))
 (define⁰
  (provided->spec⁰ z⁰)
  (:⁰ mpi-or-f->string⁰ (->⁰ (U⁰ Module-Path-Index⁰ #f) String⁰))
  (define⁰
   (mpi-or-f->string⁰ x⁰)
   (if⁰ (eq?⁰ #f x⁰) #f (module-path-index->string⁰ x⁰)))
  (list⁰
   provided
   (lcons⁰ name (symbol->string⁰ (provided-name⁰ z⁰)))
   (lcons⁰ src (mpi-or-f->string⁰ (provided-src⁰ z⁰)))
   (lcons⁰ src-name (symbol->string⁰ (provided-src-name⁰ z⁰)))
   (lcons⁰ nom-src (any->string⁰ (provided-nom-src⁰ z⁰)))
   (lcons⁰ src-phase (number->string⁰ (provided-src-phase⁰ z⁰)))
   (lcons⁰ protected? (boolean->string⁰ (provided-protected?⁰ z⁰)))))
 (:⁰ lam-name->spec⁰ (->⁰ (U⁰ Symbol⁰ (Vectorof⁰ Any⁰) (List⁰)) String⁰))
 (define⁰
  (lam-name->spec⁰ nm⁰)
  (match⁰
   nm⁰
   ((?⁰ vector?⁰) (any->string⁰ nm⁰))
   ((?⁰ empty?⁰) ())
   ((?⁰ symbol?⁰) (symbol->string⁰ nm⁰))))
 (:⁰ lam->spec⁰ (->⁰ lam⁰ Spec⁰))
 (define⁰
  (lam->spec⁰ z⁰)
  (:⁰ closure-map->spec⁰ (->⁰ (Vectorof⁰ Exact-Nonnegative-Integer⁰) String⁰))
  (define⁰
   (closure-map->spec⁰ cm⁰)
   (list->string⁰ number->string⁰ (vector->list⁰ cm⁰)))
  (:⁰
   toplevel-map->spec⁰
   (->⁰ (U⁰ #f (Setof⁰ Exact-Nonnegative-Integer⁰)) String⁰))
  (define⁰
   (toplevel-map->spec⁰ tm⁰)
   (cond⁰
    ((eq?⁰ #f tm⁰) #f)
    (else⁰
     (format-list⁰
      (for/list⁰
       :⁰
       (Listof⁰ String⁰)
       ((n⁰ :⁰ Exact-Nonnegative-Integer⁰ tm⁰))
       (number->string⁰ n⁰))
       ))))
  (list⁰
   lam
   (lcons⁰ name (lam-name->spec⁰ (lam-name⁰ z⁰)))
   (lcons⁰ flags (list->string⁰ symbol->string⁰ (lam-flags⁰ z⁰)))
   (lcons⁰ num-params (number->string⁰ (lam-num-params⁰ z⁰)))
   (lcons⁰ param-types (list->string⁰ symbol->string⁰ (lam-param-types⁰ z⁰)))
   (lcons⁰ rest? (boolean->string⁰ (lam-rest?⁰ z⁰)))
   (lcons⁰ closure-map (closure-map->spec⁰ (lam-closure-map⁰ z⁰)))
   (lcons⁰
    closure-types
    (list->string⁰ symbol->string⁰ (lam-closure-types⁰ z⁰)))
   (lcons⁰ toplevel-map (toplevel-map->spec⁰ (lam-toplevel-map⁰ z⁰)))
   (lcons⁰ max-let-depth (number->string⁰ (lam-max-let-depth⁰ z⁰)))
   (lcons⁰ body (expr-seq-any->string⁰ (lam-body⁰ z⁰)))))
 (:⁰ closure->spec⁰ (->⁰ closure⁰ Spec⁰))
 (define⁰
  (closure->spec⁰ z⁰)
  (list⁰
   closure
   (lcons⁰ code (lam->spec⁰ (closure-code⁰ z⁰)))
   (lcons⁰ gen-id (symbol->string⁰ (closure-gen-id⁰ z⁰)))))
 (:⁰ case-lam->spec⁰ (->⁰ case-lam⁰ Spec⁰))
 (define⁰
  (case-lam->spec⁰ z⁰)
  (list⁰
   case-lam
   (lcons⁰ name (lam-name->spec⁰ (case-lam-name⁰ z⁰)))
   (lcons⁰
    clauses
    (list->string⁰
     (lambda⁰ ((x⁰ :⁰ (U⁰ lam⁰ closure⁰))) (format-spec⁰ #f (expr->spec⁰ x⁰)))
     (case-lam-clauses⁰ z⁰)))))
 (:⁰ let-one->spec⁰ (->⁰ let-one⁰ Spec⁰))
 (define⁰
  (let-one->spec⁰ z⁰)
  (list⁰
   let-one
   (lcons⁰ rhs (expr-seq-any->string⁰ (let-one-rhs⁰ z⁰)))
   (lcons⁰ body (expr-seq-any->string⁰ (let-one-body⁰ z⁰)))
   (lcons⁰ type (symbol-or-f->string⁰ (let-one-type⁰ z⁰)))
   (lcons⁰ unused? (boolean->string⁰ (let-one-unused?⁰ z⁰)))))
 (:⁰ let-void->spec⁰ (->⁰ let-void⁰ Spec⁰))
 (define⁰
  (let-void->spec⁰ z⁰)
  (list⁰
   let-void
   (lcons⁰ count (number->string⁰ (let-void-count⁰ z⁰)))
   (lcons⁰ boxes (boolean->string⁰ (let-void-boxes?⁰ z⁰)))
   (lcons⁰ body (expr-seq-any->string⁰ (let-void-body⁰ z⁰)))))
 (:⁰ install-value->spec⁰ (->⁰ install-value⁰ Spec⁰))
 (define⁰
  (install-value->spec⁰ z⁰)
  (list⁰
   install-value
   (lcons⁰ count (number->string⁰ (install-value-count⁰ z⁰)))
   (lcons⁰ pos (number->string⁰ (install-value-pos⁰ z⁰)))
   (lcons⁰ boxes? (boolean->string⁰ (install-value-boxes?⁰ z⁰)))
   (lcons⁰ rhs (expr-seq-any->string⁰ (install-value-rhs⁰ z⁰)))
   (lcons⁰ body (expr-seq-any->string⁰ (install-value-body⁰ z⁰)))))
 (:⁰ let-rec->spec⁰ (->⁰ let-rec⁰ Spec⁰))
 (define⁰
  (let-rec->spec⁰ z⁰)
  (list⁰
   let-rec
   (lcons⁰
    procs
    (list->string⁰
     (lambda⁰ ((lm⁰ :⁰ lam⁰)) (format-spec⁰ #f (lam->spec⁰ lm⁰)))
     (let-rec-procs⁰ z⁰)))
   (lcons⁰ body (expr-seq-any->string⁰ (let-rec-body⁰ z⁰)))))
 (:⁰ boxenv->spec⁰ (->⁰ boxenv⁰ Spec⁰))
 (define⁰
  (boxenv->spec⁰ z⁰)
  (list⁰
   boxenv
   (lcons⁰ pos (number->string⁰ (boxenv-pos⁰ z⁰)))
   (lcons⁰ body (expr-seq-any->string⁰ (boxenv-body⁰ z⁰)))))
 (:⁰ localref->spec⁰ (->⁰ localref⁰ Spec⁰))
 (define⁰
  (localref->spec⁰ z⁰)
  (list⁰
   localref
   (lcons⁰ unbox? (boolean->string⁰ (localref-unbox?⁰ z⁰)))
   (lcons⁰ pos (number->string⁰ (localref-pos⁰ z⁰)))
   (lcons⁰ clear? (boolean->string⁰ (localref-clear?⁰ z⁰)))
   (lcons⁰ other-clears? (boolean->string⁰ (localref-other-clears?⁰ z⁰)))
   (lcons⁰ type (symbol-or-f->string⁰ (localref-type⁰ z⁰)))))
 (:⁰ toplevel->spec⁰ (->⁰ toplevel⁰ Spec⁰))
 (define⁰
  (toplevel->spec⁰ z⁰)
  (list⁰
   toplevel
   (lcons⁰ depth (number->string⁰ (toplevel-depth⁰ z⁰)))
   (lcons⁰ pos (number->string⁰ (toplevel-pos⁰ z⁰)))
   (lcons⁰ const? (boolean->string⁰ (toplevel-const?⁰ z⁰)))
   (lcons⁰ ready? (boolean->string⁰ (toplevel-ready?⁰ z⁰)))))
 (:⁰ topsyntax->spec⁰ (->⁰ topsyntax⁰ Spec⁰))
 (define⁰
  (topsyntax->spec⁰ z⁰)
  (list⁰
   topsyntax
   (lcons⁰ depth (number->string⁰ (topsyntax-depth⁰ z⁰)))
   (lcons⁰ pos (number->string⁰ (topsyntax-pos⁰ z⁰)))
   (lcons⁰ midpt (number->string⁰ (topsyntax-midpt⁰ z⁰)))))
 (:⁰ application->spec⁰ (->⁰ application⁰ Spec⁰))
 (define⁰
  (application->spec⁰ z⁰)
  (list⁰
   application
   (lcons⁰ rator (expr-seq-any->string⁰ (application-rator⁰ z⁰)))
   (lcons⁰
    rands
    (list->string⁰ expr-seq-any->string⁰ (application-rands⁰ z⁰)))))
 (:⁰ branch->spec⁰ (->⁰ branch⁰ Spec⁰))
 (define⁰
  (branch->spec⁰ z⁰)
  (list⁰
   branch
   (lcons⁰ test (expr-seq-any->string⁰ (branch-test⁰ z⁰)))
   (lcons⁰ then (expr-seq-any->string⁰ (branch-then⁰ z⁰)))
   (lcons⁰ else (expr-seq-any->string⁰ (branch-else⁰ z⁰)))))
 (:⁰ with-cont-mark->spec⁰ (->⁰ with-cont-mark⁰ Spec⁰))
 (define⁰
  (with-cont-mark->spec⁰ z⁰)
  (list⁰
   with-cont-mark
   (lcons⁰ key (expr-seq-any->string⁰ (with-cont-mark-key⁰ z⁰)))
   (lcons⁰ val (expr-seq-any->string⁰ (with-cont-mark-val⁰ z⁰)))
   (lcons⁰ body (expr-seq-any->string⁰ (with-cont-mark-body⁰ z⁰)))))
 (:⁰ beg0->spec⁰ (->⁰ beg0⁰ Spec⁰))
 (define⁰
  (beg0->spec⁰ z⁰)
  (list⁰
   beg0
   (lcons⁰ seq (list->string⁰ expr-seq-any->string⁰ (beg0-seq⁰ z⁰)))))
 (:⁰ varref->spec⁰ (->⁰ varref⁰ Spec⁰))
 (define⁰
  (varref->spec⁰ z⁰)
  (list⁰
   varref
   (lcons⁰
    toplevel
    (match⁰
     (varref-toplevel⁰ z⁰)
     ((?⁰ toplevel?⁰ tl⁰) (toplevel->spec⁰ tl⁰))
     (#t #t)))
   (lcons⁰
    dummy
    (match⁰
     (varref-dummy⁰ z⁰)
     ((?⁰ toplevel?⁰ dm⁰) (toplevel->spec⁰ dm⁰))
     (#f #f)))))
 (:⁰ assign->spec⁰ (->⁰ assign⁰ Spec⁰))
 (define⁰
  (assign->spec⁰ z⁰)
  (list⁰
   assign
   (lcons⁰ id (toplevel->spec⁰ (assign-id⁰ z⁰)))
   (lcons⁰ rhs (expr-seq-any->string⁰ (assign-rhs⁰ z⁰)))
   (lcons⁰ undef-ok? (boolean->string⁰ (assign-undef-ok?⁰ z⁰)))))
 (:⁰ apply-values->spec⁰ (->⁰ apply-values⁰ Spec⁰))
 (define⁰
  (apply-values->spec⁰ z⁰)
  (list⁰
   apply-values
   (lcons⁰ proc (expr-seq-any->string⁰ (apply-values-proc⁰ z⁰)))
   (lcons⁰ args-expr (expr-seq-any->string⁰ (apply-values-args-expr⁰ z⁰)))))
 (:⁰ with-immed-mark->spec⁰ (->⁰ with-immed-mark⁰ Spec⁰))
 (define⁰
  (with-immed-mark->spec⁰ z⁰)
  (list⁰
   with-immed-mark
   (lcons⁰ key (expr-seq-any->string⁰ (with-immed-mark-key⁰ z⁰)))
   (lcons⁰ def-val (expr-seq-any->string⁰ (with-immed-mark-def-val⁰ z⁰)))
   (lcons⁰ body (expr-seq-any->string⁰ (with-immed-mark-body⁰ z⁰)))))
 (:⁰ primval->spec⁰ (->⁰ primval⁰ Spec⁰))
 (define⁰
  (primval->spec⁰ z⁰)
  (list⁰ primval (lcons⁰ id (number->string⁰ (primval-id⁰ z⁰)))))
 (:⁰ stx-obj->spec⁰ (->⁰ stx-obj⁰ Spec⁰))
 (define⁰
  (stx-obj->spec⁰ so⁰)
  (list⁰
   stx-obj
   (lcons⁰ datum (any->string⁰ (stx-obj-datum⁰ so⁰)))
   (lcons⁰ wrap (wrap->spec⁰ (stx-obj-wrap⁰ so⁰)))
   (lcons⁰ srcloc (srcloc->string⁰ (stx-obj-srcloc⁰ so⁰)))
   (lcons⁰ props (hash->string⁰ (stx-obj-props⁰ so⁰)))
   (lcons⁰ tamper-status (symbol->string⁰ (stx-obj-tamper-status⁰ so⁰)))))
 (:⁰ wrap->spec⁰ (->⁰ wrap⁰ Spec⁰))
 (define⁰
  (wrap->spec⁰ wp⁰)
  (:⁰ ms->string⁰ (->⁰ (List⁰ multi-scope⁰ (U⁰ #f Integer⁰)) String⁰))
  (define⁰
   (ms->string⁰ ms+id⁰)
   (format⁰
    (~a ~a)
    (format-spec⁰ #f (multi-scope->spec⁰ (car⁰ ms+id⁰)))
    (number-or-f->string⁰ (cadr⁰ ms+id⁰))))
  (list⁰
   wrap
   (lcons⁰ shifts (listof-zo->string⁰ module-shift->spec⁰ (wrap-shifts⁰ wp⁰)))
   (lcons⁰
    simple-scopes
    (listof-zo->string⁰ scope->spec⁰ (wrap-simple-scopes⁰ wp⁰)))
   (lcons⁰ multi-scopes (list->string⁰ ms->string⁰ (wrap-multi-scopes⁰ wp⁰)))))
 (:⁰ module-shift->spec⁰ (->⁰ module-shift⁰ Spec⁰))
 (define⁰
  (module-shift->spec⁰ ms⁰)
  (list⁰
   module-shift
   (lcons⁰
    from
    (cond⁰
     ((module-shift-from⁰ ms⁰) =>⁰ module-path-index->string⁰)
     (else⁰ #f)))
   (lcons⁰
    to
    (cond⁰ ((module-shift-to⁰ ms⁰) =>⁰ module-path-index->string⁰) (else⁰ #f)))
   (lcons⁰
    from-inspector-desc
    (symbol-or-f->string⁰ (module-shift-from-inspector-desc⁰ ms⁰)))
   (lcons⁰
    to-inspector-desc
    (symbol-or-f->string⁰ (module-shift-to-inspector-desc⁰ ms⁰)))))
 (:⁰ scope->spec⁰ (->⁰ scope⁰ Spec⁰))
 (define⁰
  (scope->spec⁰ sc⁰)
  (:⁰
   sym+scope+binding->string⁰
   (->⁰ (List⁰ Symbol⁰ (Listof⁰ scope⁰) binding⁰) String⁰))
  (define⁰
   (sym+scope+binding->string⁰ ssbs⁰)
   (format⁰
    (~a ~a ~a)
    (symbol->string⁰ (car⁰ ssbs⁰))
    (listof-zo->string⁰ scope->spec⁰ (cadr⁰ ssbs⁰))
    (format-spec⁰ #f (binding->spec⁰ (caddr⁰ ssbs⁰)))))
  (:⁰
   scope+all-from-module->string⁰
   (->⁰ (List⁰ (Listof⁰ scope⁰) all-from-module⁰) String⁰))
  (define⁰
   (scope+all-from-module->string⁰ bbs⁰)
   (format⁰
    (~a ~a)
    (listof-zo->string⁰ scope->spec⁰ (car⁰ bbs⁰))
    (format-spec⁰ #f (all-from-module->spec⁰ (cadr⁰ bbs⁰)))))
  (list⁰
   scope
   (lcons⁰
    name
    (let⁰
     ((name⁰ :⁰ (U⁰ (quote⁰ root⁰) Integer⁰) (scope-name⁰ sc⁰)))
     (cond⁰
      ((eq?⁰ (quote⁰ root⁰) name⁰) root)
      (else⁰ (number->string⁰ name⁰)))))
   (lcons⁰ kind (symbol->string⁰ (scope-kind⁰ sc⁰)))
   (lcons⁰
    bindings
    (list->string⁰ sym+scope+binding->string⁰ (scope-bindings⁰ sc⁰)))
   (lcons⁰
    bulk-bindings
    (list->string⁰ scope+all-from-module->string⁰ (scope-bulk-bindings⁰ sc⁰)))
   (lcons⁰
    multi-owner
    (cond⁰ ((scope-multi-owner⁰ sc⁰) =>⁰ multi-scope->spec⁰) (else⁰ #f)))))
 (:⁰ multi-scope->spec⁰ (->⁰ multi-scope⁰ Spec⁰))
 (define⁰
  (multi-scope->spec⁰ ms⁰)
  (:⁰ sc->string⁰ (->⁰ (List⁰ (U⁰ Integer⁰ #f) scope⁰) String⁰))
  (define⁰
   (sc->string⁰ id+scope⁰)
   (format⁰
    (~a ~a)
    (number-or-f->string⁰ (car⁰ id+scope⁰))
    (format-spec⁰ #f (scope->spec⁰ (cadr⁰ id+scope⁰)))))
  (list⁰
   multi-scope
   (lcons⁰ name (number->string⁰ (multi-scope-name⁰ ms⁰)))
   (lcons⁰ src-name (any->string⁰ (multi-scope-src-name⁰ ms⁰)))
   (lcons⁰ scopes (list->string⁰ sc->string⁰ (multi-scope-scopes⁰ ms⁰)))))
 (:⁰ module-binding->spec⁰ (->⁰ module-binding⁰ Spec⁰))
 (define⁰
  (module-binding->spec⁰ mb⁰)
  (list⁰
   module-binding
   (lcons⁰ encoded (any->string⁰ (module-binding-encoded⁰ mb⁰)))))
 (:⁰ decoded-module-binding->spec⁰ (->⁰ decoded-module-binding⁰ Spec⁰))
 (define⁰
  (decoded-module-binding->spec⁰ dmb⁰)
  (list⁰
   decoded-module-binding
   (lcons⁰
    path
    (cond⁰
     ((decoded-module-binding-path⁰ dmb⁰) =>⁰ module-path-index->string⁰)
     (else⁰ #f)))
   (lcons⁰ name (symbol->string⁰ (decoded-module-binding-name⁰ dmb⁰)))
   (lcons⁰ phase (number->string⁰ (decoded-module-binding-phase⁰ dmb⁰)))
   (lcons⁰
    nominal-path
    (cond⁰
     ((decoded-module-binding-nominal-path⁰ dmb⁰)
      =>⁰
      module-path-index->string⁰)
     (else⁰ #f)))
   (lcons⁰
    nominal-export-name
    (symbol->string⁰ (decoded-module-binding-nominal-export-name⁰ dmb⁰)))
   (lcons⁰
    nominal-phase
    (number-or-f->string⁰ (decoded-module-binding-nominal-phase⁰ dmb⁰)))
   (lcons⁰
    import-phase
    (number-or-f->string⁰ (decoded-module-binding-import-phase⁰ dmb⁰)))
   (lcons⁰
    inspector-desc
    (symbol-or-f->string⁰ (decoded-module-binding-inspector-desc⁰ dmb⁰)))))
 (:⁰ local-binding->spec⁰ (->⁰ local-binding⁰ Spec⁰))
 (define⁰
  (local-binding->spec⁰ lb⁰)
  (list⁰
   local-binding
   (lcons⁰ name (symbol->string⁰ (local-binding-name⁰ lb⁰)))))
 (:⁰ free-id=?-binding->spec⁰ (->⁰ free-id=?-binding⁰ Spec⁰))
 (define⁰
  (free-id=?-binding->spec⁰ fib⁰)
  (list⁰
   free-id=?-binding
   (lcons⁰ base (binding->spec⁰ (free-id=?-binding-base⁰ fib⁰)))
   (lcons⁰ id (stx-obj->spec⁰ (free-id=?-binding-id⁰ fib⁰)))
   (lcons⁰ phase (number-or-f->string⁰ (free-id=?-binding-phase⁰ fib⁰)))))
 (:⁰ function-shape->spec⁰ (->⁰ function-shape⁰ String⁰))
 (define⁰
  (function-shape->spec⁰ fs⁰)
  (format-list⁰
   (list⁰
    function-shape
    (format⁰ arity : ~a (function-shape-arity⁰ fs⁰))
    (format⁰ preserves-marks? : ~a (function-shape-preserves-marks?⁰ fs⁰)))
    ))
 (:⁰ struct-shape->spec⁰ (->⁰ struct-shape⁰ String⁰))
 (define⁰
  (struct-shape->spec⁰ ss⁰)
  (cond⁰
   ((struct-type-shape?⁰ ss⁰) (struct-type-shape->spec⁰ ss⁰))
   ((constructor-shape?⁰ ss⁰) (constructor-shape->spec⁰ ss⁰))
   ((predicate-shape?⁰ ss⁰) (predicate-shape->spec⁰ ss⁰))
   ((accessor-shape?⁰ ss⁰) (accessor-shape->spec⁰ ss⁰))
   ((mutator-shape?⁰ ss⁰) (mutator-shape->spec⁰ ss⁰))
   ((struct-other-shape?⁰ ss⁰) (struct-other-shape->spec⁰ ss⁰))
   (else⁰ (error⁰ (format⁰ unknown struct shape ~a ss⁰)))))
 (:⁰ struct-type-shape->spec⁰ (->⁰ struct-type-shape⁰ String⁰))
 (define⁰
  (struct-type-shape->spec⁰ sts⁰)
  (format-list⁰
   (list⁰
    struct-type-shape
    (format⁰ field-count : ~a (struct-type-shape-field-count⁰ sts⁰)))
    ))
 (:⁰ constructor-shape->spec⁰ (->⁰ constructor-shape⁰ String⁰))
 (define⁰
  (constructor-shape->spec⁰ cs⁰)
  (format-list⁰
   (list⁰
    constructor-shape
    (format⁰ arity : ~a (constructor-shape-arity⁰ cs⁰)))
    ))
 (:⁰ predicate-shape->spec⁰ (->⁰ predicate-shape⁰ String⁰))
 (define⁰ (predicate-shape->spec⁰ ps⁰) (format-list⁰ (list⁰ predicate-shape)))
 (:⁰ accessor-shape->spec⁰ (->⁰ accessor-shape⁰ String⁰))
 (define⁰
  (accessor-shape->spec⁰ sts⁰)
  (format-list⁰
   (list⁰
    accessor-shape
    (format⁰ field-count : ~a (accessor-shape-field-count⁰ sts⁰)))
    ))
 (:⁰ mutator-shape->spec⁰ (->⁰ mutator-shape⁰ String⁰))
 (define⁰
  (mutator-shape->spec⁰ sts⁰)
  (format-list⁰
   (list⁰
    mutator-shape
    (format⁰ field-count : ~a (mutator-shape-field-count⁰ sts⁰)))
    ))
 (:⁰ struct-other-shape->spec⁰ (->⁰ struct-other-shape⁰ String⁰))
 (define⁰
  (struct-other-shape->spec⁰ ps⁰)
  (format-list⁰ (list⁰ struct-other-shape)))
 (:⁰ any->string⁰ (->⁰ Any⁰ String⁰))
 (define⁰ (any->string⁰ z⁰) (format⁰ ~a z⁰))
 (:⁰ boolean->string⁰ (->⁰ Boolean⁰ String⁰))
 (define⁰ (boolean->string⁰ b⁰) (any->string⁰ b⁰))
 (:⁰ expr-seq-any->string⁰ (->⁰ (U⁰ expr⁰ seq⁰ Any⁰) String⁰))
 (define⁰
  (expr-seq-any->string⁰ z⁰)
  (cond⁰
   ((expr?⁰ z⁰) (format-spec⁰ #f (expr->spec⁰ z⁰)))
   ((seq?⁰ z⁰) (format-spec⁰ #f (seq->spec⁰ z⁰)))
   (else⁰ (any->string⁰ z⁰))))
 (:⁰ form-or-any->string⁰ (->⁰ (U⁰ form⁰ Any⁰) String⁰))
 (define⁰
  (form-or-any->string⁰ fm⁰)
  (cond⁰
   ((form?⁰ fm⁰) (format-spec⁰ #f (form->spec⁰ fm⁰)))
   (else⁰ (any->string⁰ fm⁰))))
 (:⁰ format-list⁰ (->*⁰ ((Listof⁰ String⁰)) (String⁰) String⁰))
 (define⁰ (format-list⁰ xs⁰ (sep⁰ 
)) (string-join⁰ xs⁰ sep⁰))
 (:⁰ format-spec⁰ (->⁰ Boolean⁰ Spec⁰ String⁰))
 (define⁰
  (format-spec⁰ deep?⁰ struct-spec⁰)
  (:⁰ fields⁰ (Listof⁰ (Pair⁰ String⁰ (->⁰ (U⁰ Spec⁰ String⁰)))))
  (define⁰ fields⁰ (cdr⁰ struct-spec⁰))
  (:⁰ title⁰ String⁰)
  (define⁰ title⁰ (format⁰ <struct:~a> (car⁰ struct-spec⁰)))
  (:⁰ field-name-lengths⁰ (Listof⁰ Index⁰))
  (define⁰
   field-name-lengths⁰
   (for/list⁰ ((fd⁰ fields⁰)) (string-length⁰ (car⁰ fd⁰))))
  (:⁰ w⁰ Nonnegative-Fixnum⁰)
  (define⁰ w⁰ (if⁰ (empty?⁰ fields⁰) 0 (apply⁰ max⁰ field-name-lengths⁰)))
  (if⁰
   (not⁰ deep?⁰)
   title⁰
   (format-list⁰
    (cons⁰
     title⁰
     (for/list⁰
      :⁰
      (Listof⁰ String⁰)
      ((fd⁰ :⁰ (Pair⁰ String⁰ (->⁰ (U⁰ Spec⁰ String⁰))) fields⁰))
      (:⁰ forced⁰ (U⁰ String⁰ Spec⁰))
      (define⁰ forced⁰ ((cdr⁰ fd⁰)))
      (:⁰ rest⁰ String⁰)
      (define⁰
       rest⁰
       (if⁰ (string?⁰ forced⁰) forced⁰ (format-spec⁰ #f forced⁰)))
      (format⁰   ~a : ~a (pad⁰ (car⁰ fd⁰) w⁰) rest⁰))))))
 (:⁰ list->string⁰ (All⁰ (A⁰) (->⁰ (->⁰ A⁰ String⁰) (Listof⁰ A⁰) String⁰)))
 (define⁰
  (list->string⁰ f⁰ xs⁰)
  (format⁰
   [~a]
   (format-list⁰ (for/list⁰ :⁰ (Listof⁰ String⁰) ((x⁰ :⁰ A⁰ xs⁰)) (f⁰ x⁰))  )))
 (:⁰ listof-form-or-any->string⁰ (->⁰ (Listof⁰ (U⁰ form⁰ Any⁰)) String⁰))
 (define⁰
  (listof-form-or-any->string⁰ xs⁰)
  (list->string⁰ form-or-any->string⁰ xs⁰))
 (:⁰ listof-zo->string⁰ (All⁰ (A⁰) (->⁰ (->⁰ A⁰ Spec⁰) (Listof⁰ A⁰) String⁰)))
 (define⁰
  (listof-zo->string⁰ z->spec⁰ zs⁰)
  (cond⁰
   ((empty?⁰ zs⁰) [])
   (else⁰
    (format⁰ ~a[~a] (format-spec⁰ #f (z->spec⁰ (car⁰ zs⁰))) (length⁰ zs⁰)))))
 (:⁰ module-path-index->string⁰ (->⁰ Module-Path-Index⁰ String⁰))
 (define⁰ (module-path-index->string⁰ mpi⁰) (any->string⁰ mpi⁰))
 (:⁰ module-path->spec⁰ (->⁰ Module-Path⁰ String⁰))
 (define⁰ (module-path->spec⁰ mp⁰) (any->string⁰ mp⁰))
 (:⁰ number-or-f->string⁰ (->⁰ (U⁰ Number⁰ #f) String⁰))
 (define⁰
  (number-or-f->string⁰ nf⁰)
  (if⁰ (eq?⁰ #f nf⁰) #f (number->string⁰ nf⁰)))
 (:⁰ symbol-or-f->string⁰ (->⁰ (U⁰ Symbol⁰ #f) String⁰))
 (define⁰
  (symbol-or-f->string⁰ sf⁰)
  (if⁰ (eq?⁰ #f sf⁰) #f (symbol->string⁰ sf⁰)))
 (:⁰ hash->string⁰ (All⁰ (A⁰ B⁰) (->⁰ (HashTable⁰ A⁰ B⁰) String⁰)))
 (define⁰ (hash->string⁰ h⁰) (format⁰ ~a h⁰))
 (:⁰ toplevel-or-any->string⁰ (->⁰ (U⁰ toplevel⁰ Any⁰) String⁰))
 (define⁰
  (toplevel-or-any->string⁰ tl⁰)
  (cond⁰
   ((toplevel?⁰ tl⁰) (format-spec⁰ #f (toplevel->spec⁰ tl⁰)))
   (else⁰ (any->string⁰ tl⁰))))
 (:⁰ pad⁰ (->*⁰ (String⁰ Natural⁰) (Char⁰) String⁰))
 (define⁰
  (pad⁰ str⁰ w⁰ (c⁰  ))
  (:⁰ l⁰ Index⁰)
  (define⁰ l⁰ (string-length⁰ str⁰))
  (cond⁰
   ((<⁰ l⁰ w⁰) (format⁰ ~a~a str⁰ (make-string⁰ (-⁰ w⁰ l⁰) c⁰)))
   (else⁰ str⁰)))).
scv-cr: Working on /home/camoy/wrk/scv-cr/test/zordoz/zo-transition.rkt.
scv-cr: Raw syntax is '(module zo-transition typed/racket/base
   (#%module-begin
    (provide zo-transition)
    (require racket/match
             (only-in racket/list empty? empty)
             "typed-zo-structs.rkt")
    (: zo-transition (-> zo String (values (U zo (Listof zo)) Boolean)))
    (define (zo-transition z field-name)
      (match
       (try-transition z field-name)
       ((? zo? nxt) (values nxt #t))
       ((? list? nxt)
        (match (filter zo? nxt) ('() (values z #f)) (zs (values zs #t))))
       (_ (values z #f))))
    (: try-transition (-> zo String (U zo (Listof zo) #f)))
    (define (try-transition z str)
      (match
       z
       ((? compilation-top?) (compilation-top-> z str))
       ((? prefix?) (prefix-> z str))
       ((? global-bucket?) (global-bucket-> z str))
       ((? module-variable?) (module-variable-> z str))
       ((? stx?) (stx-> z str))
       ((? form?) (form-> z str))
       ((? stx-obj?) (stx-obj-> z str))
       ((? wrap?) (wrap-> z str))
       ((? module-shift?) (module-shift-> z str))
       ((? scope?) (scope-> z str))
       ((? multi-scope?) (multi-scope-> z str))
       ((? binding?) (binding-> z str))
       ((? provided?) (provided-> z str))
       ((? all-from-module?) (all-from-module-> z str))
       (x #f)))
    (: form-> (-> zo String (U zo (Listof zo) #f)))
    (define (form-> z str)
      (match
       z
       ((? def-values?) (def-values-> z str))
       ((? def-syntaxes?) (def-syntaxes-> z str))
       ((? seq-for-syntax?) (seq-for-syntax-> z str))
       ((? req?) (req-> z str))
       ((? seq?) (seq-> z str))
       ((? splice?) (splice-> z str))
       ((? inline-variant?) (inline-variant-> z str))
       ((? mod?) (mod-> z str))
       ((? expr?) (expr-> z str))
       (x #f)))
    (: expr-> (-> zo String (U zo (Listof zo) #f)))
    (define (expr-> z str)
      (match
       z
       ((? lam?) (lam-> z str))
       ((? closure?) (closure-> z str))
       ((? case-lam?) (case-lam-> z str))
       ((? let-one?) (let-one-> z str))
       ((? let-void?) (let-void-> z str))
       ((? install-value?) (install-value-> z str))
       ((? let-rec?) (let-rec-> z str))
       ((? boxenv?) (boxenv-> z str))
       ((? localref?) (localref-> z str))
       ((? toplevel?) (toplevel-> z str))
       ((? topsyntax?) (topsyntax-> z str))
       ((? application?) (application-> z str))
       ((? branch?) (branch-> z str))
       ((? with-cont-mark?) (with-cont-mark-> z str))
       ((? beg0?) (beg0-> z str))
       ((? varref?) (varref-> z str))
       ((? assign?) (assign-> z str))
       ((? apply-values?) (apply-values-> z str))
       ((? with-immed-mark?) (with-immed-mark-> z str))
       ((? primval?) (primval-> z str))
       (x #f)))
    (: binding-> (-> binding String (U zo (Listof zo) #f)))
    (define (binding-> z str)
      (match
       z
       ((? module-binding?) (module-binding-> z str))
       ((? decoded-module-binding?) (decoded-module-binding-> z str))
       ((? local-binding?) (local-binding-> z str))
       ((? free-id=?-binding?) (free-id=?-binding-> z str))
       (x #f)))
    (: compilation-top-> (-> compilation-top String (U zo (Listof zo) #f)))
    (define (compilation-top-> z field-name)
      (match
       field-name
       ("prefix" (compilation-top-prefix z))
       ("code"
        (: res (U form Any))
        (define res (compilation-top-code z))
        (if (form? res) res #f))
       (_ #f)))
    (: prefix-> (-> prefix String (U zo (Listof zo) #f)))
    (define (prefix-> z field-name)
      (define-predicate gb-or-mv? (U global-bucket module-variable))
      (match
       field-name
       ("toplevels" (filter gb-or-mv? (prefix-toplevels z)))
       ("stxs" (for/list : (Listof zo) ((sx (prefix-stxs z)) #:when sx) sx))
       (_ #f)))
    (: global-bucket-> (-> global-bucket String (U zo (Listof zo) #f)))
    (define (global-bucket-> z field-name) #f)
    (: module-variable-> (-> module-variable String (U zo (Listof zo) #f)))
    (define (module-variable-> z field-name) #f)
    (: stx-> (-> stx String (U zo (Listof zo) #f)))
    (define (stx-> z field-name)
      (match field-name ("content" (stx-content z)) (_ #f)))
    (: all-from-module-> (-> all-from-module String (U zo (Listof zo) #f)))
    (define (all-from-module-> z field-name) #f)
    (: def-values-> (-> def-values String (U zo (Listof zo) #f)))
    (define (def-values-> z field-name)
      (match
       field-name
       ("ids" (filter toplevel? (def-values-ids z)))
       ("rhs"
        (match
         (def-values-rhs z)
         ((or (? expr? rhs) (? seq? rhs) (? inline-variant? rhs)) rhs)
         (_ #f)))
       (_ #f)))
    (: def-syntaxes-> (-> def-syntaxes String (U zo (Listof zo) #f)))
    (define (def-syntaxes-> z field-name)
      (match
       field-name
       ("ids" (filter toplevel? (def-syntaxes-ids z)))
       ("rhs"
        (match
         (def-syntaxes-rhs z)
         ((or (? expr? rhs) (? seq? rhs)) rhs)
         (_ #f)))
       ("prefix" (def-syntaxes-prefix z))
       ("dummy" (match (def-syntaxes-dummy z) ((? toplevel? dm) dm) (_ #f)))
       (_ #f)))
    (: seq-for-syntax-> (-> seq-for-syntax String (U zo (Listof zo) #f)))
    (define (seq-for-syntax-> z field-name)
      (match
       field-name
       ("forms" (filter form? (seq-for-syntax-forms z)))
       ("prefix" (seq-for-syntax-prefix z))
       ("dummy" (match (seq-for-syntax-dummy z) ((? toplevel? dm) dm) (_ #f)))
       (_ #f)))
    (: req-> (-> req String (U zo (Listof zo) #f)))
    (define (req-> z field-name)
      (match field-name ("reqs" (req-reqs z)) ("dummy" (req-dummy z)) (_ #f)))
    (: seq-> (-> seq String (U zo (Listof zo) #f)))
    (define (seq-> z field-name)
      (match field-name ("forms" (filter form? (seq-forms z))) (_ #f)))
    (: splice-> (-> splice String (U zo (Listof zo) #f)))
    (define (splice-> z field-name)
      (match field-name ("forms" (filter form? (splice-forms z))) (_ #f)))
    (: inline-variant-> (-> inline-variant String (U zo (Listof zo) #f)))
    (define (inline-variant-> z field-name)
      (match
       field-name
       ("direct" (inline-variant-direct z))
       ("inline" (inline-variant-inline z))
       (_ #f)))
    (: mod-> (-> mod String (U zo (Listof zo) #f)))
    (define (mod-> z field-name)
      (:
       get-provided
       (->
        (Listof (List (U Integer #f) (Listof provided) (Listof provided)))
        (Listof provided)))
      (define (get-provided pds)
        (cond
         ((empty? pds) empty)
         (else (append (cadar pds) (caddar pds) (get-provided (cdr pds))))))
      (:
       get-syntaxes
       (->
        (Listof
         (Pair
          Exact-Positive-Integer
          (Listof (U def-syntaxes seq-for-syntax))))
        (Listof (U def-syntaxes seq-for-syntax))))
      (define (get-syntaxes sxs)
        (cond
         ((empty? sxs) empty)
         (else (append (cdar sxs) (get-syntaxes (cdr sxs))))))
      (match
       field-name
       ("prefix" (mod-prefix z))
       ("provides" (get-provided (mod-provides z)))
       ("body" (filter form? (mod-body z)))
       ("syntax-bodies" (get-syntaxes (mod-syntax-bodies z)))
       ("dummy" (mod-dummy z))
       ("internal-context"
        (match
         (mod-internal-context z)
         ((? stx? ic) ic)
         ((? vector? ic) (vector->list ic))
         (_ #f)))
       ("pre-submodules" (mod-pre-submodules z))
       ("post-submodules" (mod-post-submodules z))
       (_ #f)))
    (: provided-> (-> provided String (U zo (Listof zo) #f)))
    (define (provided-> z field-name) #f)
    (: lam-> (-> lam String (U zo (Listof zo) #f)))
    (define (lam-> z field-name)
      (match
       field-name
       ("body" (match (lam-body z) ((? expr-or-seq? bd) bd) (_x #f)))
       (_ #f)))
    (: closure-> (-> closure String (U zo (Listof zo) #f)))
    (define (closure-> z field-name)
      (match field-name ("code" (closure-code z)) (_ #f)))
    (: case-lam-> (-> case-lam String (U zo (Listof zo) #f)))
    (define (case-lam-> z field-name)
      (match field-name ("clauses" (case-lam-clauses z)) (_ #f)))
    (: let-one-> (-> let-one String (U zo (Listof zo) #f)))
    (define (let-one-> z field-name)
      (match
       field-name
       ("rhs" (match (let-one-rhs z) ((? expr-or-seq? rhs) rhs) (_ #f)))
       ("body" (match (let-one-body z) ((? expr-or-seq? body) body) (_ #f)))
       (_ #f)))
    (: let-void-> (-> let-void String (U zo (Listof zo) #f)))
    (define (let-void-> z field-name)
      (match
       field-name
       ("body" (match (let-void-body z) ((? expr-or-seq? body) body) (_ #f)))
       (_ #f)))
    (: install-value-> (-> install-value String (U zo (Listof zo) #f)))
    (define (install-value-> z field-name)
      (match
       field-name
       ("rhs" (match (install-value-rhs z) ((? expr-or-seq? rhs) rhs) (_ #f)))
       ("body"
        (match (install-value-body z) ((? expr-or-seq? body) body) (_ #f)))
       (_ #f)))
    (: let-rec-> (-> let-rec String (U zo (Listof zo) #f)))
    (define (let-rec-> z field-name)
      (match
       field-name
       ("procs" (let-rec-procs z))
       ("body" (match (let-rec-body z) ((? expr-or-seq? body) body) (_ #f)))
       (_ #f)))
    (: boxenv-> (-> boxenv String (U zo (Listof zo) #f)))
    (define (boxenv-> z field-name)
      (match
       field-name
       ("body" (match (boxenv-body z) ((? expr-or-seq? body) body) (_ #f)))
       (_ #f)))
    (: localref-> (-> localref String (U zo (Listof zo) #f)))
    (define (localref-> z field-name) #f)
    (: toplevel-> (-> toplevel String (U zo (Listof zo) #f)))
    (define (toplevel-> z field-name) #f)
    (: topsyntax-> (-> topsyntax String (U zo (Listof zo) #f)))
    (define (topsyntax-> z field-name) #f)
    (: application-> (-> application String (U zo (Listof zo) #f)))
    (define (application-> z field-name)
      (match
       field-name
       ("rator"
        (match (application-rator z) ((? expr-or-seq? rator) rator) (_ #f)))
       ("rands" (filter expr-or-seq? (application-rands z)))
       (_ #f)))
    (: branch-> (-> branch String (U zo (Listof zo) #f)))
    (define (branch-> z field-name)
      (match
       field-name
       ("test" (match (branch-test z) ((? expr-or-seq? test) test) (_ #f)))
       ("then" (match (branch-then z) ((? expr-or-seq? then) then) (_ #f)))
       ("else" (match (branch-else z) ((? expr-or-seq? el) el) (_ #f)))
       (_ #f)))
    (: with-cont-mark-> (-> with-cont-mark String (U zo (Listof zo) #f)))
    (define (with-cont-mark-> z field-name)
      (match
       field-name
       ("key" (match (with-cont-mark-key z) ((? expr-or-seq? key) key) (_ #f)))
       ("val" (match (with-cont-mark-val z) ((? expr-or-seq? val) val) (_ #f)))
       ("body"
        (match (with-cont-mark-body z) ((? expr-or-seq? body) body) (_ #f)))
       (_ #f)))
    (: beg0-> (-> beg0 String (U zo (Listof zo) #f)))
    (define (beg0-> z field-name)
      (match field-name ("seq" (filter expr-or-seq? (beg0-seq z))) (_ #f)))
    (: varref-> (-> varref String (U zo (Listof zo) #f)))
    (define (varref-> z field-name)
      (match
       field-name
       ("toplevel" (match (varref-toplevel z) ((? toplevel? tl) tl) (_ #f)))
       ("dummy" (match (varref-dummy z) ((? toplevel? dm) dm) (_ #f)))
       (_ #f)))
    (: assign-> (-> assign String (U zo (Listof zo) #f)))
    (define (assign-> z field-name)
      (match
       field-name
       ("id" (assign-id z))
       ("rhs" (match (assign-rhs z) ((? expr-or-seq? rhs) rhs) (_ #f)))
       (_ #f)))
    (: apply-values-> (-> apply-values String (U zo (Listof zo) #f)))
    (define (apply-values-> z field-name)
      (match
       field-name
       ("proc"
        (match (apply-values-proc z) ((? expr-or-seq? proc) proc) (_ #f)))
       ("args-expr"
        (match
         (apply-values-args-expr z)
         ((? expr-or-seq? args-expr) args-expr)
         (_ #f)))
       (_ #f)))
    (: with-immed-mark-> (-> with-immed-mark String (U zo (Listof zo) #f)))
    (define (with-immed-mark-> z field-name)
      (match
       field-name
       ("key"
        (match (with-immed-mark-key z) ((? expr-or-seq? proc) proc) (_ #f)))
       ("def-val"
        (match
         (with-immed-mark-def-val z)
         ((? expr-or-seq? args-expr) args-expr)
         (_ #f)))
       ("body"
        (match (with-immed-mark-body z) ((? expr-or-seq? proc) proc) (_ #f)))
       (_ #f)))
    (: primval-> (-> primval String (U zo (Listof zo) #f)))
    (define (primval-> z field-name) #f)
    (: stx-obj-> (-> stx-obj String (U zo (Listof zo) #f)))
    (define (stx-obj-> z field-name)
      (match field-name ("wrap" (stx-obj-wrap z)) (_ #f)))
    (: wrap-> (-> wrap String (U zo (Listof zo) #f)))
    (define (wrap-> z field-name)
      (match
       field-name
       ("shifts" (wrap-shifts z))
       ("simple-scopes" (wrap-simple-scopes z))
       ("multi-scopes"
        (for/list
         :
         (Listof zo)
         ((ms : (List multi-scope (U #f Integer)) (wrap-multi-scopes z)))
         (car ms)))
       (_ #f)))
    (: module-shift-> (-> module-shift String (U zo (Listof zo) #f)))
    (define (module-shift-> z field-name) (match field-name (_ #f)))
    (: scope-> (-> scope String (U zo (Listof zo) #f)))
    (define (scope-> z field-name)
      (:
       get-bindings
       (-> (Listof (List Symbol (Listof scope) binding)) (Listof zo)))
      (define (get-bindings bs)
        (cond
         ((empty? bs) '())
         (else (append (cadar bs) (cddar bs) (get-bindings (cdr bs))))))
      (:
       get-bulk-bindings
       (-> (Listof (List (Listof scope) all-from-module)) (Listof zo)))
      (define (get-bulk-bindings bbs)
        (cond
         ((empty? bbs) '())
         (else (append (caar bbs) (cdar bbs) (get-bulk-bindings (cdr bbs))))))
      (match
       field-name
       ("bindings" (get-bindings (scope-bindings z)))
       ("bulk-bindings" (get-bulk-bindings (scope-bulk-bindings z)))
       ("multi-owner" (scope-multi-owner z))
       (_ #f)))
    (: multi-scope-> (-> multi-scope String (U zo (Listof zo) #f)))
    (define (multi-scope-> z field-name)
      (match
       field-name
       ("scopes"
        (for/list
         :
         (Listof zo)
         ((mss : (List (U #f Integer) scope) (multi-scope-scopes z)))
         (cadr mss)))
       (_ #f)))
    (: module-binding-> (-> module-binding String (U zo (Listof zo) #f)))
    (define (module-binding-> z field-name) (match field-name (_ #f)))
    (:
     decoded-module-binding->
     (-> decoded-module-binding String (U zo (Listof zo) #f)))
    (define (decoded-module-binding-> z field-name) (match field-name (_ #f)))
    (: local-binding-> (-> local-binding String (U zo (Listof zo) #f)))
    (define (local-binding-> z field-name) #f)
    (: free-id=?-binding-> (-> free-id=?-binding String (U zo (Listof zo) #f)))
    (define (free-id=?-binding-> z field-name)
      (match
       field-name
       ("base" (free-id=?-binding-base z))
       ("id" (free-id=?-binding-id z))
       (_ #f)))
    (define-predicate expr-or-seq? (U expr seq)))).
scv-cr: Elaborated syntax is (module⁰
 zo-transition⁰
 scv-cr/private/lang/scv/base⁰
 (begin⁰
  (module⁰ #%type-decl⁰ racket/base⁰)
  (require⁰ (for-syntax⁰ racket/base⁰))
  (define-syntax⁰ scv-cr?⁰ #t))
 (begin⁰
  (provide⁰ (contract-out⁰ (zo-transition⁰ generated-contract957⁰)))
  (provide⁰ g969⁰ g968⁰ g965⁰ generated-contract957⁰ g966⁰ g970⁰ g964⁰ g967⁰)
  (require⁰
   (only-in⁰
    (combine-in⁰
     (lib⁰ racket/contract/base.rkt)
     (lib⁰ racket/base.rkt)
     (submod⁰ typed-zo-structs.rkt #%type-decl⁰ ..)
     (lib⁰ racket/contract.rkt))))
  (define⁰ g964⁰ (lambda⁴⁶˙˙⁴⁷ (x⁴⁶˙˙⁴⁷) (zo?⁶²˙˙⁶⁹ x⁴⁶˙˙⁴⁷)))
  (define⁰ g965⁰ string?¹⁰˙˙¹¹)
  (define⁰ g966⁰ (listof⁰ g964⁰))
  (define⁰ g967⁰ (or/c⁰ g966⁰ g964⁰))
  (define⁰ g968⁰ (quote⁴⁶˙˙⁴⁷ #t))
  (define⁰ g969⁰ (quote⁴⁶˙˙⁴⁷ #f))
  (define⁰ g970⁰ (or/c⁰ g968⁰ g969⁰))
  (define⁰
   generated-contract957⁰
   (->⁰ g964⁰ g965⁰ (values⁵⁸˙˙⁵⁹ g967⁰ g970⁰))))
 (begin⁰
  (module⁰
   require/contracts⁰
   scv-cr/private/lang/scv/base⁰
   (begin⁰
    (module⁰ #%type-decl⁰ racket/base⁰)
    (require⁰ (for-syntax⁰ racket/base⁰))
    (define-syntax⁰ scv-cr?⁰ #t))
   (require⁰)
   (begin⁰
    (provide⁰ (contract-out⁰))
    (provide⁰ g962⁰ l1⁰ g959⁰ g958⁰ l233⁰ g963⁰ g960⁰ g961⁰)
    (require⁰
     (only-in⁰
      (combine-in⁰
       (lib⁰ racket/contract/base.rkt)
       (lib⁰ racket/base.rkt)
       (submod⁰ typed-zo-structs.rkt #%type-decl⁰ ..))))
    (define⁰ g958⁰ (lambda⁴⁶˙˙⁴⁷ (x⁴⁶˙˙⁴⁷) (module-variable?⁶²˙˙⁶⁹ x⁴⁶˙˙⁴⁷)))
    (define⁰ g959⁰ (lambda⁴⁶˙˙⁴⁷ (x⁴⁶˙˙⁴⁷) (global-bucket?⁶²˙˙⁶⁹ x⁴⁶˙˙⁴⁷)))
    (define⁰ g960⁰ (or/c⁰ g958⁰ g959⁰))
    (define⁰ g961⁰ (lambda⁴⁶˙˙⁴⁷ (x⁴⁶˙˙⁴⁷) (seq?⁶²˙˙⁶⁹ x⁴⁶˙˙⁴⁷)))
    (define⁰ g962⁰ (lambda⁴⁶˙˙⁴⁷ (x⁴⁶˙˙⁴⁷) (expr?⁶²˙˙⁶⁹ x⁴⁶˙˙⁴⁷)))
    (define⁰ g963⁰ (or/c⁰ g961⁰ g962⁰))
    (define⁰ l1⁰ g963⁰)
    (define⁰ l233⁰ g960⁰)))
  (require⁰ (quote⁰ require/contracts⁰))
  (begin⁰
   (require⁰ (only-in⁰ (quote⁰˙˙¹ require/contracts⁰˙˙¹)))
   (define-values⁰ () (values⁰))))
 (scv-ignore:provide⁰)
 (require⁰
  racket/match⁰
  (only-in⁰ racket/list⁰ empty?⁰ empty⁰)
  typed-zo-structs.rkt)
 (:⁰
  zo-transition⁰
  (->⁰ zo⁰ String⁰ (values⁰ (U⁰ zo⁰ (Listof⁰ zo⁰)) Boolean⁰)))
 (define⁰
  (zo-transition⁰ z⁰ field-name⁰)
  (match⁰
   (try-transition⁰ z⁰ field-name⁰)
   ((?⁰ zo?⁰ nxt⁰) (values⁰ nxt⁰ #t))
   ((?⁰ list?⁰ nxt⁰)
    (match⁰
     (filter⁰ zo?⁰ nxt⁰)
     ((quote⁰ ()) (values⁰ z⁰ #f))
     (zs⁰ (values⁰ zs⁰ #t))))
   (_⁰ (values⁰ z⁰ #f))))
 (:⁰ try-transition⁰ (->⁰ zo⁰ String⁰ (U⁰ zo⁰ (Listof⁰ zo⁰) #f)))
 (define⁰
  (try-transition⁰ z⁰ str⁰)
  (match⁰
   z⁰
   ((?⁰ compilation-top?⁰) (compilation-top->⁰ z⁰ str⁰))
   ((?⁰ prefix?⁰) (prefix->⁰ z⁰ str⁰))
   ((?⁰ global-bucket?⁰) (global-bucket->⁰ z⁰ str⁰))
   ((?⁰ module-variable?⁰) (module-variable->⁰ z⁰ str⁰))
   ((?⁰ stx?⁰) (stx->⁰ z⁰ str⁰))
   ((?⁰ form?⁰) (form->⁰ z⁰ str⁰))
   ((?⁰ stx-obj?⁰) (stx-obj->⁰ z⁰ str⁰))
   ((?⁰ wrap?⁰) (wrap->⁰ z⁰ str⁰))
   ((?⁰ module-shift?⁰) (module-shift->⁰ z⁰ str⁰))
   ((?⁰ scope?⁰) (scope->⁰ z⁰ str⁰))
   ((?⁰ multi-scope?⁰) (multi-scope->⁰ z⁰ str⁰))
   ((?⁰ binding?⁰) (binding->⁰ z⁰ str⁰))
   ((?⁰ provided?⁰) (provided->⁰ z⁰ str⁰))
   ((?⁰ all-from-module?⁰) (all-from-module->⁰ z⁰ str⁰))
   (x⁰ #f)))
 (:⁰ form->⁰ (->⁰ zo⁰ String⁰ (U⁰ zo⁰ (Listof⁰ zo⁰) #f)))
 (define⁰
  (form->⁰ z⁰ str⁰)
  (match⁰
   z⁰
   ((?⁰ def-values?⁰) (def-values->⁰ z⁰ str⁰))
   ((?⁰ def-syntaxes?⁰) (def-syntaxes->⁰ z⁰ str⁰))
   ((?⁰ seq-for-syntax?⁰) (seq-for-syntax->⁰ z⁰ str⁰))
   ((?⁰ req?⁰) (req->⁰ z⁰ str⁰))
   ((?⁰ seq?⁰) (seq->⁰ z⁰ str⁰))
   ((?⁰ splice?⁰) (splice->⁰ z⁰ str⁰))
   ((?⁰ inline-variant?⁰) (inline-variant->⁰ z⁰ str⁰))
   ((?⁰ mod?⁰) (mod->⁰ z⁰ str⁰))
   ((?⁰ expr?⁰) (expr->⁰ z⁰ str⁰))
   (x⁰ #f)))
 (:⁰ expr->⁰ (->⁰ zo⁰ String⁰ (U⁰ zo⁰ (Listof⁰ zo⁰) #f)))
 (define⁰
  (expr->⁰ z⁰ str⁰)
  (match⁰
   z⁰
   ((?⁰ lam?⁰) (lam->⁰ z⁰ str⁰))
   ((?⁰ closure?⁰) (closure->⁰ z⁰ str⁰))
   ((?⁰ case-lam?⁰) (case-lam->⁰ z⁰ str⁰))
   ((?⁰ let-one?⁰) (let-one->⁰ z⁰ str⁰))
   ((?⁰ let-void?⁰) (let-void->⁰ z⁰ str⁰))
   ((?⁰ install-value?⁰) (install-value->⁰ z⁰ str⁰))
   ((?⁰ let-rec?⁰) (let-rec->⁰ z⁰ str⁰))
   ((?⁰ boxenv?⁰) (boxenv->⁰ z⁰ str⁰))
   ((?⁰ localref?⁰) (localref->⁰ z⁰ str⁰))
   ((?⁰ toplevel?⁰) (toplevel->⁰ z⁰ str⁰))
   ((?⁰ topsyntax?⁰) (topsyntax->⁰ z⁰ str⁰))
   ((?⁰ application?⁰) (application->⁰ z⁰ str⁰))
   ((?⁰ branch?⁰) (branch->⁰ z⁰ str⁰))
   ((?⁰ with-cont-mark?⁰) (with-cont-mark->⁰ z⁰ str⁰))
   ((?⁰ beg0?⁰) (beg0->⁰ z⁰ str⁰))
   ((?⁰ varref?⁰) (varref->⁰ z⁰ str⁰))
   ((?⁰ assign?⁰) (assign->⁰ z⁰ str⁰))
   ((?⁰ apply-values?⁰) (apply-values->⁰ z⁰ str⁰))
   ((?⁰ with-immed-mark?⁰) (with-immed-mark->⁰ z⁰ str⁰))
   ((?⁰ primval?⁰) (primval->⁰ z⁰ str⁰))
   (x⁰ #f)))
 (:⁰ binding->⁰ (->⁰ binding⁰ String⁰ (U⁰ zo⁰ (Listof⁰ zo⁰) #f)))
 (define⁰
  (binding->⁰ z⁰ str⁰)
  (match⁰
   z⁰
   ((?⁰ module-binding?⁰) (module-binding->⁰ z⁰ str⁰))
   ((?⁰ decoded-module-binding?⁰) (decoded-module-binding->⁰ z⁰ str⁰))
   ((?⁰ local-binding?⁰) (local-binding->⁰ z⁰ str⁰))
   ((?⁰ free-id=?-binding?⁰) (free-id=?-binding->⁰ z⁰ str⁰))
   (x⁰ #f)))
 (:⁰
  compilation-top->⁰
  (->⁰ compilation-top⁰ String⁰ (U⁰ zo⁰ (Listof⁰ zo⁰) #f)))
 (define⁰
  (compilation-top->⁰ z⁰ field-name⁰)
  (match⁰
   field-name⁰
   (prefix (compilation-top-prefix⁰ z⁰))
   (code
    (:⁰ res⁰ (U⁰ form⁰ Any⁰))
    (define⁰ res⁰ (compilation-top-code⁰ z⁰))
    (if⁰ (form?⁰ res⁰) res⁰ #f))
   (_⁰ #f)))
 (:⁰ prefix->⁰ (->⁰ prefix⁰ String⁰ (U⁰ zo⁰ (Listof⁰ zo⁰) #f)))
 (define⁰
  (prefix->⁰ z⁰ field-name⁰)
  (define⁰ gb-or-mv?⁰ l233⁰)
  (match⁰
   field-name⁰
   (toplevels (filter⁰ gb-or-mv?⁰ (prefix-toplevels⁰ z⁰)))
   (stxs (for/list⁰ :⁰ (Listof⁰ zo⁰) ((sx⁰ (prefix-stxs⁰ z⁰)) #:when sx⁰) sx⁰))
   (_⁰ #f)))
 (:⁰ global-bucket->⁰ (->⁰ global-bucket⁰ String⁰ (U⁰ zo⁰ (Listof⁰ zo⁰) #f)))
 (define⁰ (global-bucket->⁰ z⁰ field-name⁰) #f)
 (:⁰
  module-variable->⁰
  (->⁰ module-variable⁰ String⁰ (U⁰ zo⁰ (Listof⁰ zo⁰) #f)))
 (define⁰ (module-variable->⁰ z⁰ field-name⁰) #f)
 (:⁰ stx->⁰ (->⁰ stx⁰ String⁰ (U⁰ zo⁰ (Listof⁰ zo⁰) #f)))
 (define⁰
  (stx->⁰ z⁰ field-name⁰)
  (match⁰ field-name⁰ (content (stx-content⁰ z⁰)) (_⁰ #f)))
 (:⁰
  all-from-module->⁰
  (->⁰ all-from-module⁰ String⁰ (U⁰ zo⁰ (Listof⁰ zo⁰) #f)))
 (define⁰ (all-from-module->⁰ z⁰ field-name⁰) #f)
 (:⁰ def-values->⁰ (->⁰ def-values⁰ String⁰ (U⁰ zo⁰ (Listof⁰ zo⁰) #f)))
 (define⁰
  (def-values->⁰ z⁰ field-name⁰)
  (match⁰
   field-name⁰
   (ids (filter⁰ toplevel?⁰ (def-values-ids⁰ z⁰)))
   (rhs
    (match⁰
     (def-values-rhs⁰ z⁰)
     ((or⁰ (?⁰ expr?⁰ rhs⁰) (?⁰ seq?⁰ rhs⁰) (?⁰ inline-variant?⁰ rhs⁰)) rhs⁰)
     (_⁰ #f)))
   (_⁰ #f)))
 (:⁰ def-syntaxes->⁰ (->⁰ def-syntaxes⁰ String⁰ (U⁰ zo⁰ (Listof⁰ zo⁰) #f)))
 (define⁰
  (def-syntaxes->⁰ z⁰ field-name⁰)
  (match⁰
   field-name⁰
   (ids (filter⁰ toplevel?⁰ (def-syntaxes-ids⁰ z⁰)))
   (rhs
    (match⁰
     (def-syntaxes-rhs⁰ z⁰)
     ((or⁰ (?⁰ expr?⁰ rhs⁰) (?⁰ seq?⁰ rhs⁰)) rhs⁰)
     (_⁰ #f)))
   (prefix (def-syntaxes-prefix⁰ z⁰))
   (dummy (match⁰ (def-syntaxes-dummy⁰ z⁰) ((?⁰ toplevel?⁰ dm⁰) dm⁰) (_⁰ #f)))
   (_⁰ #f)))
 (:⁰ seq-for-syntax->⁰ (->⁰ seq-for-syntax⁰ String⁰ (U⁰ zo⁰ (Listof⁰ zo⁰) #f)))
 (define⁰
  (seq-for-syntax->⁰ z⁰ field-name⁰)
  (match⁰
   field-name⁰
   (forms (filter⁰ form?⁰ (seq-for-syntax-forms⁰ z⁰)))
   (prefix (seq-for-syntax-prefix⁰ z⁰))
   (dummy
    (match⁰ (seq-for-syntax-dummy⁰ z⁰) ((?⁰ toplevel?⁰ dm⁰) dm⁰) (_⁰ #f)))
   (_⁰ #f)))
 (:⁰ req->⁰ (->⁰ req⁰ String⁰ (U⁰ zo⁰ (Listof⁰ zo⁰) #f)))
 (define⁰
  (req->⁰ z⁰ field-name⁰)
  (match⁰ field-name⁰ (reqs (req-reqs⁰ z⁰)) (dummy (req-dummy⁰ z⁰)) (_⁰ #f)))
 (:⁰ seq->⁰ (->⁰ seq⁰ String⁰ (U⁰ zo⁰ (Listof⁰ zo⁰) #f)))
 (define⁰
  (seq->⁰ z⁰ field-name⁰)
  (match⁰ field-name⁰ (forms (filter⁰ form?⁰ (seq-forms⁰ z⁰))) (_⁰ #f)))
 (:⁰ splice->⁰ (->⁰ splice⁰ String⁰ (U⁰ zo⁰ (Listof⁰ zo⁰) #f)))
 (define⁰
  (splice->⁰ z⁰ field-name⁰)
  (match⁰ field-name⁰ (forms (filter⁰ form?⁰ (splice-forms⁰ z⁰))) (_⁰ #f)))
 (:⁰ inline-variant->⁰ (->⁰ inline-variant⁰ String⁰ (U⁰ zo⁰ (Listof⁰ zo⁰) #f)))
 (define⁰
  (inline-variant->⁰ z⁰ field-name⁰)
  (match⁰
   field-name⁰
   (direct (inline-variant-direct⁰ z⁰))
   (inline (inline-variant-inline⁰ z⁰))
   (_⁰ #f)))
 (:⁰ mod->⁰ (->⁰ mod⁰ String⁰ (U⁰ zo⁰ (Listof⁰ zo⁰) #f)))
 (define⁰
  (mod->⁰ z⁰ field-name⁰)
  (:⁰
   get-provided⁰
   (->⁰
    (Listof⁰ (List⁰ (U⁰ Integer⁰ #f) (Listof⁰ provided⁰) (Listof⁰ provided⁰)))
    (Listof⁰ provided⁰)))
  (define⁰
   (get-provided⁰ pds⁰)
   (cond⁰
    ((empty?⁰ pds⁰) empty⁰)
    (else⁰
     (append⁰ (cadar⁰ pds⁰) (caddar⁰ pds⁰) (get-provided⁰ (cdr⁰ pds⁰))))))
  (:⁰
   get-syntaxes⁰
   (->⁰
    (Listof⁰
     (Pair⁰
      Exact-Positive-Integer⁰
      (Listof⁰ (U⁰ def-syntaxes⁰ seq-for-syntax⁰))))
    (Listof⁰ (U⁰ def-syntaxes⁰ seq-for-syntax⁰))))
  (define⁰
   (get-syntaxes⁰ sxs⁰)
   (cond⁰
    ((empty?⁰ sxs⁰) empty⁰)
    (else⁰ (append⁰ (cdar⁰ sxs⁰) (get-syntaxes⁰ (cdr⁰ sxs⁰))))))
  (match⁰
   field-name⁰
   (prefix (mod-prefix⁰ z⁰))
   (provides (get-provided⁰ (mod-provides⁰ z⁰)))
   (body (filter⁰ form?⁰ (mod-body⁰ z⁰)))
   (syntax-bodies (get-syntaxes⁰ (mod-syntax-bodies⁰ z⁰)))
   (dummy (mod-dummy⁰ z⁰))
   (internal-context
    (match⁰
     (mod-internal-context⁰ z⁰)
     ((?⁰ stx?⁰ ic⁰) ic⁰)
     ((?⁰ vector?⁰ ic⁰) (vector->list⁰ ic⁰))
     (_⁰ #f)))
   (pre-submodules (mod-pre-submodules⁰ z⁰))
   (post-submodules (mod-post-submodules⁰ z⁰))
   (_⁰ #f)))
 (:⁰ provided->⁰ (->⁰ provided⁰ String⁰ (U⁰ zo⁰ (Listof⁰ zo⁰) #f)))
 (define⁰ (provided->⁰ z⁰ field-name⁰) #f)
 (:⁰ lam->⁰ (->⁰ lam⁰ String⁰ (U⁰ zo⁰ (Listof⁰ zo⁰) #f)))
 (define⁰
  (lam->⁰ z⁰ field-name⁰)
  (match⁰
   field-name⁰
   (body (match⁰ (lam-body⁰ z⁰) ((?⁰ expr-or-seq?⁰ bd⁰) bd⁰) (_x⁰ #f)))
   (_⁰ #f)))
 (:⁰ closure->⁰ (->⁰ closure⁰ String⁰ (U⁰ zo⁰ (Listof⁰ zo⁰) #f)))
 (define⁰
  (closure->⁰ z⁰ field-name⁰)
  (match⁰ field-name⁰ (code (closure-code⁰ z⁰)) (_⁰ #f)))
 (:⁰ case-lam->⁰ (->⁰ case-lam⁰ String⁰ (U⁰ zo⁰ (Listof⁰ zo⁰) #f)))
 (define⁰
  (case-lam->⁰ z⁰ field-name⁰)
  (match⁰ field-name⁰ (clauses (case-lam-clauses⁰ z⁰)) (_⁰ #f)))
 (:⁰ let-one->⁰ (->⁰ let-one⁰ String⁰ (U⁰ zo⁰ (Listof⁰ zo⁰) #f)))
 (define⁰
  (let-one->⁰ z⁰ field-name⁰)
  (match⁰
   field-name⁰
   (rhs (match⁰ (let-one-rhs⁰ z⁰) ((?⁰ expr-or-seq?⁰ rhs⁰) rhs⁰) (_⁰ #f)))
   (body (match⁰ (let-one-body⁰ z⁰) ((?⁰ expr-or-seq?⁰ body⁰) body⁰) (_⁰ #f)))
   (_⁰ #f)))
 (:⁰ let-void->⁰ (->⁰ let-void⁰ String⁰ (U⁰ zo⁰ (Listof⁰ zo⁰) #f)))
 (define⁰
  (let-void->⁰ z⁰ field-name⁰)
  (match⁰
   field-name⁰
   (body (match⁰ (let-void-body⁰ z⁰) ((?⁰ expr-or-seq?⁰ body⁰) body⁰) (_⁰ #f)))
   (_⁰ #f)))
 (:⁰ install-value->⁰ (->⁰ install-value⁰ String⁰ (U⁰ zo⁰ (Listof⁰ zo⁰) #f)))
 (define⁰
  (install-value->⁰ z⁰ field-name⁰)
  (match⁰
   field-name⁰
   (rhs
    (match⁰ (install-value-rhs⁰ z⁰) ((?⁰ expr-or-seq?⁰ rhs⁰) rhs⁰) (_⁰ #f)))
   (body
    (match⁰ (install-value-body⁰ z⁰) ((?⁰ expr-or-seq?⁰ body⁰) body⁰) (_⁰ #f)))
   (_⁰ #f)))
 (:⁰ let-rec->⁰ (->⁰ let-rec⁰ String⁰ (U⁰ zo⁰ (Listof⁰ zo⁰) #f)))
 (define⁰
  (let-rec->⁰ z⁰ field-name⁰)
  (match⁰
   field-name⁰
   (procs (let-rec-procs⁰ z⁰))
   (body (match⁰ (let-rec-body⁰ z⁰) ((?⁰ expr-or-seq?⁰ body⁰) body⁰) (_⁰ #f)))
   (_⁰ #f)))
 (:⁰ boxenv->⁰ (->⁰ boxenv⁰ String⁰ (U⁰ zo⁰ (Listof⁰ zo⁰) #f)))
 (define⁰
  (boxenv->⁰ z⁰ field-name⁰)
  (match⁰
   field-name⁰
   (body (match⁰ (boxenv-body⁰ z⁰) ((?⁰ expr-or-seq?⁰ body⁰) body⁰) (_⁰ #f)))
   (_⁰ #f)))
 (:⁰ localref->⁰ (->⁰ localref⁰ String⁰ (U⁰ zo⁰ (Listof⁰ zo⁰) #f)))
 (define⁰ (localref->⁰ z⁰ field-name⁰) #f)
 (:⁰ toplevel->⁰ (->⁰ toplevel⁰ String⁰ (U⁰ zo⁰ (Listof⁰ zo⁰) #f)))
 (define⁰ (toplevel->⁰ z⁰ field-name⁰) #f)
 (:⁰ topsyntax->⁰ (->⁰ topsyntax⁰ String⁰ (U⁰ zo⁰ (Listof⁰ zo⁰) #f)))
 (define⁰ (topsyntax->⁰ z⁰ field-name⁰) #f)
 (:⁰ application->⁰ (->⁰ application⁰ String⁰ (U⁰ zo⁰ (Listof⁰ zo⁰) #f)))
 (define⁰
  (application->⁰ z⁰ field-name⁰)
  (match⁰
   field-name⁰
   (rator
    (match⁰
     (application-rator⁰ z⁰)
     ((?⁰ expr-or-seq?⁰ rator⁰) rator⁰)
     (_⁰ #f)))
   (rands (filter⁰ expr-or-seq?⁰ (application-rands⁰ z⁰)))
   (_⁰ #f)))
 (:⁰ branch->⁰ (->⁰ branch⁰ String⁰ (U⁰ zo⁰ (Listof⁰ zo⁰) #f)))
 (define⁰
  (branch->⁰ z⁰ field-name⁰)
  (match⁰
   field-name⁰
   (test (match⁰ (branch-test⁰ z⁰) ((?⁰ expr-or-seq?⁰ test⁰) test⁰) (_⁰ #f)))
   (then (match⁰ (branch-then⁰ z⁰) ((?⁰ expr-or-seq?⁰ then⁰) then⁰) (_⁰ #f)))
   (else (match⁰ (branch-else⁰ z⁰) ((?⁰ expr-or-seq?⁰ el⁰) el⁰) (_⁰ #f)))
   (_⁰ #f)))
 (:⁰ with-cont-mark->⁰ (->⁰ with-cont-mark⁰ String⁰ (U⁰ zo⁰ (Listof⁰ zo⁰) #f)))
 (define⁰
  (with-cont-mark->⁰ z⁰ field-name⁰)
  (match⁰
   field-name⁰
   (key
    (match⁰ (with-cont-mark-key⁰ z⁰) ((?⁰ expr-or-seq?⁰ key⁰) key⁰) (_⁰ #f)))
   (val
    (match⁰ (with-cont-mark-val⁰ z⁰) ((?⁰ expr-or-seq?⁰ val⁰) val⁰) (_⁰ #f)))
   (body
    (match⁰
     (with-cont-mark-body⁰ z⁰)
     ((?⁰ expr-or-seq?⁰ body⁰) body⁰)
     (_⁰ #f)))
   (_⁰ #f)))
 (:⁰ beg0->⁰ (->⁰ beg0⁰ String⁰ (U⁰ zo⁰ (Listof⁰ zo⁰) #f)))
 (define⁰
  (beg0->⁰ z⁰ field-name⁰)
  (match⁰ field-name⁰ (seq (filter⁰ expr-or-seq?⁰ (beg0-seq⁰ z⁰))) (_⁰ #f)))
 (:⁰ varref->⁰ (->⁰ varref⁰ String⁰ (U⁰ zo⁰ (Listof⁰ zo⁰) #f)))
 (define⁰
  (varref->⁰ z⁰ field-name⁰)
  (match⁰
   field-name⁰
   (toplevel (match⁰ (varref-toplevel⁰ z⁰) ((?⁰ toplevel?⁰ tl⁰) tl⁰) (_⁰ #f)))
   (dummy (match⁰ (varref-dummy⁰ z⁰) ((?⁰ toplevel?⁰ dm⁰) dm⁰) (_⁰ #f)))
   (_⁰ #f)))
 (:⁰ assign->⁰ (->⁰ assign⁰ String⁰ (U⁰ zo⁰ (Listof⁰ zo⁰) #f)))
 (define⁰
  (assign->⁰ z⁰ field-name⁰)
  (match⁰
   field-name⁰
   (id (assign-id⁰ z⁰))
   (rhs (match⁰ (assign-rhs⁰ z⁰) ((?⁰ expr-or-seq?⁰ rhs⁰) rhs⁰) (_⁰ #f)))
   (_⁰ #f)))
 (:⁰ apply-values->⁰ (->⁰ apply-values⁰ String⁰ (U⁰ zo⁰ (Listof⁰ zo⁰) #f)))
 (define⁰
  (apply-values->⁰ z⁰ field-name⁰)
  (match⁰
   field-name⁰
   (proc
    (match⁰ (apply-values-proc⁰ z⁰) ((?⁰ expr-or-seq?⁰ proc⁰) proc⁰) (_⁰ #f)))
   (args-expr
    (match⁰
     (apply-values-args-expr⁰ z⁰)
     ((?⁰ expr-or-seq?⁰ args-expr⁰) args-expr⁰)
     (_⁰ #f)))
   (_⁰ #f)))
 (:⁰
  with-immed-mark->⁰
  (->⁰ with-immed-mark⁰ String⁰ (U⁰ zo⁰ (Listof⁰ zo⁰) #f)))
 (define⁰
  (with-immed-mark->⁰ z⁰ field-name⁰)
  (match⁰
   field-name⁰
   (key
    (match⁰
     (with-immed-mark-key⁰ z⁰)
     ((?⁰ expr-or-seq?⁰ proc⁰) proc⁰)
     (_⁰ #f)))
   (def-val
    (match⁰
     (with-immed-mark-def-val⁰ z⁰)
     ((?⁰ expr-or-seq?⁰ args-expr⁰) args-expr⁰)
     (_⁰ #f)))
   (body
    (match⁰
     (with-immed-mark-body⁰ z⁰)
     ((?⁰ expr-or-seq?⁰ proc⁰) proc⁰)
     (_⁰ #f)))
   (_⁰ #f)))
 (:⁰ primval->⁰ (->⁰ primval⁰ String⁰ (U⁰ zo⁰ (Listof⁰ zo⁰) #f)))
 (define⁰ (primval->⁰ z⁰ field-name⁰) #f)
 (:⁰ stx-obj->⁰ (->⁰ stx-obj⁰ String⁰ (U⁰ zo⁰ (Listof⁰ zo⁰) #f)))
 (define⁰
  (stx-obj->⁰ z⁰ field-name⁰)
  (match⁰ field-name⁰ (wrap (stx-obj-wrap⁰ z⁰)) (_⁰ #f)))
 (:⁰ wrap->⁰ (->⁰ wrap⁰ String⁰ (U⁰ zo⁰ (Listof⁰ zo⁰) #f)))
 (define⁰
  (wrap->⁰ z⁰ field-name⁰)
  (match⁰
   field-name⁰
   (shifts (wrap-shifts⁰ z⁰))
   (simple-scopes (wrap-simple-scopes⁰ z⁰))
   (multi-scopes
    (for/list⁰
     :⁰
     (Listof⁰ zo⁰)
     ((ms⁰ :⁰ (List⁰ multi-scope⁰ (U⁰ #f Integer⁰)) (wrap-multi-scopes⁰ z⁰)))
     (car⁰ ms⁰)))
   (_⁰ #f)))
 (:⁰ module-shift->⁰ (->⁰ module-shift⁰ String⁰ (U⁰ zo⁰ (Listof⁰ zo⁰) #f)))
 (define⁰ (module-shift->⁰ z⁰ field-name⁰) (match⁰ field-name⁰ (_⁰ #f)))
 (:⁰ scope->⁰ (->⁰ scope⁰ String⁰ (U⁰ zo⁰ (Listof⁰ zo⁰) #f)))
 (define⁰
  (scope->⁰ z⁰ field-name⁰)
  (:⁰
   get-bindings⁰
   (->⁰ (Listof⁰ (List⁰ Symbol⁰ (Listof⁰ scope⁰) binding⁰)) (Listof⁰ zo⁰)))
  (define⁰
   (get-bindings⁰ bs⁰)
   (cond⁰
    ((empty?⁰ bs⁰) (quote⁰ ()))
    (else⁰ (append⁰ (cadar⁰ bs⁰) (cddar⁰ bs⁰) (get-bindings⁰ (cdr⁰ bs⁰))))))
  (:⁰
   get-bulk-bindings⁰
   (->⁰ (Listof⁰ (List⁰ (Listof⁰ scope⁰) all-from-module⁰)) (Listof⁰ zo⁰)))
  (define⁰
   (get-bulk-bindings⁰ bbs⁰)
   (cond⁰
    ((empty?⁰ bbs⁰) (quote⁰ ()))
    (else⁰
     (append⁰ (caar⁰ bbs⁰) (cdar⁰ bbs⁰) (get-bulk-bindings⁰ (cdr⁰ bbs⁰))))))
  (match⁰
   field-name⁰
   (bindings (get-bindings⁰ (scope-bindings⁰ z⁰)))
   (bulk-bindings (get-bulk-bindings⁰ (scope-bulk-bindings⁰ z⁰)))
   (multi-owner (scope-multi-owner⁰ z⁰))
   (_⁰ #f)))
 (:⁰ multi-scope->⁰ (->⁰ multi-scope⁰ String⁰ (U⁰ zo⁰ (Listof⁰ zo⁰) #f)))
 (define⁰
  (multi-scope->⁰ z⁰ field-name⁰)
  (match⁰
   field-name⁰
   (scopes
    (for/list⁰
     :⁰
     (Listof⁰ zo⁰)
     ((mss⁰ :⁰ (List⁰ (U⁰ #f Integer⁰) scope⁰) (multi-scope-scopes⁰ z⁰)))
     (cadr⁰ mss⁰)))
   (_⁰ #f)))
 (:⁰ module-binding->⁰ (->⁰ module-binding⁰ String⁰ (U⁰ zo⁰ (Listof⁰ zo⁰) #f)))
 (define⁰ (module-binding->⁰ z⁰ field-name⁰) (match⁰ field-name⁰ (_⁰ #f)))
 (:⁰
  decoded-module-binding->⁰
  (->⁰ decoded-module-binding⁰ String⁰ (U⁰ zo⁰ (Listof⁰ zo⁰) #f)))
 (define⁰
  (decoded-module-binding->⁰ z⁰ field-name⁰)
  (match⁰ field-name⁰ (_⁰ #f)))
 (:⁰ local-binding->⁰ (->⁰ local-binding⁰ String⁰ (U⁰ zo⁰ (Listof⁰ zo⁰) #f)))
 (define⁰ (local-binding->⁰ z⁰ field-name⁰) #f)
 (:⁰
  free-id=?-binding->⁰
  (->⁰ free-id=?-binding⁰ String⁰ (U⁰ zo⁰ (Listof⁰ zo⁰) #f)))
 (define⁰
  (free-id=?-binding->⁰ z⁰ field-name⁰)
  (match⁰
   field-name⁰
   (base (free-id=?-binding-base⁰ z⁰))
   (id (free-id=?-binding-id⁰ z⁰))
   (_⁰ #f)))
 (define⁰ expr-or-seq?⁰ l1⁰)).
scv-cr: Modules are (/home/camoy/wrk/scv-cr/test/zordoz/compiler-zo-structs.rkt /home/camoy/wrk/scv-cr/test/zordoz/typed-zo-structs.rkt /home/camoy/wrk/scv-cr/test/zordoz/zo-string.rkt /home/camoy/wrk/scv-cr/test/zordoz/zo-transition.rkt /home/camoy/wrk/scv-cr/test/zordoz/zo-find.rkt /home/camoy/wrk/scv-cr/test/zordoz/zo-shell.rkt /home/camoy/wrk/scv-cr/test/zordoz/main.rkt).
scv-cr: Compiling.
scv-cr: Optimizing.
scv-cr: Optimizing the modules (/home/camoy/wrk/scv-cr/test/zordoz/compiler-zo-structs.rkt /home/camoy/wrk/scv-cr/test/zordoz/typed-zo-structs.rkt /home/camoy/wrk/scv-cr/test/zordoz/zo-string.rkt /home/camoy/wrk/scv-cr/test/zordoz/zo-transition.rkt /home/camoy/wrk/scv-cr/test/zordoz/zo-find.rkt /home/camoy/wrk/scv-cr/test/zordoz/zo-shell.rkt /home/camoy/wrk/scv-cr/test/zordoz/main.rkt).
scv-cr: Analysis result ().
scv-cr: Compiling.
