* Flatt's sets of scopes [paper](https://www.cs.utah.edu/plt/scope-sets/) is helpful for
  understanding how to manipulate syntax in the weird ways that are needed for this kind
  of stuff (the [talk](https://www.youtube.com/watch?v=OmA6oTxWMBs) is also great).
* `main.rkt`
  * `compile-files/scv-cr` is the entry point that compiles and optimizes source code at
    the given paths.
  * The two key calls here are to `make-mod` and `optimize`. The `make-mod` corresponds
    to the first phase in the diagram from the paper, extracting contracts and inserting
    them into the syntax. The `optimize` function corresponds to the second phase that
    analyzes and bypasses contracts.

## Phase 1

* `elaborate.rkt`
  * `make-mod` will do different things depending on if the target is typed or not.
    The typed case is the one that's interesting.
  * This also has two steps: `make-contracts` and `elaborate`. The former makes a
    contracts struct (see `data.rkt`) and the latter uses this information
    to inject contracts into the syntax.
  * How do we get the contracts? The `expand/dir` helps here.
* `compile.rkt`
  * The `expand/dir` function expands the typed module in an environment with a modified
    Typed Racket. We proxy the [compiled-load handler](https://docs.racket-lang.org/reference/eval.html?q=compile-load#%28tech._compiled._load._handler%29)
    to use our modified Typed Racket code only for certain modules.
  * This modified TR (found in `lib-typed-racket/`) stashes unexpanded contract definitions
    in syntax object properties. These are preserved after expansion and can be read later.
  * (Note that we can't do the obvious thing of mutating some SCV-CR hashes from TR because of the [separate compilation guarantee](https://lexi-lambda.github.io/blog/2019/04/21/defeating-racket-s-separate-compilation-guarantee/)).
* `extract.rkt`
  * Provides the `make-contracts` function. This looks at the expanded syntax and extracts out those contract definitions from the syntax object properties.
  * It then cleans up all this information and puts it into a standardized form.
  * The information is similar for provide contracts and require contracts, so the contract struct is made up of two "bundles" that contain the information for each.
* Back to `elaborate.rkt`
  * The `elaborate` function takes these bundles and injects new provide forms and require forms with the appropriate contracts attached for each.
  * You can see the result of this operation by using `raco scv-cr -w` to write the module with explicit contracts.
  * Notice also the lang changed, to "specialty" lang. This is to provide additional manipulations. E.g. here instead of actually erasing the type annotations, we let the lang just ignore them, it's much easier to do this way.
  * Implementations of these langs are in `lang/scv/`.

## Phase 2

* See `optimize.rkt`.
* The `optimize` function does two things: `make-blames` and `optimize-mods`.
* `make-blames` runs SCV and returns the analysis result (the call to pay attention to is `verify-modules`).
* `optimize-mods` takes this blame information and determines which identifiers need to be kept in.
* These are identifiers that rely on a contract dependency that is blameable. The dependency graph is constructed and do a search through this graph.
* These identifiers are computed by `unsafe` and stored in an "unsafe hash". That unsafe hash is passed along to the module and is used for bypassing.
* This is the second time where we use specialty langs, this time in `lang/opt`. Those langs use the unsafe identifiers to do the bypassing work.
* Set the environment variable `PLTSTDOUT` to `debug@scv-cr` to see debug output while running `raco scv-cr`. This will show lots of the intermediate data structures as well as SCV's analysis.

## Micellaneous Bits

* SCV can't handle all TR's contracts directly, so that's why we have `munge.rkt`.
* Opaque modules need special handling, that's what `opaque.rkt` does. This is kinda complicated and the nasty details are in `lang/scv/common.rkt`.
* Opaque modules can be explicitly marked, but SCV-CR can actually detect them automatically (although this slows down things a lot since the analysis needs to be restarted). When SCV can't find an identifier, we mark the source module as opaque and go again (see exception handler in `make-blames`).
* Structs need a lot of special casing. There's an incompatibility because TR generates contracts for struct stuff individually (i.e. it generates contracts separately for each definition generated by a `struct` form).
* We basically need to recreate the `(contract-out (struct ...))` information from the individual pieces. Including handling struct hierarchies (since structs can have parents).
* The "reconstruction" work is in `struct.rkt` which puts a `structs-data` value in the require and provide bundles containing all struct information.
